{"ast":null,"code":"import { decodedMappings, traceSegment, TraceMap } from '@jridgewell/trace-mapping';\nimport { GenMapping, addSegment, setSourceContent, decodedMap, encodedMap } from '@jridgewell/gen-mapping';\nconst SOURCELESS_MAPPING = {\n  source: null,\n  column: null,\n  line: null,\n  name: null,\n  content: null\n};\nconst EMPTY_SOURCES = [];\n\nfunction Source(map, sources, source, content) {\n  return {\n    map,\n    sources,\n    source,\n    content\n  };\n}\n/**\n * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes\n * (which may themselves be SourceMapTrees).\n */\n\n\nfunction MapSource(map, sources) {\n  return Source(map, sources, '', null);\n}\n/**\n * A \"leaf\" node in the sourcemap tree, representing an original, unmodified source file. Recursive\n * segment tracing ends at the `OriginalSource`.\n */\n\n\nfunction OriginalSource(source, content) {\n  return Source(null, EMPTY_SOURCES, source, content);\n}\n/**\n * traceMappings is only called on the root level SourceMapTree, and begins the process of\n * resolving each mapping in terms of the original source files.\n */\n\n\nfunction traceMappings(tree) {\n  const gen = new GenMapping({\n    file: tree.map.file\n  });\n  const {\n    sources: rootSources,\n    map\n  } = tree;\n  const rootNames = map.names;\n  const rootMappings = decodedMappings(map);\n\n  for (let i = 0; i < rootMappings.length; i++) {\n    const segments = rootMappings[i];\n    let lastSource = null;\n    let lastSourceLine = null;\n    let lastSourceColumn = null;\n\n    for (let j = 0; j < segments.length; j++) {\n      const segment = segments[j];\n      const genCol = segment[0];\n      let traced = SOURCELESS_MAPPING; // 1-length segments only move the current generated column, there's no source information\n      // to gather from it.\n\n      if (segment.length !== 1) {\n        const source = rootSources[segment[1]];\n        traced = originalPositionFor(source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : ''); // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n        // respective segment into an original source.\n\n        if (traced == null) continue;\n      } // So we traced a segment down into its original source file. Now push a\n      // new segment pointing to this location.\n\n\n      const {\n        column,\n        line,\n        name,\n        content,\n        source\n      } = traced;\n\n      if (line === lastSourceLine && column === lastSourceColumn && source === lastSource) {\n        continue;\n      }\n\n      lastSourceLine = line;\n      lastSourceColumn = column;\n      lastSource = source; // Sigh, TypeScript can't figure out source/line/column are either all null, or all non-null...\n\n      addSegment(gen, i, genCol, source, line, column, name);\n      if (content != null) setSourceContent(gen, source, content);\n    }\n  }\n\n  return gen;\n}\n/**\n * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own\n * child SourceMapTrees, until we find the original source map.\n */\n\n\nfunction originalPositionFor(source, line, column, name) {\n  if (!source.map) {\n    return {\n      column,\n      line,\n      name,\n      source: source.source,\n      content: source.content\n    };\n  }\n\n  const segment = traceSegment(source.map, line, column); // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n\n  if (segment == null) return null; // 1-length segments only move the current generated column, there's no source information\n  // to gather from it.\n\n  if (segment.length === 1) return SOURCELESS_MAPPING;\n  return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);\n}\n\nfunction asArray(value) {\n  if (Array.isArray(value)) return value;\n  return [value];\n}\n/**\n * Recursively builds a tree structure out of sourcemap files, with each node\n * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n * `OriginalSource`s and `SourceMapTree`s.\n *\n * Every sourcemap is composed of a collection of source files and mappings\n * into locations of those source files. When we generate a `SourceMapTree` for\n * the sourcemap, we attempt to load each source file's own sourcemap. If it\n * does not have an associated sourcemap, it is considered an original,\n * unmodified source file.\n */\n\n\nfunction buildSourceMapTree(input, loader) {\n  const maps = asArray(input).map(m => new TraceMap(m, ''));\n  const map = maps.pop();\n\n  for (let i = 0; i < maps.length; i++) {\n    if (maps[i].sources.length > 1) {\n      throw new Error(`Transformation map ${i} must have exactly one source file.\\n` + 'Did you specify these with the most recent transformation maps first?');\n    }\n  }\n\n  let tree = build(map, loader, '', 0);\n\n  for (let i = maps.length - 1; i >= 0; i--) {\n    tree = MapSource(maps[i], [tree]);\n  }\n\n  return tree;\n}\n\nfunction build(map, loader, importer, importerDepth) {\n  const {\n    resolvedSources,\n    sourcesContent\n  } = map;\n  const depth = importerDepth + 1;\n  const children = resolvedSources.map((sourceFile, i) => {\n    // The loading context gives the loader more information about why this file is being loaded\n    // (eg, from which importer). It also allows the loader to override the location of the loaded\n    // sourcemap/original source, or to override the content in the sourcesContent field if it's\n    // an unmodified source file.\n    const ctx = {\n      importer,\n      depth,\n      source: sourceFile || '',\n      content: undefined\n    }; // Use the provided loader callback to retrieve the file's sourcemap.\n    // TODO: We should eventually support async loading of sourcemap files.\n\n    const sourceMap = loader(ctx.source, ctx);\n    const {\n      source,\n      content\n    } = ctx; // If there is a sourcemap, then we need to recurse into it to load its source files.\n\n    if (sourceMap) return build(new TraceMap(sourceMap, source), loader, source, depth); // Else, it's an an unmodified source file.\n    // The contents of this unmodified source file can be overridden via the loader context,\n    // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n    // the importing sourcemap's `sourcesContent` field.\n\n    const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n    return OriginalSource(source, sourceContent);\n  });\n  return MapSource(map, children);\n}\n/**\n * A SourceMap v3 compatible sourcemap, which only includes fields that were\n * provided to it.\n */\n\n\nclass SourceMap {\n  constructor(map, options) {\n    const out = options.decodedMappings ? decodedMap(map) : encodedMap(map);\n    this.version = out.version; // SourceMap spec says this should be first.\n\n    this.file = out.file;\n    this.mappings = out.mappings;\n    this.names = out.names;\n    this.sourceRoot = out.sourceRoot;\n    this.sources = out.sources;\n\n    if (!options.excludeContent) {\n      this.sourcesContent = out.sourcesContent;\n    }\n  }\n\n  toString() {\n    return JSON.stringify(this);\n  }\n\n}\n/**\n * Traces through all the mappings in the root sourcemap, through the sources\n * (and their sourcemaps), all the way back to the original source location.\n *\n * `loader` will be called every time we encounter a source file. If it returns\n * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n * it returns a falsey value, that source file is treated as an original,\n * unmodified source file.\n *\n * Pass `excludeContent` to exclude any self-containing source file content\n * from the output sourcemap.\n *\n * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n * VLQ encoded) mappings.\n */\n\n\nfunction remapping(input, loader, options) {\n  const opts = typeof options === 'object' ? options : {\n    excludeContent: !!options,\n    decodedMappings: false\n  };\n  const tree = buildSourceMapTree(input, loader);\n  return new SourceMap(traceMappings(tree), opts);\n}\n\nexport { remapping as default };","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/@ampproject/remapping/dist/remapping.mjs"],"names":["decodedMappings","traceSegment","TraceMap","GenMapping","addSegment","setSourceContent","decodedMap","encodedMap","SOURCELESS_MAPPING","source","column","line","name","content","EMPTY_SOURCES","Source","map","sources","MapSource","OriginalSource","traceMappings","tree","gen","file","rootSources","rootNames","names","rootMappings","i","length","segments","lastSource","lastSourceLine","lastSourceColumn","j","segment","genCol","traced","originalPositionFor","asArray","value","Array","isArray","buildSourceMapTree","input","loader","maps","m","pop","Error","build","importer","importerDepth","resolvedSources","sourcesContent","depth","children","sourceFile","ctx","undefined","sourceMap","sourceContent","SourceMap","constructor","options","out","version","mappings","sourceRoot","excludeContent","toString","JSON","stringify","remapping","opts","default"],"mappings":"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","sourcesContent":["import { decodedMappings, traceSegment, TraceMap } from '@jridgewell/trace-mapping';\nimport { GenMapping, addSegment, setSourceContent, decodedMap, encodedMap } from '@jridgewell/gen-mapping';\n\nconst SOURCELESS_MAPPING = {\n    source: null,\n    column: null,\n    line: null,\n    name: null,\n    content: null,\n};\nconst EMPTY_SOURCES = [];\nfunction Source(map, sources, source, content) {\n    return {\n        map,\n        sources,\n        source,\n        content,\n    };\n}\n/**\n * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes\n * (which may themselves be SourceMapTrees).\n */\nfunction MapSource(map, sources) {\n    return Source(map, sources, '', null);\n}\n/**\n * A \"leaf\" node in the sourcemap tree, representing an original, unmodified source file. Recursive\n * segment tracing ends at the `OriginalSource`.\n */\nfunction OriginalSource(source, content) {\n    return Source(null, EMPTY_SOURCES, source, content);\n}\n/**\n * traceMappings is only called on the root level SourceMapTree, and begins the process of\n * resolving each mapping in terms of the original source files.\n */\nfunction traceMappings(tree) {\n    const gen = new GenMapping({ file: tree.map.file });\n    const { sources: rootSources, map } = tree;\n    const rootNames = map.names;\n    const rootMappings = decodedMappings(map);\n    for (let i = 0; i < rootMappings.length; i++) {\n        const segments = rootMappings[i];\n        let lastSource = null;\n        let lastSourceLine = null;\n        let lastSourceColumn = null;\n        for (let j = 0; j < segments.length; j++) {\n            const segment = segments[j];\n            const genCol = segment[0];\n            let traced = SOURCELESS_MAPPING;\n            // 1-length segments only move the current generated column, there's no source information\n            // to gather from it.\n            if (segment.length !== 1) {\n                const source = rootSources[segment[1]];\n                traced = originalPositionFor(source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : '');\n                // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n                // respective segment into an original source.\n                if (traced == null)\n                    continue;\n            }\n            // So we traced a segment down into its original source file. Now push a\n            // new segment pointing to this location.\n            const { column, line, name, content, source } = traced;\n            if (line === lastSourceLine && column === lastSourceColumn && source === lastSource) {\n                continue;\n            }\n            lastSourceLine = line;\n            lastSourceColumn = column;\n            lastSource = source;\n            // Sigh, TypeScript can't figure out source/line/column are either all null, or all non-null...\n            addSegment(gen, i, genCol, source, line, column, name);\n            if (content != null)\n                setSourceContent(gen, source, content);\n        }\n    }\n    return gen;\n}\n/**\n * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own\n * child SourceMapTrees, until we find the original source map.\n */\nfunction originalPositionFor(source, line, column, name) {\n    if (!source.map) {\n        return { column, line, name, source: source.source, content: source.content };\n    }\n    const segment = traceSegment(source.map, line, column);\n    // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n    if (segment == null)\n        return null;\n    // 1-length segments only move the current generated column, there's no source information\n    // to gather from it.\n    if (segment.length === 1)\n        return SOURCELESS_MAPPING;\n    return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);\n}\n\nfunction asArray(value) {\n    if (Array.isArray(value))\n        return value;\n    return [value];\n}\n/**\n * Recursively builds a tree structure out of sourcemap files, with each node\n * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n * `OriginalSource`s and `SourceMapTree`s.\n *\n * Every sourcemap is composed of a collection of source files and mappings\n * into locations of those source files. When we generate a `SourceMapTree` for\n * the sourcemap, we attempt to load each source file's own sourcemap. If it\n * does not have an associated sourcemap, it is considered an original,\n * unmodified source file.\n */\nfunction buildSourceMapTree(input, loader) {\n    const maps = asArray(input).map((m) => new TraceMap(m, ''));\n    const map = maps.pop();\n    for (let i = 0; i < maps.length; i++) {\n        if (maps[i].sources.length > 1) {\n            throw new Error(`Transformation map ${i} must have exactly one source file.\\n` +\n                'Did you specify these with the most recent transformation maps first?');\n        }\n    }\n    let tree = build(map, loader, '', 0);\n    for (let i = maps.length - 1; i >= 0; i--) {\n        tree = MapSource(maps[i], [tree]);\n    }\n    return tree;\n}\nfunction build(map, loader, importer, importerDepth) {\n    const { resolvedSources, sourcesContent } = map;\n    const depth = importerDepth + 1;\n    const children = resolvedSources.map((sourceFile, i) => {\n        // The loading context gives the loader more information about why this file is being loaded\n        // (eg, from which importer). It also allows the loader to override the location of the loaded\n        // sourcemap/original source, or to override the content in the sourcesContent field if it's\n        // an unmodified source file.\n        const ctx = {\n            importer,\n            depth,\n            source: sourceFile || '',\n            content: undefined,\n        };\n        // Use the provided loader callback to retrieve the file's sourcemap.\n        // TODO: We should eventually support async loading of sourcemap files.\n        const sourceMap = loader(ctx.source, ctx);\n        const { source, content } = ctx;\n        // If there is a sourcemap, then we need to recurse into it to load its source files.\n        if (sourceMap)\n            return build(new TraceMap(sourceMap, source), loader, source, depth);\n        // Else, it's an an unmodified source file.\n        // The contents of this unmodified source file can be overridden via the loader context,\n        // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n        // the importing sourcemap's `sourcesContent` field.\n        const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n        return OriginalSource(source, sourceContent);\n    });\n    return MapSource(map, children);\n}\n\n/**\n * A SourceMap v3 compatible sourcemap, which only includes fields that were\n * provided to it.\n */\nclass SourceMap {\n    constructor(map, options) {\n        const out = options.decodedMappings ? decodedMap(map) : encodedMap(map);\n        this.version = out.version; // SourceMap spec says this should be first.\n        this.file = out.file;\n        this.mappings = out.mappings;\n        this.names = out.names;\n        this.sourceRoot = out.sourceRoot;\n        this.sources = out.sources;\n        if (!options.excludeContent) {\n            this.sourcesContent = out.sourcesContent;\n        }\n    }\n    toString() {\n        return JSON.stringify(this);\n    }\n}\n\n/**\n * Traces through all the mappings in the root sourcemap, through the sources\n * (and their sourcemaps), all the way back to the original source location.\n *\n * `loader` will be called every time we encounter a source file. If it returns\n * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n * it returns a falsey value, that source file is treated as an original,\n * unmodified source file.\n *\n * Pass `excludeContent` to exclude any self-containing source file content\n * from the output sourcemap.\n *\n * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n * VLQ encoded) mappings.\n */\nfunction remapping(input, loader, options) {\n    const opts = typeof options === 'object' ? options : { excludeContent: !!options, decodedMappings: false };\n    const tree = buildSourceMapTree(input, loader);\n    return new SourceMap(traceMappings(tree), opts);\n}\n\nexport { remapping as default };\n"]},"metadata":{},"sourceType":"module"}