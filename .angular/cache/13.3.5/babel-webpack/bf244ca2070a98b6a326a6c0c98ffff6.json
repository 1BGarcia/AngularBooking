{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchFromURL = fetchFromURL;\nexports.flattenSourceMap = flattenSourceMap;\nexports.getSourceMappingURL = getSourceMappingURL;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _sourceMapJs = _interopRequireDefault(require(\"source-map-js\"));\n\nvar _iconvLite = require(\"iconv-lite\");\n\nvar _parseDataUrl = _interopRequireDefault(require(\"./parse-data-url\"));\n\nvar _labelsToNames = _interopRequireDefault(require(\"./labels-to-names\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Matches only the last occurrence of sourceMappingURL\n\n\nconst innerRegex = /\\s*[#@]\\s*sourceMappingURL\\s*=\\s*([^\\s'\"]*)\\s*/;\n/* eslint-disable prefer-template */\n\nconst sourceMappingURLRegex = RegExp(\"(?:\" + \"/\\\\*\" + \"(?:\\\\s*\\r?\\n(?://)?)?\" + \"(?:\" + innerRegex.source + \")\" + \"\\\\s*\" + \"\\\\*/\" + \"|\" + \"//(?:\" + innerRegex.source + \")\" + \")\" + \"\\\\s*\");\n/* eslint-enable prefer-template */\n\nfunction labelToName(label) {\n  const labelLowercase = String(label).trim().toLowerCase();\n  return _labelsToNames.default[labelLowercase] || null;\n}\n\nfunction flattenSourceMap(_x) {\n  return _flattenSourceMap.apply(this, arguments);\n}\n\nfunction _flattenSourceMap() {\n  _flattenSourceMap = _asyncToGenerator(function* (map) {\n    const consumer = yield new _sourceMapJs.default.SourceMapConsumer(map);\n    const generatedMap = map.file ? new _sourceMapJs.default.SourceMapGenerator({\n      file: map.file\n    }) : new _sourceMapJs.default.SourceMapGenerator();\n    consumer.sources.forEach(sourceFile => {\n      const sourceContent = consumer.sourceContentFor(sourceFile, true);\n      generatedMap.setSourceContent(sourceFile, sourceContent);\n    });\n    consumer.eachMapping(mapping => {\n      const {\n        source\n      } = consumer.originalPositionFor({\n        line: mapping.generatedLine,\n        column: mapping.generatedColumn\n      });\n      const mappings = {\n        source,\n        original: {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        },\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (source) {\n        generatedMap.addMapping(mappings);\n      }\n    });\n    return generatedMap.toJSON();\n  });\n  return _flattenSourceMap.apply(this, arguments);\n}\n\nfunction getSourceMappingURL(code) {\n  const lines = code.split(/^/m);\n  let match;\n\n  for (let i = lines.length - 1; i >= 0; i--) {\n    match = lines[i].match(sourceMappingURLRegex);\n\n    if (match) {\n      break;\n    }\n  }\n\n  const sourceMappingURL = match ? match[1] || match[2] || \"\" : null;\n  return {\n    sourceMappingURL: sourceMappingURL ? decodeURI(sourceMappingURL) : sourceMappingURL,\n    replacementString: match ? match[0] : null\n  };\n}\n\nfunction getAbsolutePath(context, request, sourceRoot) {\n  if (sourceRoot) {\n    if (_path.default.isAbsolute(sourceRoot)) {\n      return _path.default.join(sourceRoot, request);\n    }\n\n    return _path.default.join(context, sourceRoot, request);\n  }\n\n  return _path.default.join(context, request);\n}\n\nfunction fetchFromDataURL(loaderContext, sourceURL) {\n  const dataURL = (0, _parseDataUrl.default)(sourceURL);\n\n  if (dataURL) {\n    // https://tools.ietf.org/html/rfc4627\n    // JSON text SHALL be encoded in Unicode. The default encoding is UTF-8.\n    const encodingName = labelToName(dataURL.parameters.get(\"charset\")) || \"UTF-8\";\n    return (0, _iconvLite.decode)(dataURL.body, encodingName);\n  }\n\n  throw new Error(`Failed to parse source map from \"data\" URL: ${sourceURL}`);\n}\n\nfunction fetchFromFilesystem(_x2, _x3) {\n  return _fetchFromFilesystem.apply(this, arguments);\n}\n\nfunction _fetchFromFilesystem() {\n  _fetchFromFilesystem = _asyncToGenerator(function* (loaderContext, sourceURL) {\n    let buffer;\n\n    try {\n      buffer = yield new Promise((resolve, reject) => {\n        loaderContext.fs.readFile(sourceURL, (error, data) => {\n          if (error) {\n            return reject(error);\n          }\n\n          return resolve(data);\n        });\n      });\n    } catch (error) {\n      throw new Error(`Failed to parse source map from '${sourceURL}' file: ${error}`);\n    }\n\n    return {\n      path: sourceURL,\n      data: buffer.toString()\n    };\n  });\n  return _fetchFromFilesystem.apply(this, arguments);\n}\n\nfunction fetchPathsFromFilesystem(_x4, _x5) {\n  return _fetchPathsFromFilesystem.apply(this, arguments);\n}\n\nfunction _fetchPathsFromFilesystem() {\n  _fetchPathsFromFilesystem = _asyncToGenerator(function* (loaderContext, possibleRequests, errorsAccumulator = \"\") {\n    let result;\n\n    try {\n      result = yield fetchFromFilesystem(loaderContext, possibleRequests[0], errorsAccumulator);\n    } catch (error) {\n      // eslint-disable-next-line no-param-reassign\n      errorsAccumulator += `${error.message}\\n\\n`;\n      const [, ...tailPossibleRequests] = possibleRequests;\n\n      if (tailPossibleRequests.length === 0) {\n        error.message = errorsAccumulator;\n        throw error;\n      }\n\n      return fetchPathsFromFilesystem(loaderContext, tailPossibleRequests, errorsAccumulator);\n    }\n\n    return result;\n  });\n  return _fetchPathsFromFilesystem.apply(this, arguments);\n}\n\nfunction fetchFromURL(_x6, _x7, _x8, _x9) {\n  return _fetchFromURL.apply(this, arguments);\n}\n\nfunction _fetchFromURL() {\n  _fetchFromURL = _asyncToGenerator(function* (loaderContext, context, url, sourceRoot, skipReading = false) {\n    // 1. It's an absolute url and it is not `windows` path like `C:\\dir\\file`\n    if (/^[a-z][a-z0-9+.-]*:/i.test(url) && !_path.default.win32.isAbsolute(url)) {\n      const {\n        protocol\n      } = _url.default.parse(url);\n\n      if (protocol === \"data:\") {\n        if (skipReading) {\n          return {\n            sourceURL: \"\"\n          };\n        }\n\n        const sourceContent = fetchFromDataURL(loaderContext, url);\n        return {\n          sourceURL: \"\",\n          sourceContent\n        };\n      }\n\n      if (skipReading) {\n        return {\n          sourceURL: url\n        };\n      }\n\n      if (protocol === \"file:\") {\n        const pathFromURL = _url.default.fileURLToPath(url);\n\n        const sourceURL = _path.default.normalize(pathFromURL);\n\n        const {\n          data: sourceContent\n        } = yield fetchFromFilesystem(loaderContext, sourceURL);\n        return {\n          sourceURL,\n          sourceContent\n        };\n      }\n\n      throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n    } // 2. It's a scheme-relative\n\n\n    if (/^\\/\\//.test(url)) {\n      throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n    } // 3. Absolute path\n\n\n    if (_path.default.isAbsolute(url)) {\n      let sourceURL = _path.default.normalize(url);\n\n      let sourceContent;\n\n      if (!skipReading) {\n        const possibleRequests = [sourceURL];\n\n        if (url.startsWith(\"/\")) {\n          possibleRequests.push(getAbsolutePath(context, sourceURL.slice(1), sourceRoot));\n        }\n\n        const result = yield fetchPathsFromFilesystem(loaderContext, possibleRequests);\n        sourceURL = result.path;\n        sourceContent = result.data;\n      }\n\n      return {\n        sourceURL,\n        sourceContent\n      };\n    } // 4. Relative path\n\n\n    const sourceURL = getAbsolutePath(context, url, sourceRoot);\n    let sourceContent;\n\n    if (!skipReading) {\n      const {\n        data\n      } = yield fetchFromFilesystem(loaderContext, sourceURL);\n      sourceContent = data;\n    }\n\n    return {\n      sourceURL,\n      sourceContent\n    };\n  });\n  return _fetchFromURL.apply(this, arguments);\n}","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/source-map-loader/dist/utils.js"],"names":["Object","defineProperty","exports","value","fetchFromURL","flattenSourceMap","getSourceMappingURL","_path","_interopRequireDefault","require","_url","_sourceMapJs","_iconvLite","_parseDataUrl","_labelsToNames","obj","__esModule","default","innerRegex","sourceMappingURLRegex","RegExp","source","labelToName","label","labelLowercase","String","trim","toLowerCase","map","consumer","SourceMapConsumer","generatedMap","file","SourceMapGenerator","sources","forEach","sourceFile","sourceContent","sourceContentFor","setSourceContent","eachMapping","mapping","originalPositionFor","line","generatedLine","column","generatedColumn","mappings","original","originalLine","originalColumn","generated","addMapping","toJSON","code","lines","split","match","i","length","sourceMappingURL","decodeURI","replacementString","getAbsolutePath","context","request","sourceRoot","isAbsolute","join","fetchFromDataURL","loaderContext","sourceURL","dataURL","encodingName","parameters","get","decode","body","Error","fetchFromFilesystem","buffer","Promise","resolve","reject","fs","readFile","error","data","path","toString","fetchPathsFromFilesystem","possibleRequests","errorsAccumulator","result","message","tailPossibleRequests","url","skipReading","test","win32","protocol","parse","pathFromURL","fileURLToPath","normalize","startsWith","push","slice"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchFromURL = fetchFromURL;\nexports.flattenSourceMap = flattenSourceMap;\nexports.getSourceMappingURL = getSourceMappingURL;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _sourceMapJs = _interopRequireDefault(require(\"source-map-js\"));\n\nvar _iconvLite = require(\"iconv-lite\");\n\nvar _parseDataUrl = _interopRequireDefault(require(\"./parse-data-url\"));\n\nvar _labelsToNames = _interopRequireDefault(require(\"./labels-to-names\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Matches only the last occurrence of sourceMappingURL\nconst innerRegex = /\\s*[#@]\\s*sourceMappingURL\\s*=\\s*([^\\s'\"]*)\\s*/;\n/* eslint-disable prefer-template */\n\nconst sourceMappingURLRegex = RegExp(\"(?:\" + \"/\\\\*\" + \"(?:\\\\s*\\r?\\n(?://)?)?\" + \"(?:\" + innerRegex.source + \")\" + \"\\\\s*\" + \"\\\\*/\" + \"|\" + \"//(?:\" + innerRegex.source + \")\" + \")\" + \"\\\\s*\");\n/* eslint-enable prefer-template */\n\nfunction labelToName(label) {\n  const labelLowercase = String(label).trim().toLowerCase();\n  return _labelsToNames.default[labelLowercase] || null;\n}\n\nasync function flattenSourceMap(map) {\n  const consumer = await new _sourceMapJs.default.SourceMapConsumer(map);\n  const generatedMap = map.file ? new _sourceMapJs.default.SourceMapGenerator({\n    file: map.file\n  }) : new _sourceMapJs.default.SourceMapGenerator();\n  consumer.sources.forEach(sourceFile => {\n    const sourceContent = consumer.sourceContentFor(sourceFile, true);\n    generatedMap.setSourceContent(sourceFile, sourceContent);\n  });\n  consumer.eachMapping(mapping => {\n    const {\n      source\n    } = consumer.originalPositionFor({\n      line: mapping.generatedLine,\n      column: mapping.generatedColumn\n    });\n    const mappings = {\n      source,\n      original: {\n        line: mapping.originalLine,\n        column: mapping.originalColumn\n      },\n      generated: {\n        line: mapping.generatedLine,\n        column: mapping.generatedColumn\n      }\n    };\n\n    if (source) {\n      generatedMap.addMapping(mappings);\n    }\n  });\n  return generatedMap.toJSON();\n}\n\nfunction getSourceMappingURL(code) {\n  const lines = code.split(/^/m);\n  let match;\n\n  for (let i = lines.length - 1; i >= 0; i--) {\n    match = lines[i].match(sourceMappingURLRegex);\n\n    if (match) {\n      break;\n    }\n  }\n\n  const sourceMappingURL = match ? match[1] || match[2] || \"\" : null;\n  return {\n    sourceMappingURL: sourceMappingURL ? decodeURI(sourceMappingURL) : sourceMappingURL,\n    replacementString: match ? match[0] : null\n  };\n}\n\nfunction getAbsolutePath(context, request, sourceRoot) {\n  if (sourceRoot) {\n    if (_path.default.isAbsolute(sourceRoot)) {\n      return _path.default.join(sourceRoot, request);\n    }\n\n    return _path.default.join(context, sourceRoot, request);\n  }\n\n  return _path.default.join(context, request);\n}\n\nfunction fetchFromDataURL(loaderContext, sourceURL) {\n  const dataURL = (0, _parseDataUrl.default)(sourceURL);\n\n  if (dataURL) {\n    // https://tools.ietf.org/html/rfc4627\n    // JSON text SHALL be encoded in Unicode. The default encoding is UTF-8.\n    const encodingName = labelToName(dataURL.parameters.get(\"charset\")) || \"UTF-8\";\n    return (0, _iconvLite.decode)(dataURL.body, encodingName);\n  }\n\n  throw new Error(`Failed to parse source map from \"data\" URL: ${sourceURL}`);\n}\n\nasync function fetchFromFilesystem(loaderContext, sourceURL) {\n  let buffer;\n\n  try {\n    buffer = await new Promise((resolve, reject) => {\n      loaderContext.fs.readFile(sourceURL, (error, data) => {\n        if (error) {\n          return reject(error);\n        }\n\n        return resolve(data);\n      });\n    });\n  } catch (error) {\n    throw new Error(`Failed to parse source map from '${sourceURL}' file: ${error}`);\n  }\n\n  return {\n    path: sourceURL,\n    data: buffer.toString()\n  };\n}\n\nasync function fetchPathsFromFilesystem(loaderContext, possibleRequests, errorsAccumulator = \"\") {\n  let result;\n\n  try {\n    result = await fetchFromFilesystem(loaderContext, possibleRequests[0], errorsAccumulator);\n  } catch (error) {\n    // eslint-disable-next-line no-param-reassign\n    errorsAccumulator += `${error.message}\\n\\n`;\n    const [, ...tailPossibleRequests] = possibleRequests;\n\n    if (tailPossibleRequests.length === 0) {\n      error.message = errorsAccumulator;\n      throw error;\n    }\n\n    return fetchPathsFromFilesystem(loaderContext, tailPossibleRequests, errorsAccumulator);\n  }\n\n  return result;\n}\n\nasync function fetchFromURL(loaderContext, context, url, sourceRoot, skipReading = false) {\n  // 1. It's an absolute url and it is not `windows` path like `C:\\dir\\file`\n  if (/^[a-z][a-z0-9+.-]*:/i.test(url) && !_path.default.win32.isAbsolute(url)) {\n    const {\n      protocol\n    } = _url.default.parse(url);\n\n    if (protocol === \"data:\") {\n      if (skipReading) {\n        return {\n          sourceURL: \"\"\n        };\n      }\n\n      const sourceContent = fetchFromDataURL(loaderContext, url);\n      return {\n        sourceURL: \"\",\n        sourceContent\n      };\n    }\n\n    if (skipReading) {\n      return {\n        sourceURL: url\n      };\n    }\n\n    if (protocol === \"file:\") {\n      const pathFromURL = _url.default.fileURLToPath(url);\n\n      const sourceURL = _path.default.normalize(pathFromURL);\n\n      const {\n        data: sourceContent\n      } = await fetchFromFilesystem(loaderContext, sourceURL);\n      return {\n        sourceURL,\n        sourceContent\n      };\n    }\n\n    throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n  } // 2. It's a scheme-relative\n\n\n  if (/^\\/\\//.test(url)) {\n    throw new Error(`Failed to parse source map: '${url}' URL is not supported`);\n  } // 3. Absolute path\n\n\n  if (_path.default.isAbsolute(url)) {\n    let sourceURL = _path.default.normalize(url);\n\n    let sourceContent;\n\n    if (!skipReading) {\n      const possibleRequests = [sourceURL];\n\n      if (url.startsWith(\"/\")) {\n        possibleRequests.push(getAbsolutePath(context, sourceURL.slice(1), sourceRoot));\n      }\n\n      const result = await fetchPathsFromFilesystem(loaderContext, possibleRequests);\n      sourceURL = result.path;\n      sourceContent = result.data;\n    }\n\n    return {\n      sourceURL,\n      sourceContent\n    };\n  } // 4. Relative path\n\n\n  const sourceURL = getAbsolutePath(context, url, sourceRoot);\n  let sourceContent;\n\n  if (!skipReading) {\n    const {\n      data\n    } = await fetchFromFilesystem(loaderContext, sourceURL);\n    sourceContent = data;\n  }\n\n  return {\n    sourceURL,\n    sourceContent\n  };\n}"]},"metadata":{},"sourceType":"script"}