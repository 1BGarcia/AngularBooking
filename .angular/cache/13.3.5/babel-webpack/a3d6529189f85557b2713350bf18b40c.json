{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InlineFontsProcessor = void 0;\n\nconst cacache = __importStar(require(\"cacache\"));\n\nconst fs = __importStar(require(\"fs\"));\n\nconst https = __importStar(require(\"https\"));\n\nconst https_proxy_agent_1 = __importDefault(require(\"https-proxy-agent\"));\n\nconst path_1 = require(\"path\");\n\nconst url_1 = require(\"url\");\n\nconst package_version_1 = require(\"../package-version\");\n\nconst html_rewriting_stream_1 = require(\"./html-rewriting-stream\");\n\nconst SUPPORTED_PROVIDERS = {\n  'fonts.googleapis.com': {\n    preconnectUrl: 'https://fonts.gstatic.com'\n  },\n  'use.typekit.net': {\n    preconnectUrl: 'https://use.typekit.net'\n  }\n};\n\nclass InlineFontsProcessor {\n  constructor(options) {\n    this.options = options;\n    const {\n      path: cacheDirectory,\n      enabled\n    } = this.options.cache || {};\n\n    if (cacheDirectory && enabled) {\n      this.cachePath = (0, path_1.join)(cacheDirectory, 'angular-build-fonts');\n    }\n  }\n\n  process(content) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const hrefList = [];\n      const existingPreconnect = new Set(); // Collector link tags with href\n\n      const {\n        rewriter: collectorStream\n      } = yield (0, html_rewriting_stream_1.htmlRewritingStream)(content);\n      collectorStream.on('startTag', tag => {\n        const {\n          tagName,\n          attrs\n        } = tag;\n\n        if (tagName !== 'link') {\n          return;\n        }\n\n        let hrefValue;\n        let relValue;\n\n        for (const {\n          name,\n          value\n        } of attrs) {\n          switch (name) {\n            case 'rel':\n              relValue = value;\n              break;\n\n            case 'href':\n              hrefValue = value;\n              break;\n          }\n\n          if (hrefValue && relValue) {\n            switch (relValue) {\n              case 'stylesheet':\n                // <link rel=\"stylesheet\" href=\"https://example.com/main.css\">\n                hrefList.push(hrefValue);\n                break;\n\n              case 'preconnect':\n                // <link rel=\"preconnect\" href=\"https://example.com\">\n                existingPreconnect.add(hrefValue.replace(/\\/$/, ''));\n                break;\n            }\n\n            return;\n          }\n        }\n      });\n      yield new Promise(resolve => collectorStream.on('finish', resolve)); // Download stylesheets\n\n      const hrefsContent = new Map();\n      const newPreconnectUrls = new Set();\n\n      for (const hrefItem of hrefList) {\n        const url = _this.createNormalizedUrl(hrefItem);\n\n        if (!url) {\n          continue;\n        }\n\n        const content = yield _this.processHref(url);\n\n        if (content === undefined) {\n          continue;\n        }\n\n        hrefsContent.set(hrefItem, content); // Add preconnect\n\n        const preconnectUrl = (_a = _this.getFontProviderDetails(url)) === null || _a === void 0 ? void 0 : _a.preconnectUrl;\n\n        if (preconnectUrl && !existingPreconnect.has(preconnectUrl)) {\n          newPreconnectUrls.add(preconnectUrl);\n        }\n      }\n\n      if (hrefsContent.size === 0) {\n        return content;\n      } // Replace link with style tag.\n\n\n      const {\n        rewriter,\n        transformedContent\n      } = yield (0, html_rewriting_stream_1.htmlRewritingStream)(content);\n      rewriter.on('startTag', tag => {\n        const {\n          tagName,\n          attrs\n        } = tag;\n\n        switch (tagName) {\n          case 'head':\n            rewriter.emitStartTag(tag);\n\n            for (const url of newPreconnectUrls) {\n              rewriter.emitRaw(`<link rel=\"preconnect\" href=\"${url}\" crossorigin>`);\n            }\n\n            break;\n\n          case 'link':\n            const hrefAttr = attrs.some(({\n              name,\n              value\n            }) => name === 'rel' && value === 'stylesheet') && attrs.find(({\n              name,\n              value\n            }) => name === 'href' && hrefsContent.has(value));\n\n            if (hrefAttr) {\n              const href = hrefAttr.value;\n              const cssContent = hrefsContent.get(href);\n              rewriter.emitRaw(`<style type=\"text/css\">${cssContent}</style>`);\n            } else {\n              rewriter.emitStartTag(tag);\n            }\n\n            break;\n\n          default:\n            rewriter.emitStartTag(tag);\n            break;\n        }\n      });\n      return transformedContent;\n    })();\n  }\n\n  getResponse(url) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const key = `${package_version_1.VERSION}|${url}`;\n\n      if (_this2.cachePath) {\n        const entry = yield cacache.get.info(_this2.cachePath, key);\n\n        if (entry) {\n          return fs.promises.readFile(entry.path, 'utf8');\n        }\n      }\n\n      let agent;\n      const httpsProxy = (_a = process.env.HTTPS_PROXY) !== null && _a !== void 0 ? _a : process.env.https_proxy;\n\n      if (httpsProxy) {\n        agent = (0, https_proxy_agent_1.default)(httpsProxy);\n      }\n\n      const data = yield new Promise((resolve, reject) => {\n        let rawResponse = '';\n        https.get(url, {\n          agent,\n          rejectUnauthorized: false,\n          headers: {\n            'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36'\n          }\n        }, res => {\n          if (res.statusCode !== 200) {\n            reject(new Error(`Inlining of fonts failed. ${url} returned status code: ${res.statusCode}.`));\n            return;\n          }\n\n          res.on('data', chunk => rawResponse += chunk).on('end', () => resolve(rawResponse));\n        }).on('error', e => reject(new Error(`Inlining of fonts failed. An error has occurred while retrieving ${url} over the internet.\\n` + e.message)));\n      });\n\n      if (_this2.cachePath) {\n        yield cacache.put(_this2.cachePath, key, data);\n      }\n\n      return data;\n    })();\n  }\n\n  processHref(url) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const provider = _this3.getFontProviderDetails(url);\n\n      if (!provider) {\n        return undefined;\n      }\n\n      let cssContent = yield _this3.getResponse(url);\n\n      if (_this3.options.minify) {\n        cssContent = cssContent // Comments.\n        .replace(/\\/\\*([\\s\\S]*?)\\*\\//g, '') // New lines.\n        .replace(/\\n/g, '') // Safe spaces.\n        .replace(/\\s?[{:;]\\s+/g, s => s.trim());\n      }\n\n      return cssContent;\n    })();\n  }\n\n  getFontProviderDetails(url) {\n    return SUPPORTED_PROVIDERS[url.hostname];\n  }\n\n  createNormalizedUrl(value) {\n    // Need to convert '//' to 'https://' because the URL parser will fail with '//'.\n    const normalizedHref = value.startsWith('//') ? `https:${value}` : value;\n\n    if (!normalizedHref.startsWith('http')) {\n      // Non valid URL.\n      // Example: relative path styles.css.\n      return undefined;\n    }\n\n    const url = new url_1.URL(normalizedHref); // Force HTTPS protocol\n\n    url.protocol = 'https:';\n    return url;\n  }\n\n}\n\nexports.InlineFontsProcessor = InlineFontsProcessor;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/@angular-devkit/build-angular/src/utils/index-file/inline-fonts.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__importDefault","exports","InlineFontsProcessor","cacache","require","fs","https","https_proxy_agent_1","path_1","url_1","package_version_1","html_rewriting_stream_1","SUPPORTED_PROVIDERS","preconnectUrl","constructor","options","path","cacheDirectory","enabled","cache","cachePath","join","process","content","_a","hrefList","existingPreconnect","Set","rewriter","collectorStream","htmlRewritingStream","on","tag","tagName","attrs","hrefValue","relValue","name","push","add","replace","Promise","resolve","hrefsContent","Map","newPreconnectUrls","hrefItem","url","createNormalizedUrl","processHref","set","getFontProviderDetails","has","size","transformedContent","emitStartTag","emitRaw","hrefAttr","some","find","href","cssContent","getResponse","key","VERSION","entry","info","promises","readFile","agent","httpsProxy","env","HTTPS_PROXY","https_proxy","default","data","reject","rawResponse","rejectUnauthorized","headers","res","statusCode","Error","chunk","e","message","put","provider","minify","s","trim","hostname","normalizedHref","startsWith","URL","protocol"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlineFontsProcessor = void 0;\nconst cacache = __importStar(require(\"cacache\"));\nconst fs = __importStar(require(\"fs\"));\nconst https = __importStar(require(\"https\"));\nconst https_proxy_agent_1 = __importDefault(require(\"https-proxy-agent\"));\nconst path_1 = require(\"path\");\nconst url_1 = require(\"url\");\nconst package_version_1 = require(\"../package-version\");\nconst html_rewriting_stream_1 = require(\"./html-rewriting-stream\");\nconst SUPPORTED_PROVIDERS = {\n    'fonts.googleapis.com': {\n        preconnectUrl: 'https://fonts.gstatic.com',\n    },\n    'use.typekit.net': {\n        preconnectUrl: 'https://use.typekit.net',\n    },\n};\nclass InlineFontsProcessor {\n    constructor(options) {\n        this.options = options;\n        const { path: cacheDirectory, enabled } = this.options.cache || {};\n        if (cacheDirectory && enabled) {\n            this.cachePath = (0, path_1.join)(cacheDirectory, 'angular-build-fonts');\n        }\n    }\n    async process(content) {\n        var _a;\n        const hrefList = [];\n        const existingPreconnect = new Set();\n        // Collector link tags with href\n        const { rewriter: collectorStream } = await (0, html_rewriting_stream_1.htmlRewritingStream)(content);\n        collectorStream.on('startTag', (tag) => {\n            const { tagName, attrs } = tag;\n            if (tagName !== 'link') {\n                return;\n            }\n            let hrefValue;\n            let relValue;\n            for (const { name, value } of attrs) {\n                switch (name) {\n                    case 'rel':\n                        relValue = value;\n                        break;\n                    case 'href':\n                        hrefValue = value;\n                        break;\n                }\n                if (hrefValue && relValue) {\n                    switch (relValue) {\n                        case 'stylesheet':\n                            // <link rel=\"stylesheet\" href=\"https://example.com/main.css\">\n                            hrefList.push(hrefValue);\n                            break;\n                        case 'preconnect':\n                            // <link rel=\"preconnect\" href=\"https://example.com\">\n                            existingPreconnect.add(hrefValue.replace(/\\/$/, ''));\n                            break;\n                    }\n                    return;\n                }\n            }\n        });\n        await new Promise((resolve) => collectorStream.on('finish', resolve));\n        // Download stylesheets\n        const hrefsContent = new Map();\n        const newPreconnectUrls = new Set();\n        for (const hrefItem of hrefList) {\n            const url = this.createNormalizedUrl(hrefItem);\n            if (!url) {\n                continue;\n            }\n            const content = await this.processHref(url);\n            if (content === undefined) {\n                continue;\n            }\n            hrefsContent.set(hrefItem, content);\n            // Add preconnect\n            const preconnectUrl = (_a = this.getFontProviderDetails(url)) === null || _a === void 0 ? void 0 : _a.preconnectUrl;\n            if (preconnectUrl && !existingPreconnect.has(preconnectUrl)) {\n                newPreconnectUrls.add(preconnectUrl);\n            }\n        }\n        if (hrefsContent.size === 0) {\n            return content;\n        }\n        // Replace link with style tag.\n        const { rewriter, transformedContent } = await (0, html_rewriting_stream_1.htmlRewritingStream)(content);\n        rewriter.on('startTag', (tag) => {\n            const { tagName, attrs } = tag;\n            switch (tagName) {\n                case 'head':\n                    rewriter.emitStartTag(tag);\n                    for (const url of newPreconnectUrls) {\n                        rewriter.emitRaw(`<link rel=\"preconnect\" href=\"${url}\" crossorigin>`);\n                    }\n                    break;\n                case 'link':\n                    const hrefAttr = attrs.some(({ name, value }) => name === 'rel' && value === 'stylesheet') &&\n                        attrs.find(({ name, value }) => name === 'href' && hrefsContent.has(value));\n                    if (hrefAttr) {\n                        const href = hrefAttr.value;\n                        const cssContent = hrefsContent.get(href);\n                        rewriter.emitRaw(`<style type=\"text/css\">${cssContent}</style>`);\n                    }\n                    else {\n                        rewriter.emitStartTag(tag);\n                    }\n                    break;\n                default:\n                    rewriter.emitStartTag(tag);\n                    break;\n            }\n        });\n        return transformedContent;\n    }\n    async getResponse(url) {\n        var _a;\n        const key = `${package_version_1.VERSION}|${url}`;\n        if (this.cachePath) {\n            const entry = await cacache.get.info(this.cachePath, key);\n            if (entry) {\n                return fs.promises.readFile(entry.path, 'utf8');\n            }\n        }\n        let agent;\n        const httpsProxy = (_a = process.env.HTTPS_PROXY) !== null && _a !== void 0 ? _a : process.env.https_proxy;\n        if (httpsProxy) {\n            agent = (0, https_proxy_agent_1.default)(httpsProxy);\n        }\n        const data = await new Promise((resolve, reject) => {\n            let rawResponse = '';\n            https\n                .get(url, {\n                agent,\n                rejectUnauthorized: false,\n                headers: {\n                    'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36',\n                },\n            }, (res) => {\n                if (res.statusCode !== 200) {\n                    reject(new Error(`Inlining of fonts failed. ${url} returned status code: ${res.statusCode}.`));\n                    return;\n                }\n                res.on('data', (chunk) => (rawResponse += chunk)).on('end', () => resolve(rawResponse));\n            })\n                .on('error', (e) => reject(new Error(`Inlining of fonts failed. An error has occurred while retrieving ${url} over the internet.\\n` +\n                e.message)));\n        });\n        if (this.cachePath) {\n            await cacache.put(this.cachePath, key, data);\n        }\n        return data;\n    }\n    async processHref(url) {\n        const provider = this.getFontProviderDetails(url);\n        if (!provider) {\n            return undefined;\n        }\n        let cssContent = await this.getResponse(url);\n        if (this.options.minify) {\n            cssContent = cssContent\n                // Comments.\n                .replace(/\\/\\*([\\s\\S]*?)\\*\\//g, '')\n                // New lines.\n                .replace(/\\n/g, '')\n                // Safe spaces.\n                .replace(/\\s?[{:;]\\s+/g, (s) => s.trim());\n        }\n        return cssContent;\n    }\n    getFontProviderDetails(url) {\n        return SUPPORTED_PROVIDERS[url.hostname];\n    }\n    createNormalizedUrl(value) {\n        // Need to convert '//' to 'https://' because the URL parser will fail with '//'.\n        const normalizedHref = value.startsWith('//') ? `https:${value}` : value;\n        if (!normalizedHref.startsWith('http')) {\n            // Non valid URL.\n            // Example: relative path styles.css.\n            return undefined;\n        }\n        const url = new url_1.URL(normalizedHref);\n        // Force HTTPS protocol\n        url.protocol = 'https:';\n        return url;\n    }\n}\nexports.InlineFontsProcessor = InlineFontsProcessor;\n"]},"metadata":{},"sourceType":"script"}