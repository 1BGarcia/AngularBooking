{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Architect = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst api_1 = require(\"./api\");\n\nconst schedule_by_name_1 = require(\"./schedule-by-name\");\n\nconst inputSchema = require('./input-schema.json');\n\nconst outputSchema = require('./output-schema.json');\n\nfunction _createJobHandlerFromBuilderInfo(info, target, host, registry, baseOptions) {\n  const jobDescription = {\n    name: target ? `{${(0, api_1.targetStringFromTarget)(target)}}` : info.builderName,\n    argument: {\n      type: 'object'\n    },\n    input: inputSchema,\n    output: outputSchema,\n    info\n  };\n\n  function handler(argument, context) {\n    // Add input validation to the inbound bus.\n    const inboundBusWithInputValidation = context.inboundBus.pipe((0, operators_1.concatMap)(message => {\n      if (message.kind === core_1.experimental.jobs.JobInboundMessageKind.Input) {\n        const v = message.value;\n        const options = { ...baseOptions,\n          ...v.options\n        }; // Validate v against the options schema.\n\n        return registry.compile(info.optionSchema).pipe((0, operators_1.concatMap)(validation => validation(options)), (0, operators_1.map)(validationResult => {\n          const {\n            data,\n            success,\n            errors\n          } = validationResult;\n\n          if (success) {\n            return { ...v,\n              options: data\n            };\n          }\n\n          throw new core_1.json.schema.SchemaValidationException(errors);\n        }), (0, operators_1.map)(value => ({ ...message,\n          value\n        })));\n      } else {\n        return (0, rxjs_1.of)(message);\n      }\n    }), // Using a share replay because the job might be synchronously sending input, but\n    // asynchronously listening to it.\n    (0, operators_1.shareReplay)(1)); // Make an inboundBus that completes instead of erroring out.\n    // We'll merge the errors into the output instead.\n\n    const inboundBus = (0, rxjs_1.onErrorResumeNext)(inboundBusWithInputValidation);\n    const output = (0, rxjs_1.from)(host.loadBuilder(info)).pipe((0, operators_1.concatMap)(builder => {\n      if (builder === null) {\n        throw new Error(`Cannot load builder for builderInfo ${JSON.stringify(info, null, 2)}`);\n      }\n\n      return builder.handler(argument, { ...context,\n        inboundBus\n      }).pipe((0, operators_1.map)(output => {\n        if (output.kind === core_1.experimental.jobs.JobOutboundMessageKind.Output) {\n          // Add target to it.\n          return { ...output,\n            value: { ...output.value,\n              ...(target ? {\n                target\n              } : 0)\n            }\n          };\n        } else {\n          return output;\n        }\n      }));\n    }), // Share subscriptions to the output, otherwise the the handler will be re-run.\n    (0, operators_1.shareReplay)()); // Separate the errors from the inbound bus into their own observable that completes when the\n    // builder output does.\n\n    const inboundBusErrors = inboundBusWithInputValidation.pipe((0, operators_1.ignoreElements)(), (0, operators_1.takeUntil)((0, rxjs_1.onErrorResumeNext)(output.pipe((0, operators_1.last)())))); // Return the builder output plus any input errors.\n\n    return (0, rxjs_1.merge)(inboundBusErrors, output);\n  }\n\n  return (0, rxjs_1.of)(Object.assign(handler, {\n    jobDescription\n  }));\n}\n/**\n * A JobRegistry that resolves builder targets from the host.\n */\n\n\nclass ArchitectBuilderJobRegistry {\n  constructor(_host, _registry, _jobCache, _infoCache) {\n    this._host = _host;\n    this._registry = _registry;\n    this._jobCache = _jobCache;\n    this._infoCache = _infoCache;\n  }\n\n  _resolveBuilder(name) {\n    const cache = this._infoCache;\n\n    if (cache) {\n      const maybeCache = cache.get(name);\n\n      if (maybeCache !== undefined) {\n        return maybeCache;\n      }\n\n      const info = (0, rxjs_1.from)(this._host.resolveBuilder(name)).pipe((0, operators_1.shareReplay)(1));\n      cache.set(name, info);\n      return info;\n    }\n\n    return (0, rxjs_1.from)(this._host.resolveBuilder(name));\n  }\n\n  _createBuilder(info, target, options) {\n    const cache = this._jobCache;\n\n    if (target) {\n      const maybeHit = cache && cache.get((0, api_1.targetStringFromTarget)(target));\n\n      if (maybeHit) {\n        return maybeHit;\n      }\n    } else {\n      const maybeHit = cache && cache.get(info.builderName);\n\n      if (maybeHit) {\n        return maybeHit;\n      }\n    }\n\n    const result = _createJobHandlerFromBuilderInfo(info, target, this._host, this._registry, options || {});\n\n    if (cache) {\n      if (target) {\n        cache.set((0, api_1.targetStringFromTarget)(target), result.pipe((0, operators_1.shareReplay)(1)));\n      } else {\n        cache.set(info.builderName, result.pipe((0, operators_1.shareReplay)(1)));\n      }\n    }\n\n    return result;\n  }\n\n  get(name) {\n    const m = name.match(/^([^:]+):([^:]+)$/i);\n\n    if (!m) {\n      return (0, rxjs_1.of)(null);\n    }\n\n    return (0, rxjs_1.from)(this._resolveBuilder(name)).pipe((0, operators_1.concatMap)(builderInfo => builderInfo ? this._createBuilder(builderInfo) : (0, rxjs_1.of)(null)), (0, operators_1.first)(null, null));\n  }\n\n}\n/**\n * A JobRegistry that resolves targets from the host.\n */\n\n\nclass ArchitectTargetJobRegistry extends ArchitectBuilderJobRegistry {\n  get(name) {\n    const m = name.match(/^{([^:]+):([^:]+)(?::([^:]*))?}$/i);\n\n    if (!m) {\n      return (0, rxjs_1.of)(null);\n    }\n\n    const target = {\n      project: m[1],\n      target: m[2],\n      configuration: m[3]\n    };\n    return (0, rxjs_1.from)(Promise.all([this._host.getBuilderNameForTarget(target), this._host.getOptionsForTarget(target)])).pipe((0, operators_1.concatMap)(([builderStr, options]) => {\n      if (builderStr === null || options === null) {\n        return (0, rxjs_1.of)(null);\n      }\n\n      return this._resolveBuilder(builderStr).pipe((0, operators_1.concatMap)(builderInfo => {\n        if (builderInfo === null) {\n          return (0, rxjs_1.of)(null);\n        }\n\n        return this._createBuilder(builderInfo, target, options);\n      }));\n    }), (0, operators_1.first)(null, null));\n  }\n\n}\n\nfunction _getTargetOptionsFactory(host) {\n  return core_1.experimental.jobs.createJobHandler(target => {\n    return host.getOptionsForTarget(target).then(options => {\n      if (options === null) {\n        throw new Error(`Invalid target: ${JSON.stringify(target)}.`);\n      }\n\n      return options;\n    });\n  }, {\n    name: '..getTargetOptions',\n    output: {\n      type: 'object'\n    },\n    argument: inputSchema.properties.target\n  });\n}\n\nfunction _getProjectMetadataFactory(host) {\n  return core_1.experimental.jobs.createJobHandler(target => {\n    return host.getProjectMetadata(target).then(options => {\n      if (options === null) {\n        throw new Error(`Invalid target: ${JSON.stringify(target)}.`);\n      }\n\n      return options;\n    });\n  }, {\n    name: '..getProjectMetadata',\n    output: {\n      type: 'object'\n    },\n    argument: {\n      oneOf: [{\n        type: 'string'\n      }, inputSchema.properties.target]\n    }\n  });\n}\n\nfunction _getBuilderNameForTargetFactory(host) {\n  return core_1.experimental.jobs.createJobHandler( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (target) {\n      const builderName = yield host.getBuilderNameForTarget(target);\n\n      if (!builderName) {\n        throw new Error(`No builder were found for target ${(0, api_1.targetStringFromTarget)(target)}.`);\n      }\n\n      return builderName;\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }(), {\n    name: '..getBuilderNameForTarget',\n    output: {\n      type: 'string'\n    },\n    argument: inputSchema.properties.target\n  });\n}\n\nfunction _validateOptionsFactory(host, registry) {\n  return core_1.experimental.jobs.createJobHandler( /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator(function* ([builderName, options]) {\n      // Get option schema from the host.\n      const builderInfo = yield host.resolveBuilder(builderName);\n\n      if (!builderInfo) {\n        throw new Error(`No builder info were found for builder ${JSON.stringify(builderName)}.`);\n      }\n\n      return registry.compile(builderInfo.optionSchema).pipe((0, operators_1.concatMap)(validation => validation(options)), (0, operators_1.switchMap)(({\n        data,\n        success,\n        errors\n      }) => {\n        if (success) {\n          return (0, rxjs_1.of)(data);\n        }\n\n        throw new core_1.json.schema.SchemaValidationException(errors);\n      })).toPromise();\n    });\n\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }(), {\n    name: '..validateOptions',\n    output: {\n      type: 'object'\n    },\n    argument: {\n      type: 'array',\n      items: [{\n        type: 'string'\n      }, {\n        type: 'object'\n      }]\n    }\n  });\n}\n\nclass Architect {\n  constructor(_host, registry = new core_1.json.schema.CoreSchemaRegistry(), additionalJobRegistry) {\n    this._host = _host;\n    this._jobCache = new Map();\n    this._infoCache = new Map();\n    const privateArchitectJobRegistry = new core_1.experimental.jobs.SimpleJobRegistry(); // Create private jobs.\n\n    privateArchitectJobRegistry.register(_getTargetOptionsFactory(_host));\n    privateArchitectJobRegistry.register(_getBuilderNameForTargetFactory(_host));\n    privateArchitectJobRegistry.register(_validateOptionsFactory(_host, registry));\n    privateArchitectJobRegistry.register(_getProjectMetadataFactory(_host));\n    const jobRegistry = new core_1.experimental.jobs.FallbackRegistry([new ArchitectTargetJobRegistry(_host, registry, this._jobCache, this._infoCache), new ArchitectBuilderJobRegistry(_host, registry, this._jobCache, this._infoCache), privateArchitectJobRegistry, ...(additionalJobRegistry ? [additionalJobRegistry] : [])]);\n    this._scheduler = new core_1.experimental.jobs.SimpleScheduler(jobRegistry, registry);\n  }\n\n  has(name) {\n    return this._scheduler.has(name);\n  }\n\n  scheduleBuilder(name, options, scheduleOptions = {}) {\n    // The below will match 'project:target:configuration'\n    if (!/^[^:]+:[^:]+(:[^:]+)?$/.test(name)) {\n      throw new Error('Invalid builder name: ' + JSON.stringify(name));\n    }\n\n    return (0, schedule_by_name_1.scheduleByName)(name, options, {\n      scheduler: this._scheduler,\n      logger: scheduleOptions.logger || new core_1.logging.NullLogger(),\n      currentDirectory: this._host.getCurrentDirectory(),\n      workspaceRoot: this._host.getWorkspaceRoot(),\n      analytics: scheduleOptions.analytics\n    });\n  }\n\n  scheduleTarget(target, overrides = {}, scheduleOptions = {}) {\n    return (0, schedule_by_name_1.scheduleByTarget)(target, overrides, {\n      scheduler: this._scheduler,\n      logger: scheduleOptions.logger || new core_1.logging.NullLogger(),\n      currentDirectory: this._host.getCurrentDirectory(),\n      workspaceRoot: this._host.getWorkspaceRoot(),\n      analytics: scheduleOptions.analytics\n    });\n  }\n\n}\n\nexports.Architect = Architect;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/@angular-devkit/architect/src/architect.js"],"names":["Object","defineProperty","exports","value","Architect","core_1","require","rxjs_1","operators_1","api_1","schedule_by_name_1","inputSchema","outputSchema","_createJobHandlerFromBuilderInfo","info","target","host","registry","baseOptions","jobDescription","name","targetStringFromTarget","builderName","argument","type","input","output","handler","context","inboundBusWithInputValidation","inboundBus","pipe","concatMap","message","kind","experimental","jobs","JobInboundMessageKind","Input","v","options","compile","optionSchema","validation","map","validationResult","data","success","errors","json","schema","SchemaValidationException","of","shareReplay","onErrorResumeNext","from","loadBuilder","builder","Error","JSON","stringify","JobOutboundMessageKind","Output","inboundBusErrors","ignoreElements","takeUntil","last","merge","assign","ArchitectBuilderJobRegistry","constructor","_host","_registry","_jobCache","_infoCache","_resolveBuilder","cache","maybeCache","get","undefined","resolveBuilder","set","_createBuilder","maybeHit","result","m","match","builderInfo","first","ArchitectTargetJobRegistry","project","configuration","Promise","all","getBuilderNameForTarget","getOptionsForTarget","builderStr","_getTargetOptionsFactory","createJobHandler","then","properties","_getProjectMetadataFactory","getProjectMetadata","oneOf","_getBuilderNameForTargetFactory","_validateOptionsFactory","switchMap","toPromise","items","CoreSchemaRegistry","additionalJobRegistry","Map","privateArchitectJobRegistry","SimpleJobRegistry","register","jobRegistry","FallbackRegistry","_scheduler","SimpleScheduler","has","scheduleBuilder","scheduleOptions","test","scheduleByName","scheduler","logger","logging","NullLogger","currentDirectory","getCurrentDirectory","workspaceRoot","getWorkspaceRoot","analytics","scheduleTarget","overrides","scheduleByTarget"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Architect = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst api_1 = require(\"./api\");\nconst schedule_by_name_1 = require(\"./schedule-by-name\");\nconst inputSchema = require('./input-schema.json');\nconst outputSchema = require('./output-schema.json');\nfunction _createJobHandlerFromBuilderInfo(info, target, host, registry, baseOptions) {\n    const jobDescription = {\n        name: target ? `{${(0, api_1.targetStringFromTarget)(target)}}` : info.builderName,\n        argument: { type: 'object' },\n        input: inputSchema,\n        output: outputSchema,\n        info,\n    };\n    function handler(argument, context) {\n        // Add input validation to the inbound bus.\n        const inboundBusWithInputValidation = context.inboundBus.pipe((0, operators_1.concatMap)((message) => {\n            if (message.kind === core_1.experimental.jobs.JobInboundMessageKind.Input) {\n                const v = message.value;\n                const options = {\n                    ...baseOptions,\n                    ...v.options,\n                };\n                // Validate v against the options schema.\n                return registry.compile(info.optionSchema).pipe((0, operators_1.concatMap)((validation) => validation(options)), (0, operators_1.map)((validationResult) => {\n                    const { data, success, errors } = validationResult;\n                    if (success) {\n                        return { ...v, options: data };\n                    }\n                    throw new core_1.json.schema.SchemaValidationException(errors);\n                }), (0, operators_1.map)((value) => ({ ...message, value })));\n            }\n            else {\n                return (0, rxjs_1.of)(message);\n            }\n        }), \n        // Using a share replay because the job might be synchronously sending input, but\n        // asynchronously listening to it.\n        (0, operators_1.shareReplay)(1));\n        // Make an inboundBus that completes instead of erroring out.\n        // We'll merge the errors into the output instead.\n        const inboundBus = (0, rxjs_1.onErrorResumeNext)(inboundBusWithInputValidation);\n        const output = (0, rxjs_1.from)(host.loadBuilder(info)).pipe((0, operators_1.concatMap)((builder) => {\n            if (builder === null) {\n                throw new Error(`Cannot load builder for builderInfo ${JSON.stringify(info, null, 2)}`);\n            }\n            return builder.handler(argument, { ...context, inboundBus }).pipe((0, operators_1.map)((output) => {\n                if (output.kind === core_1.experimental.jobs.JobOutboundMessageKind.Output) {\n                    // Add target to it.\n                    return {\n                        ...output,\n                        value: {\n                            ...output.value,\n                            ...(target ? { target } : 0),\n                        },\n                    };\n                }\n                else {\n                    return output;\n                }\n            }));\n        }), \n        // Share subscriptions to the output, otherwise the the handler will be re-run.\n        (0, operators_1.shareReplay)());\n        // Separate the errors from the inbound bus into their own observable that completes when the\n        // builder output does.\n        const inboundBusErrors = inboundBusWithInputValidation.pipe((0, operators_1.ignoreElements)(), (0, operators_1.takeUntil)((0, rxjs_1.onErrorResumeNext)(output.pipe((0, operators_1.last)()))));\n        // Return the builder output plus any input errors.\n        return (0, rxjs_1.merge)(inboundBusErrors, output);\n    }\n    return (0, rxjs_1.of)(Object.assign(handler, { jobDescription }));\n}\n/**\n * A JobRegistry that resolves builder targets from the host.\n */\nclass ArchitectBuilderJobRegistry {\n    constructor(_host, _registry, _jobCache, _infoCache) {\n        this._host = _host;\n        this._registry = _registry;\n        this._jobCache = _jobCache;\n        this._infoCache = _infoCache;\n    }\n    _resolveBuilder(name) {\n        const cache = this._infoCache;\n        if (cache) {\n            const maybeCache = cache.get(name);\n            if (maybeCache !== undefined) {\n                return maybeCache;\n            }\n            const info = (0, rxjs_1.from)(this._host.resolveBuilder(name)).pipe((0, operators_1.shareReplay)(1));\n            cache.set(name, info);\n            return info;\n        }\n        return (0, rxjs_1.from)(this._host.resolveBuilder(name));\n    }\n    _createBuilder(info, target, options) {\n        const cache = this._jobCache;\n        if (target) {\n            const maybeHit = cache && cache.get((0, api_1.targetStringFromTarget)(target));\n            if (maybeHit) {\n                return maybeHit;\n            }\n        }\n        else {\n            const maybeHit = cache && cache.get(info.builderName);\n            if (maybeHit) {\n                return maybeHit;\n            }\n        }\n        const result = _createJobHandlerFromBuilderInfo(info, target, this._host, this._registry, options || {});\n        if (cache) {\n            if (target) {\n                cache.set((0, api_1.targetStringFromTarget)(target), result.pipe((0, operators_1.shareReplay)(1)));\n            }\n            else {\n                cache.set(info.builderName, result.pipe((0, operators_1.shareReplay)(1)));\n            }\n        }\n        return result;\n    }\n    get(name) {\n        const m = name.match(/^([^:]+):([^:]+)$/i);\n        if (!m) {\n            return (0, rxjs_1.of)(null);\n        }\n        return (0, rxjs_1.from)(this._resolveBuilder(name)).pipe((0, operators_1.concatMap)((builderInfo) => (builderInfo ? this._createBuilder(builderInfo) : (0, rxjs_1.of)(null))), (0, operators_1.first)(null, null));\n    }\n}\n/**\n * A JobRegistry that resolves targets from the host.\n */\nclass ArchitectTargetJobRegistry extends ArchitectBuilderJobRegistry {\n    get(name) {\n        const m = name.match(/^{([^:]+):([^:]+)(?::([^:]*))?}$/i);\n        if (!m) {\n            return (0, rxjs_1.of)(null);\n        }\n        const target = {\n            project: m[1],\n            target: m[2],\n            configuration: m[3],\n        };\n        return (0, rxjs_1.from)(Promise.all([\n            this._host.getBuilderNameForTarget(target),\n            this._host.getOptionsForTarget(target),\n        ])).pipe((0, operators_1.concatMap)(([builderStr, options]) => {\n            if (builderStr === null || options === null) {\n                return (0, rxjs_1.of)(null);\n            }\n            return this._resolveBuilder(builderStr).pipe((0, operators_1.concatMap)((builderInfo) => {\n                if (builderInfo === null) {\n                    return (0, rxjs_1.of)(null);\n                }\n                return this._createBuilder(builderInfo, target, options);\n            }));\n        }), (0, operators_1.first)(null, null));\n    }\n}\nfunction _getTargetOptionsFactory(host) {\n    return core_1.experimental.jobs.createJobHandler((target) => {\n        return host.getOptionsForTarget(target).then((options) => {\n            if (options === null) {\n                throw new Error(`Invalid target: ${JSON.stringify(target)}.`);\n            }\n            return options;\n        });\n    }, {\n        name: '..getTargetOptions',\n        output: { type: 'object' },\n        argument: inputSchema.properties.target,\n    });\n}\nfunction _getProjectMetadataFactory(host) {\n    return core_1.experimental.jobs.createJobHandler((target) => {\n        return host.getProjectMetadata(target).then((options) => {\n            if (options === null) {\n                throw new Error(`Invalid target: ${JSON.stringify(target)}.`);\n            }\n            return options;\n        });\n    }, {\n        name: '..getProjectMetadata',\n        output: { type: 'object' },\n        argument: {\n            oneOf: [{ type: 'string' }, inputSchema.properties.target],\n        },\n    });\n}\nfunction _getBuilderNameForTargetFactory(host) {\n    return core_1.experimental.jobs.createJobHandler(async (target) => {\n        const builderName = await host.getBuilderNameForTarget(target);\n        if (!builderName) {\n            throw new Error(`No builder were found for target ${(0, api_1.targetStringFromTarget)(target)}.`);\n        }\n        return builderName;\n    }, {\n        name: '..getBuilderNameForTarget',\n        output: { type: 'string' },\n        argument: inputSchema.properties.target,\n    });\n}\nfunction _validateOptionsFactory(host, registry) {\n    return core_1.experimental.jobs.createJobHandler(async ([builderName, options]) => {\n        // Get option schema from the host.\n        const builderInfo = await host.resolveBuilder(builderName);\n        if (!builderInfo) {\n            throw new Error(`No builder info were found for builder ${JSON.stringify(builderName)}.`);\n        }\n        return registry\n            .compile(builderInfo.optionSchema)\n            .pipe((0, operators_1.concatMap)((validation) => validation(options)), (0, operators_1.switchMap)(({ data, success, errors }) => {\n            if (success) {\n                return (0, rxjs_1.of)(data);\n            }\n            throw new core_1.json.schema.SchemaValidationException(errors);\n        }))\n            .toPromise();\n    }, {\n        name: '..validateOptions',\n        output: { type: 'object' },\n        argument: {\n            type: 'array',\n            items: [{ type: 'string' }, { type: 'object' }],\n        },\n    });\n}\nclass Architect {\n    constructor(_host, registry = new core_1.json.schema.CoreSchemaRegistry(), additionalJobRegistry) {\n        this._host = _host;\n        this._jobCache = new Map();\n        this._infoCache = new Map();\n        const privateArchitectJobRegistry = new core_1.experimental.jobs.SimpleJobRegistry();\n        // Create private jobs.\n        privateArchitectJobRegistry.register(_getTargetOptionsFactory(_host));\n        privateArchitectJobRegistry.register(_getBuilderNameForTargetFactory(_host));\n        privateArchitectJobRegistry.register(_validateOptionsFactory(_host, registry));\n        privateArchitectJobRegistry.register(_getProjectMetadataFactory(_host));\n        const jobRegistry = new core_1.experimental.jobs.FallbackRegistry([\n            new ArchitectTargetJobRegistry(_host, registry, this._jobCache, this._infoCache),\n            new ArchitectBuilderJobRegistry(_host, registry, this._jobCache, this._infoCache),\n            privateArchitectJobRegistry,\n            ...(additionalJobRegistry ? [additionalJobRegistry] : []),\n        ]);\n        this._scheduler = new core_1.experimental.jobs.SimpleScheduler(jobRegistry, registry);\n    }\n    has(name) {\n        return this._scheduler.has(name);\n    }\n    scheduleBuilder(name, options, scheduleOptions = {}) {\n        // The below will match 'project:target:configuration'\n        if (!/^[^:]+:[^:]+(:[^:]+)?$/.test(name)) {\n            throw new Error('Invalid builder name: ' + JSON.stringify(name));\n        }\n        return (0, schedule_by_name_1.scheduleByName)(name, options, {\n            scheduler: this._scheduler,\n            logger: scheduleOptions.logger || new core_1.logging.NullLogger(),\n            currentDirectory: this._host.getCurrentDirectory(),\n            workspaceRoot: this._host.getWorkspaceRoot(),\n            analytics: scheduleOptions.analytics,\n        });\n    }\n    scheduleTarget(target, overrides = {}, scheduleOptions = {}) {\n        return (0, schedule_by_name_1.scheduleByTarget)(target, overrides, {\n            scheduler: this._scheduler,\n            logger: scheduleOptions.logger || new core_1.logging.NullLogger(),\n            currentDirectory: this._host.getCurrentDirectory(),\n            workspaceRoot: this._host.getWorkspaceRoot(),\n            analytics: scheduleOptions.analytics,\n        });\n    }\n}\nexports.Architect = Architect;\n"]},"metadata":{},"sourceType":"script"}