{"ast":null,"code":"(module => {\n  var __defProp = Object.defineProperty;\n  var __defProps = Object.defineProperties;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getOwnPropSymbols = Object.getOwnPropertySymbols;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __propIsEnum = Object.prototype.propertyIsEnumerable;\n\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value\n  }) : obj[key] = value;\n\n  var __spreadValues = (a, b) => {\n    for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n  };\n\n  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n  var __markAsModule = target => __defProp(target, \"__esModule\", {\n    value: true\n  });\n\n  var __export = (target, all) => {\n    for (var name in all) __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  };\n\n  var __reExport = (target, module2, copyDefault, desc) => {\n    if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n      for (let key of __getOwnPropNames(module2)) if (!__hasOwnProp.call(target, key) && (copyDefault || key !== \"default\")) __defProp(target, key, {\n        get: () => module2[key],\n        enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable\n      });\n    }\n\n    return target;\n  };\n\n  var __toCommonJS = /* @__PURE__ */(cache => {\n    return (module2, temp) => {\n      return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);\n    };\n  })(typeof WeakMap !== \"undefined\" ? /* @__PURE__ */new WeakMap() : 0);\n\n  var __async = (__this, __arguments, generator) => {\n    return new Promise((resolve, reject) => {\n      var fulfilled = value => {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      };\n\n      var rejected = value => {\n        try {\n          step(generator.throw(value));\n        } catch (e) {\n          reject(e);\n        }\n      };\n\n      var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n\n      step((generator = generator.apply(__this, __arguments)).next());\n    });\n  }; // lib/npm/browser.ts\n\n\n  var browser_exports = {};\n\n  __export(browser_exports, {\n    analyzeMetafile: () => analyzeMetafile,\n    analyzeMetafileSync: () => analyzeMetafileSync,\n    build: () => build,\n    buildSync: () => buildSync,\n    default: () => browser_default,\n    formatMessages: () => formatMessages,\n    formatMessagesSync: () => formatMessagesSync,\n    initialize: () => initialize,\n    serve: () => serve,\n    transform: () => transform,\n    transformSync: () => transformSync,\n    version: () => version\n  }); // lib/shared/stdio_protocol.ts\n\n\n  function encodePacket(packet) {\n    let visit = value => {\n      if (value === null) {\n        bb.write8(0);\n      } else if (typeof value === \"boolean\") {\n        bb.write8(1);\n        bb.write8(+value);\n      } else if (typeof value === \"number\") {\n        bb.write8(2);\n        bb.write32(value | 0);\n      } else if (typeof value === \"string\") {\n        bb.write8(3);\n        bb.write(encodeUTF8(value));\n      } else if (value instanceof Uint8Array) {\n        bb.write8(4);\n        bb.write(value);\n      } else if (value instanceof Array) {\n        bb.write8(5);\n        bb.write32(value.length);\n\n        for (let item of value) {\n          visit(item);\n        }\n      } else {\n        let keys = Object.keys(value);\n        bb.write8(6);\n        bb.write32(keys.length);\n\n        for (let key of keys) {\n          bb.write(encodeUTF8(key));\n          visit(value[key]);\n        }\n      }\n    };\n\n    let bb = new ByteBuffer();\n    bb.write32(0);\n    bb.write32(packet.id << 1 | +!packet.isRequest);\n    visit(packet.value);\n    writeUInt32LE(bb.buf, bb.len - 4, 0);\n    return bb.buf.subarray(0, bb.len);\n  }\n\n  function decodePacket(bytes) {\n    let visit = () => {\n      switch (bb.read8()) {\n        case 0:\n          return null;\n\n        case 1:\n          return !!bb.read8();\n\n        case 2:\n          return bb.read32();\n\n        case 3:\n          return decodeUTF8(bb.read());\n\n        case 4:\n          return bb.read();\n\n        case 5:\n          {\n            let count = bb.read32();\n            let value2 = [];\n\n            for (let i = 0; i < count; i++) {\n              value2.push(visit());\n            }\n\n            return value2;\n          }\n\n        case 6:\n          {\n            let count = bb.read32();\n            let value2 = {};\n\n            for (let i = 0; i < count; i++) {\n              value2[decodeUTF8(bb.read())] = visit();\n            }\n\n            return value2;\n          }\n\n        default:\n          throw new Error(\"Invalid packet\");\n      }\n    };\n\n    let bb = new ByteBuffer(bytes);\n    let id = bb.read32();\n    let isRequest = (id & 1) === 0;\n    id >>>= 1;\n    let value = visit();\n\n    if (bb.ptr !== bytes.length) {\n      throw new Error(\"Invalid packet\");\n    }\n\n    return {\n      id,\n      isRequest,\n      value\n    };\n  }\n\n  var ByteBuffer = class {\n    constructor(buf = new Uint8Array(1024)) {\n      this.buf = buf;\n      this.len = 0;\n      this.ptr = 0;\n    }\n\n    _write(delta) {\n      if (this.len + delta > this.buf.length) {\n        let clone = new Uint8Array((this.len + delta) * 2);\n        clone.set(this.buf);\n        this.buf = clone;\n      }\n\n      this.len += delta;\n      return this.len - delta;\n    }\n\n    write8(value) {\n      let offset = this._write(1);\n\n      this.buf[offset] = value;\n    }\n\n    write32(value) {\n      let offset = this._write(4);\n\n      writeUInt32LE(this.buf, value, offset);\n    }\n\n    write(bytes) {\n      let offset = this._write(4 + bytes.length);\n\n      writeUInt32LE(this.buf, bytes.length, offset);\n      this.buf.set(bytes, offset + 4);\n    }\n\n    _read(delta) {\n      if (this.ptr + delta > this.buf.length) {\n        throw new Error(\"Invalid packet\");\n      }\n\n      this.ptr += delta;\n      return this.ptr - delta;\n    }\n\n    read8() {\n      return this.buf[this._read(1)];\n    }\n\n    read32() {\n      return readUInt32LE(this.buf, this._read(4));\n    }\n\n    read() {\n      let length = this.read32();\n      let bytes = new Uint8Array(length);\n\n      let ptr = this._read(bytes.length);\n\n      bytes.set(this.buf.subarray(ptr, ptr + length));\n      return bytes;\n    }\n\n  };\n  var encodeUTF8;\n  var decodeUTF8;\n\n  if (typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\") {\n    let encoder = new TextEncoder();\n    let decoder = new TextDecoder();\n\n    encodeUTF8 = text => encoder.encode(text);\n\n    decodeUTF8 = bytes => decoder.decode(bytes);\n  } else if (typeof Buffer !== \"undefined\") {\n    encodeUTF8 = text => {\n      let buffer = Buffer.from(text);\n\n      if (!(buffer instanceof Uint8Array)) {\n        buffer = new Uint8Array(buffer);\n      }\n\n      return buffer;\n    };\n\n    decodeUTF8 = bytes => {\n      let {\n        buffer,\n        byteOffset,\n        byteLength\n      } = bytes;\n      return Buffer.from(buffer, byteOffset, byteLength).toString();\n    };\n  } else {\n    throw new Error(\"No UTF-8 codec found\");\n  }\n\n  function readUInt32LE(buffer, offset) {\n    return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;\n  }\n\n  function writeUInt32LE(buffer, value, offset) {\n    buffer[offset++] = value;\n    buffer[offset++] = value >> 8;\n    buffer[offset++] = value >> 16;\n    buffer[offset++] = value >> 24;\n  } // lib/shared/common.ts\n\n\n  function validateTarget(target) {\n    target += \"\";\n    if (target.indexOf(\",\") >= 0) throw new Error(`Invalid target: ${target}`);\n    return target;\n  }\n\n  var canBeAnything = () => null;\n\n  var mustBeBoolean = value => typeof value === \"boolean\" ? null : \"a boolean\";\n\n  var mustBeBooleanOrObject = value => typeof value === \"boolean\" || typeof value === \"object\" && !Array.isArray(value) ? null : \"a boolean or an object\";\n\n  var mustBeString = value => typeof value === \"string\" ? null : \"a string\";\n\n  var mustBeRegExp = value => value instanceof RegExp ? null : \"a RegExp object\";\n\n  var mustBeInteger = value => typeof value === \"number\" && value === (value | 0) ? null : \"an integer\";\n\n  var mustBeFunction = value => typeof value === \"function\" ? null : \"a function\";\n\n  var mustBeArray = value => Array.isArray(value) ? null : \"an array\";\n\n  var mustBeObject = value => typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"an object\";\n\n  var mustBeArrayOrRecord = value => typeof value === \"object\" && value !== null ? null : \"an array or an object\";\n\n  var mustBeObjectOrNull = value => typeof value === \"object\" && !Array.isArray(value) ? null : \"an object or null\";\n\n  var mustBeStringOrBoolean = value => typeof value === \"string\" || typeof value === \"boolean\" ? null : \"a string or a boolean\";\n\n  var mustBeStringOrObject = value => typeof value === \"string\" || typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"a string or an object\";\n\n  var mustBeStringOrArray = value => typeof value === \"string\" || Array.isArray(value) ? null : \"a string or an array\";\n\n  var mustBeStringOrUint8Array = value => typeof value === \"string\" || value instanceof Uint8Array ? null : \"a string or a Uint8Array\";\n\n  function getFlag(object, keys, key, mustBeFn) {\n    let value = object[key];\n    keys[key + \"\"] = true;\n    if (value === void 0) return void 0;\n    let mustBe = mustBeFn(value);\n    if (mustBe !== null) throw new Error(`\"${key}\" must be ${mustBe}`);\n    return value;\n  }\n\n  function checkForInvalidFlags(object, keys, where) {\n    for (let key in object) {\n      if (!(key in keys)) {\n        throw new Error(`Invalid option ${where}: \"${key}\"`);\n      }\n    }\n  }\n\n  function validateInitializeOptions(options) {\n    let keys = /* @__PURE__ */Object.create(null);\n    let wasmURL = getFlag(options, keys, \"wasmURL\", mustBeString);\n    let worker = getFlag(options, keys, \"worker\", mustBeBoolean);\n    checkForInvalidFlags(options, keys, \"in startService() call\");\n    return {\n      wasmURL,\n      worker\n    };\n  }\n\n  function validateMangleCache(mangleCache) {\n    let validated;\n\n    if (mangleCache !== void 0) {\n      validated = /* @__PURE__ */Object.create(null);\n\n      for (let key of Object.keys(mangleCache)) {\n        let value = mangleCache[key];\n\n        if (typeof value === \"string\" || value === false) {\n          validated[key] = value;\n        } else {\n          throw new Error(`Expected ${JSON.stringify(key)} in mangle cache to map to either a string or false`);\n        }\n      }\n    }\n\n    return validated;\n  }\n\n  function pushLogFlags(flags, options, keys, isTTY, logLevelDefault) {\n    let color = getFlag(options, keys, \"color\", mustBeBoolean);\n    let logLevel = getFlag(options, keys, \"logLevel\", mustBeString);\n    let logLimit = getFlag(options, keys, \"logLimit\", mustBeInteger);\n    if (color !== void 0) flags.push(`--color=${color}`);else if (isTTY) flags.push(`--color=true`);\n    flags.push(`--log-level=${logLevel || logLevelDefault}`);\n    flags.push(`--log-limit=${logLimit || 0}`);\n  }\n\n  function pushCommonFlags(flags, options, keys) {\n    let legalComments = getFlag(options, keys, \"legalComments\", mustBeString);\n    let sourceRoot = getFlag(options, keys, \"sourceRoot\", mustBeString);\n    let sourcesContent = getFlag(options, keys, \"sourcesContent\", mustBeBoolean);\n    let target = getFlag(options, keys, \"target\", mustBeStringOrArray);\n    let format = getFlag(options, keys, \"format\", mustBeString);\n    let globalName = getFlag(options, keys, \"globalName\", mustBeString);\n    let mangleProps = getFlag(options, keys, \"mangleProps\", mustBeRegExp);\n    let reserveProps = getFlag(options, keys, \"reserveProps\", mustBeRegExp);\n    let minify = getFlag(options, keys, \"minify\", mustBeBoolean);\n    let minifySyntax = getFlag(options, keys, \"minifySyntax\", mustBeBoolean);\n    let minifyWhitespace = getFlag(options, keys, \"minifyWhitespace\", mustBeBoolean);\n    let minifyIdentifiers = getFlag(options, keys, \"minifyIdentifiers\", mustBeBoolean);\n    let drop = getFlag(options, keys, \"drop\", mustBeArray);\n    let charset = getFlag(options, keys, \"charset\", mustBeString);\n    let treeShaking = getFlag(options, keys, \"treeShaking\", mustBeBoolean);\n    let ignoreAnnotations = getFlag(options, keys, \"ignoreAnnotations\", mustBeBoolean);\n    let jsx = getFlag(options, keys, \"jsx\", mustBeString);\n    let jsxFactory = getFlag(options, keys, \"jsxFactory\", mustBeString);\n    let jsxFragment = getFlag(options, keys, \"jsxFragment\", mustBeString);\n    let define = getFlag(options, keys, \"define\", mustBeObject);\n    let pure = getFlag(options, keys, \"pure\", mustBeArray);\n    let keepNames = getFlag(options, keys, \"keepNames\", mustBeBoolean);\n    if (legalComments) flags.push(`--legal-comments=${legalComments}`);\n    if (sourceRoot !== void 0) flags.push(`--source-root=${sourceRoot}`);\n    if (sourcesContent !== void 0) flags.push(`--sources-content=${sourcesContent}`);\n\n    if (target) {\n      if (Array.isArray(target)) flags.push(`--target=${Array.from(target).map(validateTarget).join(\",\")}`);else flags.push(`--target=${validateTarget(target)}`);\n    }\n\n    if (format) flags.push(`--format=${format}`);\n    if (globalName) flags.push(`--global-name=${globalName}`);\n    if (minify) flags.push(\"--minify\");\n    if (minifySyntax) flags.push(\"--minify-syntax\");\n    if (minifyWhitespace) flags.push(\"--minify-whitespace\");\n    if (minifyIdentifiers) flags.push(\"--minify-identifiers\");\n    if (charset) flags.push(`--charset=${charset}`);\n    if (treeShaking !== void 0) flags.push(`--tree-shaking=${treeShaking}`);\n    if (ignoreAnnotations) flags.push(`--ignore-annotations`);\n    if (drop) for (let what of drop) flags.push(`--drop:${what}`);\n    if (mangleProps) flags.push(`--mangle-props=${mangleProps.source}`);\n    if (reserveProps) flags.push(`--reserve-props=${reserveProps.source}`);\n    if (jsx) flags.push(`--jsx=${jsx}`);\n    if (jsxFactory) flags.push(`--jsx-factory=${jsxFactory}`);\n    if (jsxFragment) flags.push(`--jsx-fragment=${jsxFragment}`);\n\n    if (define) {\n      for (let key in define) {\n        if (key.indexOf(\"=\") >= 0) throw new Error(`Invalid define: ${key}`);\n        flags.push(`--define:${key}=${define[key]}`);\n      }\n    }\n\n    if (pure) for (let fn of pure) flags.push(`--pure:${fn}`);\n    if (keepNames) flags.push(`--keep-names`);\n  }\n\n  function flagsForBuildOptions(callName, options, isTTY, logLevelDefault, writeDefault) {\n    var _a;\n\n    let flags = [];\n    let entries = [];\n    let keys = /* @__PURE__ */Object.create(null);\n    let stdinContents = null;\n    let stdinResolveDir = null;\n    let watchMode = null;\n    pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n    pushCommonFlags(flags, options, keys);\n    let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n    let bundle = getFlag(options, keys, \"bundle\", mustBeBoolean);\n    let watch = getFlag(options, keys, \"watch\", mustBeBooleanOrObject);\n    let splitting = getFlag(options, keys, \"splitting\", mustBeBoolean);\n    let preserveSymlinks = getFlag(options, keys, \"preserveSymlinks\", mustBeBoolean);\n    let metafile = getFlag(options, keys, \"metafile\", mustBeBoolean);\n    let outfile = getFlag(options, keys, \"outfile\", mustBeString);\n    let outdir = getFlag(options, keys, \"outdir\", mustBeString);\n    let outbase = getFlag(options, keys, \"outbase\", mustBeString);\n    let platform = getFlag(options, keys, \"platform\", mustBeString);\n    let tsconfig = getFlag(options, keys, \"tsconfig\", mustBeString);\n    let resolveExtensions = getFlag(options, keys, \"resolveExtensions\", mustBeArray);\n    let nodePathsInput = getFlag(options, keys, \"nodePaths\", mustBeArray);\n    let mainFields = getFlag(options, keys, \"mainFields\", mustBeArray);\n    let conditions = getFlag(options, keys, \"conditions\", mustBeArray);\n    let external = getFlag(options, keys, \"external\", mustBeArray);\n    let loader = getFlag(options, keys, \"loader\", mustBeObject);\n    let outExtension = getFlag(options, keys, \"outExtension\", mustBeObject);\n    let publicPath = getFlag(options, keys, \"publicPath\", mustBeString);\n    let entryNames = getFlag(options, keys, \"entryNames\", mustBeString);\n    let chunkNames = getFlag(options, keys, \"chunkNames\", mustBeString);\n    let assetNames = getFlag(options, keys, \"assetNames\", mustBeString);\n    let inject = getFlag(options, keys, \"inject\", mustBeArray);\n    let banner = getFlag(options, keys, \"banner\", mustBeObject);\n    let footer = getFlag(options, keys, \"footer\", mustBeObject);\n    let entryPoints = getFlag(options, keys, \"entryPoints\", mustBeArrayOrRecord);\n    let absWorkingDir = getFlag(options, keys, \"absWorkingDir\", mustBeString);\n    let stdin = getFlag(options, keys, \"stdin\", mustBeObject);\n    let write = (_a = getFlag(options, keys, \"write\", mustBeBoolean)) != null ? _a : writeDefault;\n    let allowOverwrite = getFlag(options, keys, \"allowOverwrite\", mustBeBoolean);\n    let incremental = getFlag(options, keys, \"incremental\", mustBeBoolean) === true;\n    let mangleCache = getFlag(options, keys, \"mangleCache\", mustBeObject);\n    keys.plugins = true;\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    if (sourcemap) flags.push(`--sourcemap${sourcemap === true ? \"\" : `=${sourcemap}`}`);\n    if (bundle) flags.push(\"--bundle\");\n    if (allowOverwrite) flags.push(\"--allow-overwrite\");\n\n    if (watch) {\n      flags.push(\"--watch\");\n\n      if (typeof watch === \"boolean\") {\n        watchMode = {};\n      } else {\n        let watchKeys = /* @__PURE__ */Object.create(null);\n        let onRebuild = getFlag(watch, watchKeys, \"onRebuild\", mustBeFunction);\n        checkForInvalidFlags(watch, watchKeys, `on \"watch\" in ${callName}() call`);\n        watchMode = {\n          onRebuild\n        };\n      }\n    }\n\n    if (splitting) flags.push(\"--splitting\");\n    if (preserveSymlinks) flags.push(\"--preserve-symlinks\");\n    if (metafile) flags.push(`--metafile`);\n    if (outfile) flags.push(`--outfile=${outfile}`);\n    if (outdir) flags.push(`--outdir=${outdir}`);\n    if (outbase) flags.push(`--outbase=${outbase}`);\n    if (platform) flags.push(`--platform=${platform}`);\n    if (tsconfig) flags.push(`--tsconfig=${tsconfig}`);\n\n    if (resolveExtensions) {\n      let values = [];\n\n      for (let value of resolveExtensions) {\n        value += \"\";\n        if (value.indexOf(\",\") >= 0) throw new Error(`Invalid resolve extension: ${value}`);\n        values.push(value);\n      }\n\n      flags.push(`--resolve-extensions=${values.join(\",\")}`);\n    }\n\n    if (publicPath) flags.push(`--public-path=${publicPath}`);\n    if (entryNames) flags.push(`--entry-names=${entryNames}`);\n    if (chunkNames) flags.push(`--chunk-names=${chunkNames}`);\n    if (assetNames) flags.push(`--asset-names=${assetNames}`);\n\n    if (mainFields) {\n      let values = [];\n\n      for (let value of mainFields) {\n        value += \"\";\n        if (value.indexOf(\",\") >= 0) throw new Error(`Invalid main field: ${value}`);\n        values.push(value);\n      }\n\n      flags.push(`--main-fields=${values.join(\",\")}`);\n    }\n\n    if (conditions) {\n      let values = [];\n\n      for (let value of conditions) {\n        value += \"\";\n        if (value.indexOf(\",\") >= 0) throw new Error(`Invalid condition: ${value}`);\n        values.push(value);\n      }\n\n      flags.push(`--conditions=${values.join(\",\")}`);\n    }\n\n    if (external) for (let name of external) flags.push(`--external:${name}`);\n\n    if (banner) {\n      for (let type in banner) {\n        if (type.indexOf(\"=\") >= 0) throw new Error(`Invalid banner file type: ${type}`);\n        flags.push(`--banner:${type}=${banner[type]}`);\n      }\n    }\n\n    if (footer) {\n      for (let type in footer) {\n        if (type.indexOf(\"=\") >= 0) throw new Error(`Invalid footer file type: ${type}`);\n        flags.push(`--footer:${type}=${footer[type]}`);\n      }\n    }\n\n    if (inject) for (let path of inject) flags.push(`--inject:${path}`);\n\n    if (loader) {\n      for (let ext in loader) {\n        if (ext.indexOf(\"=\") >= 0) throw new Error(`Invalid loader extension: ${ext}`);\n        flags.push(`--loader:${ext}=${loader[ext]}`);\n      }\n    }\n\n    if (outExtension) {\n      for (let ext in outExtension) {\n        if (ext.indexOf(\"=\") >= 0) throw new Error(`Invalid out extension: ${ext}`);\n        flags.push(`--out-extension:${ext}=${outExtension[ext]}`);\n      }\n    }\n\n    if (entryPoints) {\n      if (Array.isArray(entryPoints)) {\n        for (let entryPoint of entryPoints) {\n          entries.push([\"\", entryPoint + \"\"]);\n        }\n      } else {\n        for (let [key, value] of Object.entries(entryPoints)) {\n          entries.push([key + \"\", value + \"\"]);\n        }\n      }\n    }\n\n    if (stdin) {\n      let stdinKeys = /* @__PURE__ */Object.create(null);\n      let contents = getFlag(stdin, stdinKeys, \"contents\", mustBeString);\n      let resolveDir = getFlag(stdin, stdinKeys, \"resolveDir\", mustBeString);\n      let sourcefile = getFlag(stdin, stdinKeys, \"sourcefile\", mustBeString);\n      let loader2 = getFlag(stdin, stdinKeys, \"loader\", mustBeString);\n      checkForInvalidFlags(stdin, stdinKeys, 'in \"stdin\" object');\n      if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);\n      if (loader2) flags.push(`--loader=${loader2}`);\n      if (resolveDir) stdinResolveDir = resolveDir + \"\";\n      stdinContents = contents ? contents + \"\" : \"\";\n    }\n\n    let nodePaths = [];\n\n    if (nodePathsInput) {\n      for (let value of nodePathsInput) {\n        value += \"\";\n        nodePaths.push(value);\n      }\n    }\n\n    return {\n      entries,\n      flags,\n      write,\n      stdinContents,\n      stdinResolveDir,\n      absWorkingDir,\n      incremental,\n      nodePaths,\n      watch: watchMode,\n      mangleCache: validateMangleCache(mangleCache)\n    };\n  }\n\n  function flagsForTransformOptions(callName, options, isTTY, logLevelDefault) {\n    let flags = [];\n    let keys = /* @__PURE__ */Object.create(null);\n    pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n    pushCommonFlags(flags, options, keys);\n    let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n    let tsconfigRaw = getFlag(options, keys, \"tsconfigRaw\", mustBeStringOrObject);\n    let sourcefile = getFlag(options, keys, \"sourcefile\", mustBeString);\n    let loader = getFlag(options, keys, \"loader\", mustBeString);\n    let banner = getFlag(options, keys, \"banner\", mustBeString);\n    let footer = getFlag(options, keys, \"footer\", mustBeString);\n    let mangleCache = getFlag(options, keys, \"mangleCache\", mustBeObject);\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    if (sourcemap) flags.push(`--sourcemap=${sourcemap === true ? \"external\" : sourcemap}`);\n    if (tsconfigRaw) flags.push(`--tsconfig-raw=${typeof tsconfigRaw === \"string\" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);\n    if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);\n    if (loader) flags.push(`--loader=${loader}`);\n    if (banner) flags.push(`--banner=${banner}`);\n    if (footer) flags.push(`--footer=${footer}`);\n    return {\n      flags,\n      mangleCache: validateMangleCache(mangleCache)\n    };\n  }\n\n  function createChannel(streamIn) {\n    let responseCallbacks = /* @__PURE__ */new Map();\n    let pluginCallbacks = /* @__PURE__ */new Map();\n    let watchCallbacks = /* @__PURE__ */new Map();\n    let serveCallbacks = /* @__PURE__ */new Map();\n    let isClosed = false;\n    let nextRequestID = 0;\n    let nextBuildKey = 0;\n    let stdout = new Uint8Array(16 * 1024);\n    let stdoutUsed = 0;\n\n    let readFromStdout = chunk => {\n      let limit = stdoutUsed + chunk.length;\n\n      if (limit > stdout.length) {\n        let swap = new Uint8Array(limit * 2);\n        swap.set(stdout);\n        stdout = swap;\n      }\n\n      stdout.set(chunk, stdoutUsed);\n      stdoutUsed += chunk.length;\n      let offset = 0;\n\n      while (offset + 4 <= stdoutUsed) {\n        let length = readUInt32LE(stdout, offset);\n\n        if (offset + 4 + length > stdoutUsed) {\n          break;\n        }\n\n        offset += 4;\n        handleIncomingPacket(stdout.subarray(offset, offset + length));\n        offset += length;\n      }\n\n      if (offset > 0) {\n        stdout.copyWithin(0, offset, stdoutUsed);\n        stdoutUsed -= offset;\n      }\n    };\n\n    let afterClose = () => {\n      isClosed = true;\n\n      for (let callback of responseCallbacks.values()) {\n        callback(\"The service was stopped\", null);\n      }\n\n      responseCallbacks.clear();\n\n      for (let callbacks of serveCallbacks.values()) {\n        callbacks.onWait(\"The service was stopped\");\n      }\n\n      serveCallbacks.clear();\n\n      for (let callback of watchCallbacks.values()) {\n        try {\n          callback(new Error(\"The service was stopped\"), null);\n        } catch (e) {\n          console.error(e);\n        }\n      }\n\n      watchCallbacks.clear();\n    };\n\n    let sendRequest = (refs, value, callback) => {\n      if (isClosed) return callback(\"The service is no longer running\", null);\n      let id = nextRequestID++;\n      responseCallbacks.set(id, (error, response) => {\n        try {\n          callback(error, response);\n        } finally {\n          if (refs) refs.unref();\n        }\n      });\n      if (refs) refs.ref();\n      streamIn.writeToStdin(encodePacket({\n        id,\n        isRequest: true,\n        value\n      }));\n    };\n\n    let sendResponse = (id, value) => {\n      if (isClosed) throw new Error(\"The service is no longer running\");\n      streamIn.writeToStdin(encodePacket({\n        id,\n        isRequest: false,\n        value\n      }));\n    };\n\n    let handleRequest = (id, request) => __async(this, null, function* () {\n      try {\n        switch (request.command) {\n          case \"ping\":\n            {\n              sendResponse(id, {});\n              break;\n            }\n\n          case \"on-start\":\n            {\n              let callback = pluginCallbacks.get(request.key);\n              if (!callback) sendResponse(id, {});else sendResponse(id, yield callback(request));\n              break;\n            }\n\n          case \"on-resolve\":\n            {\n              let callback = pluginCallbacks.get(request.key);\n              if (!callback) sendResponse(id, {});else sendResponse(id, yield callback(request));\n              break;\n            }\n\n          case \"on-load\":\n            {\n              let callback = pluginCallbacks.get(request.key);\n              if (!callback) sendResponse(id, {});else sendResponse(id, yield callback(request));\n              break;\n            }\n\n          case \"serve-request\":\n            {\n              let callbacks = serveCallbacks.get(request.key);\n              if (callbacks && callbacks.onRequest) callbacks.onRequest(request.args);\n              sendResponse(id, {});\n              break;\n            }\n\n          case \"serve-wait\":\n            {\n              let callbacks = serveCallbacks.get(request.key);\n              if (callbacks) callbacks.onWait(request.error);\n              sendResponse(id, {});\n              break;\n            }\n\n          case \"watch-rebuild\":\n            {\n              let callback = watchCallbacks.get(request.key);\n\n              try {\n                if (callback) callback(null, request.args);\n              } catch (err) {\n                console.error(err);\n              }\n\n              sendResponse(id, {});\n              break;\n            }\n\n          default:\n            throw new Error(`Invalid command: ` + request.command);\n        }\n      } catch (e) {\n        sendResponse(id, {\n          errors: [extractErrorMessageV8(e, streamIn, null, void 0, \"\")]\n        });\n      }\n    });\n\n    let isFirstPacket = true;\n\n    let handleIncomingPacket = bytes => {\n      if (isFirstPacket) {\n        isFirstPacket = false;\n        let binaryVersion = String.fromCharCode(...bytes);\n\n        if (binaryVersion !== \"0.14.22\") {\n          throw new Error(`Cannot start service: Host version \"${\"0.14.22\"}\" does not match binary version ${JSON.stringify(binaryVersion)}`);\n        }\n\n        return;\n      }\n\n      let packet = decodePacket(bytes);\n\n      if (packet.isRequest) {\n        handleRequest(packet.id, packet.value);\n      } else {\n        let callback = responseCallbacks.get(packet.id);\n        responseCallbacks.delete(packet.id);\n        if (packet.value.error) callback(packet.value.error, {});else callback(null, packet.value);\n      }\n    };\n\n    let handlePlugins = (initialOptions, plugins, buildKey, stash, refs) => __async(this, null, function* () {\n      let onStartCallbacks = [];\n      let onEndCallbacks = [];\n      let onResolveCallbacks = {};\n      let onLoadCallbacks = {};\n      let nextCallbackID = 0;\n      let i = 0;\n      let requestPlugins = [];\n      let isSetupDone = false;\n      plugins = [...plugins];\n\n      for (let item of plugins) {\n        let keys = {};\n        if (typeof item !== \"object\") throw new Error(`Plugin at index ${i} must be an object`);\n        const name = getFlag(item, keys, \"name\", mustBeString);\n        if (typeof name !== \"string\" || name === \"\") throw new Error(`Plugin at index ${i} is missing a name`);\n\n        try {\n          let setup = getFlag(item, keys, \"setup\", mustBeFunction);\n          if (typeof setup !== \"function\") throw new Error(`Plugin is missing a setup function`);\n          checkForInvalidFlags(item, keys, `on plugin ${JSON.stringify(name)}`);\n          let plugin = {\n            name,\n            onResolve: [],\n            onLoad: []\n          };\n          i++;\n\n          let resolve = (path, options = {}) => {\n            if (!isSetupDone) throw new Error('Cannot call \"resolve\" before plugin setup has completed');\n            if (typeof path !== \"string\") throw new Error(`The path to resolve must be a string`);\n            let keys2 = /* @__PURE__ */Object.create(null);\n            let pluginName = getFlag(options, keys2, \"pluginName\", mustBeString);\n            let importer = getFlag(options, keys2, \"importer\", mustBeString);\n            let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n            let resolveDir = getFlag(options, keys2, \"resolveDir\", mustBeString);\n            let kind = getFlag(options, keys2, \"kind\", mustBeString);\n            let pluginData = getFlag(options, keys2, \"pluginData\", canBeAnything);\n            checkForInvalidFlags(options, keys2, \"in resolve() call\");\n            return new Promise((resolve2, reject) => {\n              const request = {\n                command: \"resolve\",\n                path,\n                key: buildKey,\n                pluginName: name\n              };\n              if (pluginName != null) request.pluginName = pluginName;\n              if (importer != null) request.importer = importer;\n              if (namespace != null) request.namespace = namespace;\n              if (resolveDir != null) request.resolveDir = resolveDir;\n              if (kind != null) request.kind = kind;\n              if (pluginData != null) request.pluginData = stash.store(pluginData);\n              sendRequest(refs, request, (error, response) => {\n                if (error !== null) reject(new Error(error));else resolve2({\n                  errors: replaceDetailsInMessages(response.errors, stash),\n                  warnings: replaceDetailsInMessages(response.warnings, stash),\n                  path: response.path,\n                  external: response.external,\n                  sideEffects: response.sideEffects,\n                  namespace: response.namespace,\n                  suffix: response.suffix,\n                  pluginData: stash.load(response.pluginData)\n                });\n              });\n            });\n          };\n\n          let promise = setup({\n            initialOptions,\n            resolve,\n\n            onStart(callback2) {\n              let registeredText = `This error came from the \"onStart\" callback registered here:`;\n              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onStart\");\n              onStartCallbacks.push({\n                name,\n                callback: callback2,\n                note: registeredNote\n              });\n            },\n\n            onEnd(callback2) {\n              let registeredText = `This error came from the \"onEnd\" callback registered here:`;\n              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onEnd\");\n              onEndCallbacks.push({\n                name,\n                callback: callback2,\n                note: registeredNote\n              });\n            },\n\n            onResolve(options, callback2) {\n              let registeredText = `This error came from the \"onResolve\" callback registered here:`;\n              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onResolve\");\n              let keys2 = {};\n              let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n              let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n              checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${JSON.stringify(name)}`);\n              if (filter == null) throw new Error(`onResolve() call is missing a filter`);\n              let id = nextCallbackID++;\n              onResolveCallbacks[id] = {\n                name,\n                callback: callback2,\n                note: registeredNote\n              };\n              plugin.onResolve.push({\n                id,\n                filter: filter.source,\n                namespace: namespace || \"\"\n              });\n            },\n\n            onLoad(options, callback2) {\n              let registeredText = `This error came from the \"onLoad\" callback registered here:`;\n              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onLoad\");\n              let keys2 = {};\n              let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n              let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n              checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${JSON.stringify(name)}`);\n              if (filter == null) throw new Error(`onLoad() call is missing a filter`);\n              let id = nextCallbackID++;\n              onLoadCallbacks[id] = {\n                name,\n                callback: callback2,\n                note: registeredNote\n              };\n              plugin.onLoad.push({\n                id,\n                filter: filter.source,\n                namespace: namespace || \"\"\n              });\n            },\n\n            esbuild: streamIn.esbuild\n          });\n          if (promise) yield promise;\n          requestPlugins.push(plugin);\n        } catch (e) {\n          return {\n            ok: false,\n            error: e,\n            pluginName: name\n          };\n        }\n      }\n\n      const callback = request => __async(this, null, function* () {\n        switch (request.command) {\n          case \"on-start\":\n            {\n              let response = {\n                errors: [],\n                warnings: []\n              };\n              yield Promise.all(onStartCallbacks.map(_0 => __async(this, [_0], function* ({\n                name,\n                callback: callback2,\n                note\n              }) {\n                try {\n                  let result = yield callback2();\n\n                  if (result != null) {\n                    if (typeof result !== \"object\") throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(name)} to return an object`);\n                    let keys = {};\n                    let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                    let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                    checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${JSON.stringify(name)}`);\n                    if (errors != null) response.errors.push(...sanitizeMessages(errors, \"errors\", stash, name));\n                    if (warnings != null) response.warnings.push(...sanitizeMessages(warnings, \"warnings\", stash, name));\n                  }\n                } catch (e) {\n                  response.errors.push(extractErrorMessageV8(e, streamIn, stash, note && note(), name));\n                }\n              })));\n              return response;\n            }\n\n          case \"on-resolve\":\n            {\n              let response = {},\n                  name = \"\",\n                  callback2,\n                  note;\n\n              for (let id of request.ids) {\n                try {\n                  ({\n                    name,\n                    callback: callback2,\n                    note\n                  } = onResolveCallbacks[id]);\n                  let result = yield callback2({\n                    path: request.path,\n                    importer: request.importer,\n                    namespace: request.namespace,\n                    resolveDir: request.resolveDir,\n                    kind: request.kind,\n                    pluginData: stash.load(request.pluginData)\n                  });\n\n                  if (result != null) {\n                    if (typeof result !== \"object\") throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(name)} to return an object`);\n                    let keys = {};\n                    let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                    let path = getFlag(result, keys, \"path\", mustBeString);\n                    let namespace = getFlag(result, keys, \"namespace\", mustBeString);\n                    let suffix = getFlag(result, keys, \"suffix\", mustBeString);\n                    let external = getFlag(result, keys, \"external\", mustBeBoolean);\n                    let sideEffects = getFlag(result, keys, \"sideEffects\", mustBeBoolean);\n                    let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                    let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                    let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                    let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n                    let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n                    checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${JSON.stringify(name)}`);\n                    response.id = id;\n                    if (pluginName != null) response.pluginName = pluginName;\n                    if (path != null) response.path = path;\n                    if (namespace != null) response.namespace = namespace;\n                    if (suffix != null) response.suffix = suffix;\n                    if (external != null) response.external = external;\n                    if (sideEffects != null) response.sideEffects = sideEffects;\n                    if (pluginData != null) response.pluginData = stash.store(pluginData);\n                    if (errors != null) response.errors = sanitizeMessages(errors, \"errors\", stash, name);\n                    if (warnings != null) response.warnings = sanitizeMessages(warnings, \"warnings\", stash, name);\n                    if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                    if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                    break;\n                  }\n                } catch (e) {\n                  return {\n                    id,\n                    errors: [extractErrorMessageV8(e, streamIn, stash, note && note(), name)]\n                  };\n                }\n              }\n\n              return response;\n            }\n\n          case \"on-load\":\n            {\n              let response = {},\n                  name = \"\",\n                  callback2,\n                  note;\n\n              for (let id of request.ids) {\n                try {\n                  ({\n                    name,\n                    callback: callback2,\n                    note\n                  } = onLoadCallbacks[id]);\n                  let result = yield callback2({\n                    path: request.path,\n                    namespace: request.namespace,\n                    suffix: request.suffix,\n                    pluginData: stash.load(request.pluginData)\n                  });\n\n                  if (result != null) {\n                    if (typeof result !== \"object\") throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(name)} to return an object`);\n                    let keys = {};\n                    let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                    let contents = getFlag(result, keys, \"contents\", mustBeStringOrUint8Array);\n                    let resolveDir = getFlag(result, keys, \"resolveDir\", mustBeString);\n                    let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                    let loader = getFlag(result, keys, \"loader\", mustBeString);\n                    let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                    let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                    let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n                    let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n                    checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${JSON.stringify(name)}`);\n                    response.id = id;\n                    if (pluginName != null) response.pluginName = pluginName;\n                    if (contents instanceof Uint8Array) response.contents = contents;else if (contents != null) response.contents = encodeUTF8(contents);\n                    if (resolveDir != null) response.resolveDir = resolveDir;\n                    if (pluginData != null) response.pluginData = stash.store(pluginData);\n                    if (loader != null) response.loader = loader;\n                    if (errors != null) response.errors = sanitizeMessages(errors, \"errors\", stash, name);\n                    if (warnings != null) response.warnings = sanitizeMessages(warnings, \"warnings\", stash, name);\n                    if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                    if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                    break;\n                  }\n                } catch (e) {\n                  return {\n                    id,\n                    errors: [extractErrorMessageV8(e, streamIn, stash, note && note(), name)]\n                  };\n                }\n              }\n\n              return response;\n            }\n\n          default:\n            throw new Error(`Invalid command: ` + request.command);\n        }\n      });\n\n      let runOnEndCallbacks = (result, logPluginError, done) => done();\n\n      if (onEndCallbacks.length > 0) {\n        runOnEndCallbacks = (result, logPluginError, done) => {\n          (() => __async(this, null, function* () {\n            for (const {\n              name,\n              callback: callback2,\n              note\n            } of onEndCallbacks) {\n              try {\n                yield callback2(result);\n              } catch (e) {\n                result.errors.push(yield new Promise(resolve => logPluginError(e, name, note && note(), resolve)));\n              }\n            }\n          }))().then(done);\n        };\n      }\n\n      isSetupDone = true;\n      let refCount = 0;\n      return {\n        ok: true,\n        requestPlugins,\n        runOnEndCallbacks,\n        pluginRefs: {\n          ref() {\n            if (++refCount === 1) pluginCallbacks.set(buildKey, callback);\n          },\n\n          unref() {\n            if (--refCount === 0) pluginCallbacks.delete(buildKey);\n          }\n\n        }\n      };\n    });\n\n    let buildServeData = (refs, options, request, key) => {\n      let keys = {};\n      let port = getFlag(options, keys, \"port\", mustBeInteger);\n      let host = getFlag(options, keys, \"host\", mustBeString);\n      let servedir = getFlag(options, keys, \"servedir\", mustBeString);\n      let onRequest = getFlag(options, keys, \"onRequest\", mustBeFunction);\n      let onWait;\n      let wait = new Promise((resolve, reject) => {\n        onWait = error => {\n          serveCallbacks.delete(key);\n          if (error !== null) reject(new Error(error));else resolve();\n        };\n      });\n      request.serve = {};\n      checkForInvalidFlags(options, keys, `in serve() call`);\n      if (port !== void 0) request.serve.port = port;\n      if (host !== void 0) request.serve.host = host;\n      if (servedir !== void 0) request.serve.servedir = servedir;\n      serveCallbacks.set(key, {\n        onRequest,\n        onWait\n      });\n      return {\n        wait,\n\n        stop() {\n          sendRequest(refs, {\n            command: \"serve-stop\",\n            key\n          }, () => {});\n        }\n\n      };\n    };\n\n    const buildLogLevelDefault = \"warning\";\n    const transformLogLevelDefault = \"silent\";\n\n    let buildOrServe = args => {\n      let key = nextBuildKey++;\n      const details = createObjectStash();\n      let plugins;\n      let {\n        refs,\n        options,\n        isTTY,\n        callback\n      } = args;\n\n      if (typeof options === \"object\") {\n        let value = options.plugins;\n\n        if (value !== void 0) {\n          if (!Array.isArray(value)) throw new Error(`\"plugins\" must be an array`);\n          plugins = value;\n        }\n      }\n\n      let logPluginError = (e, pluginName, note, done) => {\n        let flags = [];\n\n        try {\n          pushLogFlags(flags, options, {}, isTTY, buildLogLevelDefault);\n        } catch (e2) {}\n\n        const message = extractErrorMessageV8(e, streamIn, details, note, pluginName);\n        sendRequest(refs, {\n          command: \"error\",\n          flags,\n          error: message\n        }, () => {\n          message.detail = details.load(message.detail);\n          done(message);\n        });\n      };\n\n      let handleError = (e, pluginName) => {\n        logPluginError(e, pluginName, void 0, error => {\n          callback(failureErrorWithLog(\"Build failed\", [error], []), null);\n        });\n      };\n\n      if (plugins && plugins.length > 0) {\n        if (streamIn.isSync) return handleError(new Error(\"Cannot use plugins in synchronous API calls\"), \"\");\n        handlePlugins(options, plugins, key, details, refs).then(result => {\n          if (!result.ok) {\n            handleError(result.error, result.pluginName);\n          } else {\n            try {\n              buildOrServeContinue(__spreadProps(__spreadValues({}, args), {\n                key,\n                details,\n                logPluginError,\n                requestPlugins: result.requestPlugins,\n                runOnEndCallbacks: result.runOnEndCallbacks,\n                pluginRefs: result.pluginRefs\n              }));\n            } catch (e) {\n              handleError(e, \"\");\n            }\n          }\n        }, e => handleError(e, \"\"));\n      } else {\n        try {\n          buildOrServeContinue(__spreadProps(__spreadValues({}, args), {\n            key,\n            details,\n            logPluginError,\n            requestPlugins: null,\n            runOnEndCallbacks: (result, logPluginError2, done) => done(),\n            pluginRefs: null\n          }));\n        } catch (e) {\n          handleError(e, \"\");\n        }\n      }\n    };\n\n    let buildOrServeContinue = ({\n      callName,\n      refs: callerRefs,\n      serveOptions,\n      options,\n      isTTY,\n      defaultWD,\n      callback,\n      key,\n      details,\n      logPluginError,\n      requestPlugins,\n      runOnEndCallbacks,\n      pluginRefs\n    }) => {\n      const refs = {\n        ref() {\n          if (pluginRefs) pluginRefs.ref();\n          if (callerRefs) callerRefs.ref();\n        },\n\n        unref() {\n          if (pluginRefs) pluginRefs.unref();\n          if (callerRefs) callerRefs.unref();\n        }\n\n      };\n      let writeDefault = !streamIn.isBrowser;\n      let {\n        entries,\n        flags,\n        write,\n        stdinContents,\n        stdinResolveDir,\n        absWorkingDir,\n        incremental,\n        nodePaths,\n        watch,\n        mangleCache\n      } = flagsForBuildOptions(callName, options, isTTY, buildLogLevelDefault, writeDefault);\n      let request = {\n        command: \"build\",\n        key,\n        entries,\n        flags,\n        write,\n        stdinContents,\n        stdinResolveDir,\n        absWorkingDir: absWorkingDir || defaultWD,\n        incremental,\n        nodePaths\n      };\n      if (requestPlugins) request.plugins = requestPlugins;\n      if (mangleCache) request.mangleCache = mangleCache;\n      let serve2 = serveOptions && buildServeData(refs, serveOptions, request, key);\n      let rebuild;\n      let stop;\n\n      let copyResponseToResult = (response, result) => {\n        if (response.outputFiles) result.outputFiles = response.outputFiles.map(convertOutputFiles);\n        if (response.metafile) result.metafile = JSON.parse(response.metafile);\n        if (response.mangleCache) result.mangleCache = response.mangleCache;\n        if (response.writeToStdout !== void 0) console.log(decodeUTF8(response.writeToStdout).replace(/\\n$/, \"\"));\n      };\n\n      let buildResponseToResult = (response, callback2) => {\n        let result = {\n          errors: replaceDetailsInMessages(response.errors, details),\n          warnings: replaceDetailsInMessages(response.warnings, details)\n        };\n        copyResponseToResult(response, result);\n        runOnEndCallbacks(result, logPluginError, () => {\n          if (result.errors.length > 0) {\n            return callback2(failureErrorWithLog(\"Build failed\", result.errors, result.warnings), null);\n          }\n\n          if (response.rebuild) {\n            if (!rebuild) {\n              let isDisposed = false;\n\n              rebuild = () => new Promise((resolve, reject) => {\n                if (isDisposed || isClosed) throw new Error(\"Cannot rebuild\");\n                sendRequest(refs, {\n                  command: \"rebuild\",\n                  key\n                }, (error2, response2) => {\n                  if (error2) {\n                    const message = {\n                      pluginName: \"\",\n                      text: error2,\n                      location: null,\n                      notes: [],\n                      detail: void 0\n                    };\n                    return callback2(failureErrorWithLog(\"Build failed\", [message], []), null);\n                  }\n\n                  buildResponseToResult(response2, (error3, result3) => {\n                    if (error3) reject(error3);else resolve(result3);\n                  });\n                });\n              });\n\n              refs.ref();\n\n              rebuild.dispose = () => {\n                if (isDisposed) return;\n                isDisposed = true;\n                sendRequest(refs, {\n                  command: \"rebuild-dispose\",\n                  key\n                }, () => {});\n                refs.unref();\n              };\n            }\n\n            result.rebuild = rebuild;\n          }\n\n          if (response.watch) {\n            if (!stop) {\n              let isStopped = false;\n              refs.ref();\n\n              stop = () => {\n                if (isStopped) return;\n                isStopped = true;\n                watchCallbacks.delete(key);\n                sendRequest(refs, {\n                  command: \"watch-stop\",\n                  key\n                }, () => {});\n                refs.unref();\n              };\n\n              if (watch) {\n                watchCallbacks.set(key, (serviceStopError, watchResponse) => {\n                  if (serviceStopError) {\n                    if (watch.onRebuild) watch.onRebuild(serviceStopError, null);\n                    return;\n                  }\n\n                  let result2 = {\n                    errors: replaceDetailsInMessages(watchResponse.errors, details),\n                    warnings: replaceDetailsInMessages(watchResponse.warnings, details)\n                  };\n                  copyResponseToResult(watchResponse, result2);\n                  runOnEndCallbacks(result2, logPluginError, () => {\n                    if (result2.errors.length > 0) {\n                      if (watch.onRebuild) watch.onRebuild(failureErrorWithLog(\"Build failed\", result2.errors, result2.warnings), null);\n                      return;\n                    }\n\n                    if (watchResponse.rebuildID !== void 0) result2.rebuild = rebuild;\n                    result2.stop = stop;\n                    if (watch.onRebuild) watch.onRebuild(null, result2);\n                  });\n                });\n              }\n            }\n\n            result.stop = stop;\n          }\n\n          callback2(null, result);\n        });\n      };\n\n      if (write && streamIn.isBrowser) throw new Error(`Cannot enable \"write\" in the browser`);\n      if (incremental && streamIn.isSync) throw new Error(`Cannot use \"incremental\" with a synchronous build`);\n      if (watch && streamIn.isSync) throw new Error(`Cannot use \"watch\" with a synchronous build`);\n      sendRequest(refs, request, (error, response) => {\n        if (error) return callback(new Error(error), null);\n\n        if (serve2) {\n          let serveResponse = response;\n          let isStopped = false;\n          refs.ref();\n          let result = {\n            port: serveResponse.port,\n            host: serveResponse.host,\n            wait: serve2.wait,\n\n            stop() {\n              if (isStopped) return;\n              isStopped = true;\n              serve2.stop();\n              refs.unref();\n            }\n\n          };\n          refs.ref();\n          serve2.wait.then(refs.unref, refs.unref);\n          return callback(null, result);\n        }\n\n        return buildResponseToResult(response, callback);\n      });\n    };\n\n    let transform2 = ({\n      callName,\n      refs,\n      input,\n      options,\n      isTTY,\n      fs,\n      callback\n    }) => {\n      const details = createObjectStash();\n\n      let start = inputPath => {\n        try {\n          if (typeof input !== \"string\") throw new Error('The input to \"transform\" must be a string');\n          let {\n            flags,\n            mangleCache\n          } = flagsForTransformOptions(callName, options, isTTY, transformLogLevelDefault);\n          let request = {\n            command: \"transform\",\n            flags,\n            inputFS: inputPath !== null,\n            input: inputPath !== null ? inputPath : input\n          };\n          if (mangleCache) request.mangleCache = mangleCache;\n          sendRequest(refs, request, (error, response) => {\n            if (error) return callback(new Error(error), null);\n            let errors = replaceDetailsInMessages(response.errors, details);\n            let warnings = replaceDetailsInMessages(response.warnings, details);\n            let outstanding = 1;\n\n            let next = () => {\n              if (--outstanding === 0) {\n                let result = {\n                  warnings,\n                  code: response.code,\n                  map: response.map\n                };\n                if (response.mangleCache) result.mangleCache = response == null ? void 0 : response.mangleCache;\n                callback(null, result);\n              }\n            };\n\n            if (errors.length > 0) return callback(failureErrorWithLog(\"Transform failed\", errors, warnings), null);\n\n            if (response.codeFS) {\n              outstanding++;\n              fs.readFile(response.code, (err, contents) => {\n                if (err !== null) {\n                  callback(err, null);\n                } else {\n                  response.code = contents;\n                  next();\n                }\n              });\n            }\n\n            if (response.mapFS) {\n              outstanding++;\n              fs.readFile(response.map, (err, contents) => {\n                if (err !== null) {\n                  callback(err, null);\n                } else {\n                  response.map = contents;\n                  next();\n                }\n              });\n            }\n\n            next();\n          });\n        } catch (e) {\n          let flags = [];\n\n          try {\n            pushLogFlags(flags, options, {}, isTTY, transformLogLevelDefault);\n          } catch (e2) {}\n\n          const error = extractErrorMessageV8(e, streamIn, details, void 0, \"\");\n          sendRequest(refs, {\n            command: \"error\",\n            flags,\n            error\n          }, () => {\n            error.detail = details.load(error.detail);\n            callback(failureErrorWithLog(\"Transform failed\", [error], []), null);\n          });\n        }\n      };\n\n      if (typeof input === \"string\" && input.length > 1024 * 1024) {\n        let next = start;\n\n        start = () => fs.writeFile(input, next);\n      }\n\n      start(null);\n    };\n\n    let formatMessages2 = ({\n      callName,\n      refs,\n      messages,\n      options,\n      callback\n    }) => {\n      let result = sanitizeMessages(messages, \"messages\", null, \"\");\n      if (!options) throw new Error(`Missing second argument in ${callName}() call`);\n      let keys = {};\n      let kind = getFlag(options, keys, \"kind\", mustBeString);\n      let color = getFlag(options, keys, \"color\", mustBeBoolean);\n      let terminalWidth = getFlag(options, keys, \"terminalWidth\", mustBeInteger);\n      checkForInvalidFlags(options, keys, `in ${callName}() call`);\n      if (kind === void 0) throw new Error(`Missing \"kind\" in ${callName}() call`);\n      if (kind !== \"error\" && kind !== \"warning\") throw new Error(`Expected \"kind\" to be \"error\" or \"warning\" in ${callName}() call`);\n      let request = {\n        command: \"format-msgs\",\n        messages: result,\n        isWarning: kind === \"warning\"\n      };\n      if (color !== void 0) request.color = color;\n      if (terminalWidth !== void 0) request.terminalWidth = terminalWidth;\n      sendRequest(refs, request, (error, response) => {\n        if (error) return callback(new Error(error), null);\n        callback(null, response.messages);\n      });\n    };\n\n    let analyzeMetafile2 = ({\n      callName,\n      refs,\n      metafile,\n      options,\n      callback\n    }) => {\n      if (options === void 0) options = {};\n      let keys = {};\n      let color = getFlag(options, keys, \"color\", mustBeBoolean);\n      let verbose = getFlag(options, keys, \"verbose\", mustBeBoolean);\n      checkForInvalidFlags(options, keys, `in ${callName}() call`);\n      let request = {\n        command: \"analyze-metafile\",\n        metafile\n      };\n      if (color !== void 0) request.color = color;\n      if (verbose !== void 0) request.verbose = verbose;\n      sendRequest(refs, request, (error, response) => {\n        if (error) return callback(new Error(error), null);\n        callback(null, response.result);\n      });\n    };\n\n    return {\n      readFromStdout,\n      afterClose,\n      service: {\n        buildOrServe,\n        transform: transform2,\n        formatMessages: formatMessages2,\n        analyzeMetafile: analyzeMetafile2\n      }\n    };\n  }\n\n  function createObjectStash() {\n    const map = /* @__PURE__ */new Map();\n    let nextID = 0;\n    return {\n      load(id) {\n        return map.get(id);\n      },\n\n      store(value) {\n        if (value === void 0) return -1;\n        const id = nextID++;\n        map.set(id, value);\n        return id;\n      }\n\n    };\n  }\n\n  function extractCallerV8(e, streamIn, ident) {\n    let note;\n    let tried = false;\n    return () => {\n      if (tried) return note;\n      tried = true;\n\n      try {\n        let lines = (e.stack + \"\").split(\"\\n\");\n        lines.splice(1, 1);\n        let location = parseStackLinesV8(streamIn, lines, ident);\n\n        if (location) {\n          note = {\n            text: e.message,\n            location\n          };\n          return note;\n        }\n      } catch (e2) {}\n    };\n  }\n\n  function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {\n    let text = \"Internal error\";\n    let location = null;\n\n    try {\n      text = (e && e.message || e) + \"\";\n    } catch (e2) {}\n\n    try {\n      location = parseStackLinesV8(streamIn, (e.stack + \"\").split(\"\\n\"), \"\");\n    } catch (e2) {}\n\n    return {\n      pluginName,\n      text,\n      location,\n      notes: note ? [note] : [],\n      detail: stash ? stash.store(e) : -1\n    };\n  }\n\n  function parseStackLinesV8(streamIn, lines, ident) {\n    let at = \"    at \";\n\n    if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {\n      for (let i = 1; i < lines.length; i++) {\n        let line = lines[i];\n        if (!line.startsWith(at)) continue;\n        line = line.slice(at.length);\n\n        while (true) {\n          let match = /^(?:new |async )?\\S+ \\((.*)\\)$/.exec(line);\n\n          if (match) {\n            line = match[1];\n            continue;\n          }\n\n          match = /^eval at \\S+ \\((.*)\\)(?:, \\S+:\\d+:\\d+)?$/.exec(line);\n\n          if (match) {\n            line = match[1];\n            continue;\n          }\n\n          match = /^(\\S+):(\\d+):(\\d+)$/.exec(line);\n\n          if (match) {\n            let contents;\n\n            try {\n              contents = streamIn.readFileSync(match[1], \"utf8\");\n            } catch (e) {\n              break;\n            }\n\n            let lineText = contents.split(/\\r\\n|\\r|\\n|\\u2028|\\u2029/)[+match[2] - 1] || \"\";\n            let column = +match[3] - 1;\n            let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;\n            return {\n              file: match[1],\n              namespace: \"file\",\n              line: +match[2],\n              column: encodeUTF8(lineText.slice(0, column)).length,\n              length: encodeUTF8(lineText.slice(column, column + length)).length,\n              lineText: lineText + \"\\n\" + lines.slice(1).join(\"\\n\"),\n              suggestion: \"\"\n            };\n          }\n\n          break;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  function failureErrorWithLog(text, errors, warnings) {\n    let limit = 5;\n    let summary = errors.length < 1 ? \"\" : ` with ${errors.length} error${errors.length < 2 ? \"\" : \"s\"}:` + errors.slice(0, limit + 1).map((e, i) => {\n      if (i === limit) return \"\\n...\";\n      if (!e.location) return `\nerror: ${e.text}`;\n      let {\n        file,\n        line,\n        column\n      } = e.location;\n      let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : \"\";\n      return `\n${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;\n    }).join(\"\");\n    let error = new Error(`${text}${summary}`);\n    error.errors = errors;\n    error.warnings = warnings;\n    return error;\n  }\n\n  function replaceDetailsInMessages(messages, stash) {\n    for (const message of messages) {\n      message.detail = stash.load(message.detail);\n    }\n\n    return messages;\n  }\n\n  function sanitizeLocation(location, where) {\n    if (location == null) return null;\n    let keys = {};\n    let file = getFlag(location, keys, \"file\", mustBeString);\n    let namespace = getFlag(location, keys, \"namespace\", mustBeString);\n    let line = getFlag(location, keys, \"line\", mustBeInteger);\n    let column = getFlag(location, keys, \"column\", mustBeInteger);\n    let length = getFlag(location, keys, \"length\", mustBeInteger);\n    let lineText = getFlag(location, keys, \"lineText\", mustBeString);\n    let suggestion = getFlag(location, keys, \"suggestion\", mustBeString);\n    checkForInvalidFlags(location, keys, where);\n    return {\n      file: file || \"\",\n      namespace: namespace || \"\",\n      line: line || 0,\n      column: column || 0,\n      length: length || 0,\n      lineText: lineText || \"\",\n      suggestion: suggestion || \"\"\n    };\n  }\n\n  function sanitizeMessages(messages, property, stash, fallbackPluginName) {\n    let messagesClone = [];\n    let index = 0;\n\n    for (const message of messages) {\n      let keys = {};\n      let pluginName = getFlag(message, keys, \"pluginName\", mustBeString);\n      let text = getFlag(message, keys, \"text\", mustBeString);\n      let location = getFlag(message, keys, \"location\", mustBeObjectOrNull);\n      let notes = getFlag(message, keys, \"notes\", mustBeArray);\n      let detail = getFlag(message, keys, \"detail\", canBeAnything);\n      let where = `in element ${index} of \"${property}\"`;\n      checkForInvalidFlags(message, keys, where);\n      let notesClone = [];\n\n      if (notes) {\n        for (const note of notes) {\n          let noteKeys = {};\n          let noteText = getFlag(note, noteKeys, \"text\", mustBeString);\n          let noteLocation = getFlag(note, noteKeys, \"location\", mustBeObjectOrNull);\n          checkForInvalidFlags(note, noteKeys, where);\n          notesClone.push({\n            text: noteText || \"\",\n            location: sanitizeLocation(noteLocation, where)\n          });\n        }\n      }\n\n      messagesClone.push({\n        pluginName: pluginName || fallbackPluginName,\n        text: text || \"\",\n        location: sanitizeLocation(location, where),\n        notes: notesClone,\n        detail: stash ? stash.store(detail) : -1\n      });\n      index++;\n    }\n\n    return messagesClone;\n  }\n\n  function sanitizeStringArray(values, property) {\n    const result = [];\n\n    for (const value of values) {\n      if (typeof value !== \"string\") throw new Error(`${JSON.stringify(property)} must be an array of strings`);\n      result.push(value);\n    }\n\n    return result;\n  }\n\n  function convertOutputFiles({\n    path,\n    contents\n  }) {\n    let text = null;\n    return {\n      path,\n      contents,\n\n      get text() {\n        if (text === null) text = decodeUTF8(contents);\n        return text;\n      }\n\n    };\n  } // lib/npm/browser.ts\n\n\n  var version = \"0.14.22\";\n\n  var build = options => ensureServiceIsRunning().build(options);\n\n  var serve = () => {\n    throw new Error(`The \"serve\" API only works in node`);\n  };\n\n  var transform = (input, options) => ensureServiceIsRunning().transform(input, options);\n\n  var formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);\n\n  var analyzeMetafile = (metafile, options) => ensureServiceIsRunning().analyzeMetafile(metafile, options);\n\n  var buildSync = () => {\n    throw new Error(`The \"buildSync\" API only works in node`);\n  };\n\n  var transformSync = () => {\n    throw new Error(`The \"transformSync\" API only works in node`);\n  };\n\n  var formatMessagesSync = () => {\n    throw new Error(`The \"formatMessagesSync\" API only works in node`);\n  };\n\n  var analyzeMetafileSync = () => {\n    throw new Error(`The \"analyzeMetafileSync\" API only works in node`);\n  };\n\n  var initializePromise;\n  var longLivedService;\n\n  var ensureServiceIsRunning = () => {\n    if (longLivedService) return longLivedService;\n    if (initializePromise) throw new Error('You need to wait for the promise returned from \"initialize\" to be resolved before calling this');\n    throw new Error('You need to call \"initialize\" before calling this');\n  };\n\n  var initialize = options => {\n    options = validateInitializeOptions(options || {});\n    let wasmURL = options.wasmURL;\n    let useWorker = options.worker !== false;\n    if (!wasmURL) throw new Error('Must provide the \"wasmURL\" option');\n    wasmURL += \"\";\n    if (initializePromise) throw new Error('Cannot call \"initialize\" more than once');\n    initializePromise = startRunningService(wasmURL, useWorker);\n    initializePromise.catch(() => {\n      initializePromise = void 0;\n    });\n    return initializePromise;\n  };\n\n  var startRunningService = (wasmURL, useWorker) => __async(void 0, null, function* () {\n    let res = yield fetch(wasmURL);\n    if (!res.ok) throw new Error(`Failed to download ${JSON.stringify(wasmURL)}`);\n    let wasm = yield res.arrayBuffer();\n    let code = `{let global={};for(let o=self;o;o=Object.getPrototypeOf(o))for(let k of Object.getOwnPropertyNames(o))if(!(k in global))Object.defineProperty(global,k,{get:()=>self[k]});// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n(() => {\n\t// Map multiple JavaScript environments to a single common API,\n\t// preferring web standards over Node.js API.\n\t//\n\t// Environments considered:\n\t// - Browsers\n\t// - Node.js\n\t// - Electron\n\t// - Parcel\n\t// - Webpack\n\n\tif (typeof global !== \"undefined\") {\n\t\t// global already exists\n\t} else if (typeof window !== \"undefined\") {\n\t\twindow.global = window;\n\t} else if (typeof self !== \"undefined\") {\n\t\tself.global = self;\n\t} else {\n\t\tthrow new Error(\"cannot export Go (neither global, window nor self is defined)\");\n\t}\n\n\tif (!global.require && typeof require !== \"undefined\") {\n\t\tglobal.require = require;\n\t}\n\n\tif (!global.fs && global.require) {\n\t\tconst fs = require(\"fs\");\n\t\tif (typeof fs === \"object\" && fs !== null && Object.keys(fs).length !== 0) {\n\t\t\t\n    global.fs = Object.assign({}, fs, {\n      // Hack around a Unicode bug in node: https://github.com/nodejs/node/issues/24550\n      write(fd, buf, offset, length, position, callback) {\n        if (offset === 0 && length === buf.length && position === null) {\n          if (fd === process.stdout.fd) {\n            try {\n              process.stdout.write(buf, err => err ? callback(err, 0, null) : callback(null, length, buf));\n            } catch (err) {\n              callback(err, 0, null);\n            }\n            return;\n          }\n          if (fd === process.stderr.fd) {\n            try {\n              process.stderr.write(buf, err => err ? callback(err, 0, null) : callback(null, length, buf));\n            } catch (err) {\n              callback(err, 0, null);\n            }\n            return;\n          }\n        }\n        fs.write(fd, buf, offset, length, position, callback);\n      },\n    });\n  \n\t\t}\n\t}\n\n\tconst enosys = () => {\n\t\tconst err = new Error(\"not implemented\");\n\t\terr.code = \"ENOSYS\";\n\t\treturn err;\n\t};\n\n\tif (!global.fs) {\n\t\tlet outputBuf = \"\";\n\t\tglobal.fs = {\n\t\t\tconstants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 }, // unused\n\t\t\twriteSync(fd, buf) {\n\t\t\t\toutputBuf += decoder.decode(buf);\n\t\t\t\tconst nl = outputBuf.lastIndexOf(\"\\\\n\");\n\t\t\t\tif (nl != -1) {\n\t\t\t\t\tconsole.log(outputBuf.substr(0, nl));\n\t\t\t\t\toutputBuf = outputBuf.substr(nl + 1);\n\t\t\t\t}\n\t\t\t\treturn buf.length;\n\t\t\t},\n\t\t\twrite(fd, buf, offset, length, position, callback) {\n\t\t\t\tif (offset !== 0 || length !== buf.length || position !== null) {\n\t\t\t\t\tcallback(enosys());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst n = this.writeSync(fd, buf);\n\t\t\t\tcallback(null, n);\n\t\t\t},\n\t\t\tchmod(path, mode, callback) { callback(enosys()); },\n\t\t\tchown(path, uid, gid, callback) { callback(enosys()); },\n\t\t\tclose(fd, callback) { callback(enosys()); },\n\t\t\tfchmod(fd, mode, callback) { callback(enosys()); },\n\t\t\tfchown(fd, uid, gid, callback) { callback(enosys()); },\n\t\t\tfstat(fd, callback) { callback(enosys()); },\n\t\t\tfsync(fd, callback) { callback(null); },\n\t\t\tftruncate(fd, length, callback) { callback(enosys()); },\n\t\t\tlchown(path, uid, gid, callback) { callback(enosys()); },\n\t\t\tlink(path, link, callback) { callback(enosys()); },\n\t\t\tlstat(path, callback) { callback(enosys()); },\n\t\t\tmkdir(path, perm, callback) { callback(enosys()); },\n\t\t\topen(path, flags, mode, callback) { callback(enosys()); },\n\t\t\tread(fd, buffer, offset, length, position, callback) { callback(enosys()); },\n\t\t\treaddir(path, callback) { callback(enosys()); },\n\t\t\treadlink(path, callback) { callback(enosys()); },\n\t\t\trename(from, to, callback) { callback(enosys()); },\n\t\t\trmdir(path, callback) { callback(enosys()); },\n\t\t\tstat(path, callback) { callback(enosys()); },\n\t\t\tsymlink(path, link, callback) { callback(enosys()); },\n\t\t\ttruncate(path, length, callback) { callback(enosys()); },\n\t\t\tunlink(path, callback) { callback(enosys()); },\n\t\t\tutimes(path, atime, mtime, callback) { callback(enosys()); },\n\t\t};\n\t}\n\n\tif (!global.process) {\n\t\tglobal.process = {\n\t\t\tgetuid() { return -1; },\n\t\t\tgetgid() { return -1; },\n\t\t\tgeteuid() { return -1; },\n\t\t\tgetegid() { return -1; },\n\t\t\tgetgroups() { throw enosys(); },\n\t\t\tpid: -1,\n\t\t\tppid: -1,\n\t\t\tumask() { throw enosys(); },\n\t\t\tcwd() { throw enosys(); },\n\t\t\tchdir() { throw enosys(); },\n\t\t}\n\t}\n\n\tif (!global.crypto && global.require) {\n\t\tconst nodeCrypto = require(\"crypto\");\n\t\tglobal.crypto = {\n\t\t\tgetRandomValues(b) {\n\t\t\t\tnodeCrypto.randomFillSync(b);\n\t\t\t},\n\t\t};\n\t}\n\tif (!global.crypto) {\n\t\tthrow new Error(\"global.crypto is not available, polyfill required (getRandomValues only)\");\n\t}\n\n\tif (!global.performance) {\n\t\tglobal.performance = {\n\t\t\tnow() {\n\t\t\t\tconst [sec, nsec] = process.hrtime();\n\t\t\t\treturn sec * 1000 + nsec / 1000000;\n\t\t\t},\n\t\t};\n\t}\n\n\tif (!global.TextEncoder && global.require) {\n\t\tglobal.TextEncoder = require(\"util\").TextEncoder;\n\t}\n\tif (!global.TextEncoder) {\n\t\tthrow new Error(\"global.TextEncoder is not available, polyfill required\");\n\t}\n\n\tif (!global.TextDecoder && global.require) {\n\t\tglobal.TextDecoder = require(\"util\").TextDecoder;\n\t}\n\tif (!global.TextDecoder) {\n\t\tthrow new Error(\"global.TextDecoder is not available, polyfill required\");\n\t}\n\n\t\n    // Make sure Go sees the shadowed \"fs\" global\n    const { fs } = global;\n  \n\n\tconst encoder = new TextEncoder(\"utf-8\");\n\tconst decoder = new TextDecoder(\"utf-8\");\n\n\tglobal.Go = class {\n\t\tconstructor() {\n\t\t\tthis.argv = [\"js\"];\n\t\t\tthis.env = {};\n\t\t\tthis.exit = (code) => {\n\t\t\t\tif (code !== 0) {\n\t\t\t\t\tconsole.warn(\"exit code:\", code);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._exitPromise = new Promise((resolve) => {\n\t\t\t\tthis._resolveExitPromise = resolve;\n\t\t\t});\n\t\t\tthis._pendingEvent = null;\n\t\t\tthis._scheduledTimeouts = new Map();\n\t\t\tthis._nextCallbackTimeoutID = 1;\n\n\t\t\tconst setInt64 = (addr, v) => {\n\t\t\t\tthis.mem.setUint32(addr + 0, v, true);\n\t\t\t\tthis.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n\t\t\t}\n\n\t\t\tconst getInt64 = (addr) => {\n\t\t\t\tconst low = this.mem.getUint32(addr + 0, true);\n\t\t\t\tconst high = this.mem.getInt32(addr + 4, true);\n\t\t\t\treturn low + high * 4294967296;\n\t\t\t}\n\n\t\t\tconst loadValue = (addr) => {\n\t\t\t\tconst f = this.mem.getFloat64(addr, true);\n\t\t\t\tif (f === 0) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (!isNaN(f)) {\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\n\t\t\t\tconst id = this.mem.getUint32(addr, true);\n\t\t\t\treturn this._values[id];\n\t\t\t}\n\n\t\t\tconst storeValue = (addr, v) => {\n\t\t\t\tconst nanHead = 0x7FF80000;\n\n\t\t\t\tif (typeof v === \"number\" && v !== 0) {\n\t\t\t\t\tif (isNaN(v)) {\n\t\t\t\t\t\tthis.mem.setUint32(addr + 4, nanHead, true);\n\t\t\t\t\t\tthis.mem.setUint32(addr, 0, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.mem.setFloat64(addr, v, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (v === undefined) {\n\t\t\t\t\tthis.mem.setFloat64(addr, 0, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet id = this._ids.get(v);\n\t\t\t\tif (id === undefined) {\n\t\t\t\t\tid = this._idPool.pop();\n\t\t\t\t\tif (id === undefined) {\n\t\t\t\t\t\tid = this._values.length;\n\t\t\t\t\t}\n\t\t\t\t\tthis._values[id] = v;\n\t\t\t\t\tthis._goRefCounts[id] = 0;\n\t\t\t\t\tthis._ids.set(v, id);\n\t\t\t\t}\n\t\t\t\tthis._goRefCounts[id]++;\n\t\t\t\tlet typeFlag = 0;\n\t\t\t\tswitch (typeof v) {\n\t\t\t\t\tcase \"object\":\n\t\t\t\t\t\tif (v !== null) {\n\t\t\t\t\t\t\ttypeFlag = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\ttypeFlag = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"symbol\":\n\t\t\t\t\t\ttypeFlag = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\ttypeFlag = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n\t\t\t\tthis.mem.setUint32(addr, id, true);\n\t\t\t}\n\n\t\t\tconst loadSlice = (addr) => {\n\t\t\t\tconst array = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\treturn new Uint8Array(this._inst.exports.mem.buffer, array, len);\n\t\t\t}\n\n\t\t\tconst loadSliceOfValues = (addr) => {\n\t\t\t\tconst array = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\tconst a = new Array(len);\n\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\ta[i] = loadValue(array + i * 8);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tconst loadString = (addr) => {\n\t\t\t\tconst saddr = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\treturn decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n\t\t\t}\n\n\t\t\tconst timeOrigin = Date.now() - performance.now();\n\t\t\tthis.importObject = {\n\t\t\t\tgo: {\n\t\t\t\t\t// Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n\t\t\t\t\t// may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n\t\t\t\t\t// function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n\t\t\t\t\t// This changes the SP, thus we have to update the SP used by the imported function.\n\n\t\t\t\t\t// func wasmExit(code int32)\n\t\t\t\t\t\"runtime.wasmExit\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst code = this.mem.getInt32(sp + 8, true);\n\t\t\t\t\t\tthis.exited = true;\n\t\t\t\t\t\tdelete this._inst;\n\t\t\t\t\t\tdelete this._values;\n\t\t\t\t\t\tdelete this._goRefCounts;\n\t\t\t\t\t\tdelete this._ids;\n\t\t\t\t\t\tdelete this._idPool;\n\t\t\t\t\t\tthis.exit(code);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n\t\t\t\t\t\"runtime.wasmWrite\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst fd = getInt64(sp + 8);\n\t\t\t\t\t\tconst p = getInt64(sp + 16);\n\t\t\t\t\t\tconst n = this.mem.getInt32(sp + 24, true);\n\t\t\t\t\t\tfs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func resetMemoryDataView()\n\t\t\t\t\t\"runtime.resetMemoryDataView\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tthis.mem = new DataView(this._inst.exports.mem.buffer);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func nanotime1() int64\n\t\t\t\t\t\"runtime.nanotime1\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tsetInt64(sp + 8, (timeOrigin + performance.now()) * 1000000);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func walltime() (sec int64, nsec int32)\n\t\t\t\t\t\"runtime.walltime\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst msec = (new Date).getTime();\n\t\t\t\t\t\tsetInt64(sp + 8, msec / 1000);\n\t\t\t\t\t\tthis.mem.setInt32(sp + 16, (msec % 1000) * 1000000, true);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func scheduleTimeoutEvent(delay int64) int32\n\t\t\t\t\t\"runtime.scheduleTimeoutEvent\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this._nextCallbackTimeoutID;\n\t\t\t\t\t\tthis._nextCallbackTimeoutID++;\n\t\t\t\t\t\tthis._scheduledTimeouts.set(id, setTimeout(\n\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\tthis._resume();\n\t\t\t\t\t\t\t\twhile (this._scheduledTimeouts.has(id)) {\n\t\t\t\t\t\t\t\t\t// for some reason Go failed to register the timeout event, log and try again\n\t\t\t\t\t\t\t\t\t// (temporary workaround for https://github.com/golang/go/issues/28975)\n\t\t\t\t\t\t\t\t\tconsole.warn(\"scheduleTimeoutEvent: missed timeout event\");\n\t\t\t\t\t\t\t\t\tthis._resume();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetInt64(sp + 8) + 1, // setTimeout has been seen to fire up to 1 millisecond early\n\t\t\t\t\t\t));\n\t\t\t\t\t\tthis.mem.setInt32(sp + 16, id, true);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func clearTimeoutEvent(id int32)\n\t\t\t\t\t\"runtime.clearTimeoutEvent\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this.mem.getInt32(sp + 8, true);\n\t\t\t\t\t\tclearTimeout(this._scheduledTimeouts.get(id));\n\t\t\t\t\t\tthis._scheduledTimeouts.delete(id);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func getRandomData(r []byte)\n\t\t\t\t\t\"runtime.getRandomData\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tcrypto.getRandomValues(loadSlice(sp + 8));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func finalizeRef(v ref)\n\t\t\t\t\t\"syscall/js.finalizeRef\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this.mem.getUint32(sp + 8, true);\n\t\t\t\t\t\tthis._goRefCounts[id]--;\n\t\t\t\t\t\tif (this._goRefCounts[id] === 0) {\n\t\t\t\t\t\t\tconst v = this._values[id];\n\t\t\t\t\t\t\tthis._values[id] = null;\n\t\t\t\t\t\t\tthis._ids.delete(v);\n\t\t\t\t\t\t\tthis._idPool.push(id);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func stringVal(value string) ref\n\t\t\t\t\t\"syscall/js.stringVal\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tstoreValue(sp + 24, loadString(sp + 8));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueGet(v ref, p string) ref\n\t\t\t\t\t\"syscall/js.valueGet\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\tstoreValue(sp + 32, result);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueSet(v ref, p string, x ref)\n\t\t\t\t\t\"syscall/js.valueSet\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueDelete(v ref, p string)\n\t\t\t\t\t\"syscall/js.valueDelete\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueIndex(v ref, i int) ref\n\t\t\t\t\t\"syscall/js.valueIndex\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tstoreValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueSetIndex(v ref, i int, x ref)\n\t\t\t\t\t\"syscall/js.valueSetIndex\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueCall(v ref, m string, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueCall\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst m = Reflect.get(v, loadString(sp + 16));\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 32);\n\t\t\t\t\t\t\tconst result = Reflect.apply(m, v, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 56, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 64, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 56, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 64, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInvoke(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueInvoke\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 16);\n\t\t\t\t\t\t\tconst result = Reflect.apply(v, undefined, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueNew(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueNew\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 16);\n\t\t\t\t\t\t\tconst result = Reflect.construct(v, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueLength(v ref) int\n\t\t\t\t\t\"syscall/js.valueLength\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tsetInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n\t\t\t\t\t},\n\n\t\t\t\t\t// valuePrepareString(v ref) (ref, int)\n\t\t\t\t\t\"syscall/js.valuePrepareString\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst str = encoder.encode(String(loadValue(sp + 8)));\n\t\t\t\t\t\tstoreValue(sp + 16, str);\n\t\t\t\t\t\tsetInt64(sp + 24, str.length);\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueLoadString(v ref, b []byte)\n\t\t\t\t\t\"syscall/js.valueLoadString\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst str = loadValue(sp + 8);\n\t\t\t\t\t\tloadSlice(sp + 16).set(str);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInstanceOf(v ref, t ref) bool\n\t\t\t\t\t\"syscall/js.valueInstanceOf\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tthis.mem.setUint8(sp + 24, (loadValue(sp + 8) instanceof loadValue(sp + 16)) ? 1 : 0);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func copyBytesToGo(dst []byte, src ref) (int, bool)\n\t\t\t\t\t\"syscall/js.copyBytesToGo\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst dst = loadSlice(sp + 8);\n\t\t\t\t\t\tconst src = loadValue(sp + 32);\n\t\t\t\t\t\tif (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst toCopy = src.subarray(0, dst.length);\n\t\t\t\t\t\tdst.set(toCopy);\n\t\t\t\t\t\tsetInt64(sp + 40, toCopy.length);\n\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func copyBytesToJS(dst ref, src []byte) (int, bool)\n\t\t\t\t\t\"syscall/js.copyBytesToJS\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst dst = loadValue(sp + 8);\n\t\t\t\t\t\tconst src = loadSlice(sp + 16);\n\t\t\t\t\t\tif (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst toCopy = src.subarray(0, dst.length);\n\t\t\t\t\t\tdst.set(toCopy);\n\t\t\t\t\t\tsetInt64(sp + 40, toCopy.length);\n\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t},\n\n\t\t\t\t\t\"debug\": (value) => {\n\t\t\t\t\t\tconsole.log(value);\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tasync run(instance) {\n\t\t\tif (!(instance instanceof WebAssembly.Instance)) {\n\t\t\t\tthrow new Error(\"Go.run: WebAssembly.Instance expected\");\n\t\t\t}\n\t\t\tthis._inst = instance;\n\t\t\tthis.mem = new DataView(this._inst.exports.mem.buffer);\n\t\t\tthis._values = [ // JS values that Go currently has references to, indexed by reference id\n\t\t\t\tNaN,\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t\tglobal,\n\t\t\t\tthis,\n\t\t\t];\n\t\t\tthis._goRefCounts = new Array(this._values.length).fill(Infinity); // number of references that Go has to a JS value, indexed by reference id\n\t\t\tthis._ids = new Map([ // mapping from JS values to reference ids\n\t\t\t\t[0, 1],\n\t\t\t\t[null, 2],\n\t\t\t\t[true, 3],\n\t\t\t\t[false, 4],\n\t\t\t\t[global, 5],\n\t\t\t\t[this, 6],\n\t\t\t]);\n\t\t\tthis._idPool = [];   // unused ids that have been garbage collected\n\t\t\tthis.exited = false; // whether the Go program has exited\n\n\t\t\t// Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n\t\t\tlet offset = 4096;\n\n\t\t\tconst strPtr = (str) => {\n\t\t\t\tconst ptr = offset;\n\t\t\t\tconst bytes = encoder.encode(str + \"\\\\0\");\n\t\t\t\tnew Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n\t\t\t\toffset += bytes.length;\n\t\t\t\tif (offset % 8 !== 0) {\n\t\t\t\t\toffset += 8 - (offset % 8);\n\t\t\t\t}\n\t\t\t\treturn ptr;\n\t\t\t};\n\n\t\t\tconst argc = this.argv.length;\n\n\t\t\tconst argvPtrs = [];\n\t\t\tthis.argv.forEach((arg) => {\n\t\t\t\targvPtrs.push(strPtr(arg));\n\t\t\t});\n\t\t\targvPtrs.push(0);\n\n\t\t\tconst keys = Object.keys(this.env).sort();\n\t\t\tkeys.forEach((key) => {\n\t\t\t\targvPtrs.push(strPtr(\\`\\${key}=\\${this.env[key]}\\`));\n\t\t\t});\n\t\t\targvPtrs.push(0);\n\n\t\t\tconst argv = offset;\n\t\t\targvPtrs.forEach((ptr) => {\n\t\t\t\tthis.mem.setUint32(offset, ptr, true);\n\t\t\t\tthis.mem.setUint32(offset + 4, 0, true);\n\t\t\t\toffset += 8;\n\t\t\t});\n\n\t\t\t// The linker guarantees global data starts from at least wasmMinDataAddr.\n\t\t\t// Keep in sync with cmd/link/internal/ld/data.go:wasmMinDataAddr.\n\t\t\tconst wasmMinDataAddr = 4096 + 8192;\n\t\t\tif (offset >= wasmMinDataAddr) {\n\t\t\t\tthrow new Error(\"total length of command line and environment variables exceeds limit\");\n\t\t\t}\n\n\t\t\tthis._inst.exports.run(argc, argv);\n\t\t\tif (this.exited) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t\tawait this._exitPromise;\n\t\t}\n\n\t\t_resume() {\n\t\t\tif (this.exited) {\n\t\t\t\tthrow new Error(\"Go program has already exited\");\n\t\t\t}\n\t\t\tthis._inst.exports.resume();\n\t\t\tif (this.exited) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t}\n\n\t\t_makeFuncWrapper(id) {\n\t\t\tconst go = this;\n\t\t\treturn function () {\n\t\t\t\tconst event = { id: id, this: this, args: arguments };\n\t\t\t\tgo._pendingEvent = event;\n\t\t\t\tgo._resume();\n\t\t\t\treturn event.result;\n\t\t\t};\n\t\t}\n\t}\n\n\tif (\n\t\ttypeof module !== \"undefined\" &&\n\t\tglobal.require &&\n\t\tglobal.require.main === module &&\n\t\tglobal.process &&\n\t\tglobal.process.versions &&\n\t\t!global.process.versions.electron\n\t) {\n\t\tif (process.argv.length < 3) {\n\t\t\tconsole.error(\"usage: go_js_wasm_exec [wasm binary] [arguments]\");\n\t\t\tprocess.exit(1);\n\t\t}\n\n\t\tconst go = new Go();\n\t\tgo.argv = process.argv.slice(2);\n\t\tgo.env = Object.assign({ TMPDIR: require(\"os\").tmpdir() }, process.env);\n\t\tgo.exit = process.exit;\n\t\tWebAssembly.instantiate(fs.readFileSync(process.argv[2]), go.importObject).then((result) => {\n\t\t\tprocess.on(\"exit\", (code) => { // Node.js exits if no event handler is pending\n\t\t\t\tif (code === 0 && !go.exited) {\n\t\t\t\t\t// deadlock, make Go print error and stack traces\n\t\t\t\t\tgo._pendingEvent = { id: 0 };\n\t\t\t\t\tgo._resume();\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn go.run(result.instance);\n\t\t}).catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tprocess.exit(1);\n\t\t});\n\t}\n})();\nonmessage = ({ data: wasm }) => {\n  let decoder = new TextDecoder();\n  let fs = global.fs;\n  let stderr = \"\";\n  fs.writeSync = (fd, buffer) => {\n    if (fd === 1) {\n      postMessage(buffer);\n    } else if (fd === 2) {\n      stderr += decoder.decode(buffer);\n      let parts = stderr.split(\"\\\\n\");\n      if (parts.length > 1)\n        console.log(parts.slice(0, -1).join(\"\\\\n\"));\n      stderr = parts[parts.length - 1];\n    } else {\n      throw new Error(\"Bad write\");\n    }\n    return buffer.length;\n  };\n  let stdin = [];\n  let resumeStdin;\n  let stdinPos = 0;\n  onmessage = ({ data }) => {\n    if (data.length > 0) {\n      stdin.push(data);\n      if (resumeStdin)\n        resumeStdin();\n    }\n  };\n  fs.read = (fd, buffer, offset, length, position, callback) => {\n    if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\n      throw new Error(\"Bad read\");\n    }\n    if (stdin.length === 0) {\n      resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\n      return;\n    }\n    let first = stdin[0];\n    let count = Math.max(0, Math.min(length, first.length - stdinPos));\n    buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n    stdinPos += count;\n    if (stdinPos === first.length) {\n      stdin.shift();\n      stdinPos = 0;\n    }\n    callback(null, count);\n  };\n  let go = new global.Go();\n  go.argv = [\"\", \\`--service=\\${\"0.14.22\"}\\`];\n  WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));\n};}`;\n    let worker;\n\n    if (useWorker) {\n      let blob = new Blob([code], {\n        type: \"text/javascript\"\n      });\n      worker = new Worker(URL.createObjectURL(blob));\n    } else {\n      let fn = new Function(\"postMessage\", code + `var onmessage; return m => onmessage(m)`);\n      let onmessage = fn(data => worker.onmessage({\n        data\n      }));\n      worker = {\n        onmessage: null,\n        postMessage: data => onmessage({\n          data\n        }),\n\n        terminate() {}\n\n      };\n    }\n\n    worker.postMessage(wasm);\n\n    worker.onmessage = ({\n      data\n    }) => readFromStdout(data);\n\n    let {\n      readFromStdout,\n      service\n    } = createChannel({\n      writeToStdin(bytes) {\n        worker.postMessage(bytes);\n      },\n\n      isSync: false,\n      isBrowser: true,\n      esbuild: browser_exports\n    });\n    longLivedService = {\n      build: options => new Promise((resolve, reject) => service.buildOrServe({\n        callName: \"build\",\n        refs: null,\n        serveOptions: null,\n        options,\n        isTTY: false,\n        defaultWD: \"/\",\n        callback: (err, res2) => err ? reject(err) : resolve(res2)\n      })),\n      transform: (input, options) => new Promise((resolve, reject) => service.transform({\n        callName: \"transform\",\n        refs: null,\n        input,\n        options: options || {},\n        isTTY: false,\n        fs: {\n          readFile(_, callback) {\n            callback(new Error(\"Internal error\"), null);\n          },\n\n          writeFile(_, callback) {\n            callback(null);\n          }\n\n        },\n        callback: (err, res2) => err ? reject(err) : resolve(res2)\n      })),\n      formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({\n        callName: \"formatMessages\",\n        refs: null,\n        messages,\n        options,\n        callback: (err, res2) => err ? reject(err) : resolve(res2)\n      })),\n      analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({\n        callName: \"analyzeMetafile\",\n        refs: null,\n        metafile: typeof metafile === \"string\" ? metafile : JSON.stringify(metafile),\n        options,\n        callback: (err, res2) => err ? reject(err) : resolve(res2)\n      }))\n    };\n  });\n\n  var browser_default = browser_exports;\n  module.exports = __toCommonJS(browser_exports);\n})(typeof module === \"object\" ? module : {\n  set exports(x) {\n    (typeof self !== \"undefined\" ? self : this).esbuild = x;\n  }\n\n});","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/esbuild-wasm/lib/browser.js"],"names":["module","__defProp","Object","defineProperty","__defProps","defineProperties","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropNames","getOwnPropertyNames","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","prototype","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","key","value","enumerable","configurable","writable","__spreadValues","a","b","prop","call","__spreadProps","__markAsModule","target","__export","all","name","get","__reExport","module2","copyDefault","desc","__toCommonJS","cache","temp","set","WeakMap","__async","__this","__arguments","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","throw","x","done","then","apply","browser_exports","analyzeMetafile","analyzeMetafileSync","build","buildSync","default","browser_default","formatMessages","formatMessagesSync","initialize","serve","transform","transformSync","version","encodePacket","packet","visit","bb","write8","write32","write","encodeUTF8","Uint8Array","Array","length","item","keys","ByteBuffer","id","isRequest","writeUInt32LE","buf","len","subarray","decodePacket","bytes","read8","read32","decodeUTF8","read","count","value2","i","push","Error","ptr","constructor","_write","delta","clone","offset","_read","readUInt32LE","TextEncoder","TextDecoder","encoder","decoder","text","encode","decode","Buffer","buffer","from","byteOffset","byteLength","toString","validateTarget","indexOf","canBeAnything","mustBeBoolean","mustBeBooleanOrObject","isArray","mustBeString","mustBeRegExp","RegExp","mustBeInteger","mustBeFunction","mustBeArray","mustBeObject","mustBeArrayOrRecord","mustBeObjectOrNull","mustBeStringOrBoolean","mustBeStringOrObject","mustBeStringOrArray","mustBeStringOrUint8Array","getFlag","object","mustBeFn","mustBe","checkForInvalidFlags","where","validateInitializeOptions","options","create","wasmURL","worker","validateMangleCache","mangleCache","validated","JSON","stringify","pushLogFlags","flags","isTTY","logLevelDefault","color","logLevel","logLimit","pushCommonFlags","legalComments","sourceRoot","sourcesContent","format","globalName","mangleProps","reserveProps","minify","minifySyntax","minifyWhitespace","minifyIdentifiers","drop","charset","treeShaking","ignoreAnnotations","jsx","jsxFactory","jsxFragment","define","pure","keepNames","map","join","what","source","fn","flagsForBuildOptions","callName","writeDefault","_a","entries","stdinContents","stdinResolveDir","watchMode","sourcemap","bundle","watch","splitting","preserveSymlinks","metafile","outfile","outdir","outbase","platform","tsconfig","resolveExtensions","nodePathsInput","mainFields","conditions","external","loader","outExtension","publicPath","entryNames","chunkNames","assetNames","inject","banner","footer","entryPoints","absWorkingDir","stdin","allowOverwrite","incremental","plugins","watchKeys","onRebuild","values","type","path","ext","entryPoint","stdinKeys","contents","resolveDir","sourcefile","loader2","nodePaths","flagsForTransformOptions","tsconfigRaw","createChannel","streamIn","responseCallbacks","Map","pluginCallbacks","watchCallbacks","serveCallbacks","isClosed","nextRequestID","nextBuildKey","stdout","stdoutUsed","readFromStdout","chunk","limit","swap","handleIncomingPacket","copyWithin","afterClose","callback","clear","callbacks","onWait","console","error","sendRequest","refs","response","unref","ref","writeToStdin","sendResponse","handleRequest","request","command","onRequest","args","err","errors","extractErrorMessageV8","isFirstPacket","binaryVersion","String","fromCharCode","delete","handlePlugins","initialOptions","buildKey","stash","onStartCallbacks","onEndCallbacks","onResolveCallbacks","onLoadCallbacks","nextCallbackID","requestPlugins","isSetupDone","setup","plugin","onResolve","onLoad","keys2","pluginName","importer","namespace","kind","pluginData","resolve2","store","replaceDetailsInMessages","warnings","sideEffects","suffix","load","promise","onStart","callback2","registeredText","registeredNote","extractCallerV8","note","onEnd","filter","esbuild","ok","_0","result","sanitizeMessages","ids","watchFiles","watchDirs","sanitizeStringArray","runOnEndCallbacks","logPluginError","refCount","pluginRefs","buildServeData","port","host","servedir","wait","stop","buildLogLevelDefault","transformLogLevelDefault","buildOrServe","details","createObjectStash","e2","message","detail","handleError","failureErrorWithLog","isSync","buildOrServeContinue","logPluginError2","callerRefs","serveOptions","defaultWD","isBrowser","serve2","rebuild","copyResponseToResult","outputFiles","convertOutputFiles","parse","writeToStdout","log","replace","buildResponseToResult","isDisposed","error2","response2","location","notes","error3","result3","dispose","isStopped","serviceStopError","watchResponse","result2","rebuildID","serveResponse","transform2","input","fs","start","inputPath","inputFS","outstanding","code","codeFS","readFile","mapFS","writeFile","formatMessages2","messages","terminalWidth","isWarning","analyzeMetafile2","verbose","service","nextID","ident","tried","lines","stack","split","splice","parseStackLinesV8","at","readFileSync","startsWith","line","slice","match","exec","lineText","column","file","suggestion","summary","pluginText","sanitizeLocation","property","fallbackPluginName","messagesClone","index","notesClone","noteKeys","noteText","noteLocation","ensureServiceIsRunning","initializePromise","longLivedService","useWorker","startRunningService","catch","res","fetch","wasm","arrayBuffer","blob","Blob","Worker","URL","createObjectURL","Function","onmessage","data","postMessage","terminate","res2","_","exports","self"],"mappings":"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GAAG,CAACG,WAAJ,EAAjB;AACA,QAAInD,IAAI,GAAI;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","sourcesContent":["(module=>{\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, copyDefault, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== \"default\"))\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toCommonJS = /* @__PURE__ */ ((cache) => {\n  return (module2, temp) => {\n    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);\n  };\n})(typeof WeakMap !== \"undefined\" ? /* @__PURE__ */ new WeakMap() : 0);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// lib/npm/browser.ts\nvar browser_exports = {};\n__export(browser_exports, {\n  analyzeMetafile: () => analyzeMetafile,\n  analyzeMetafileSync: () => analyzeMetafileSync,\n  build: () => build,\n  buildSync: () => buildSync,\n  default: () => browser_default,\n  formatMessages: () => formatMessages,\n  formatMessagesSync: () => formatMessagesSync,\n  initialize: () => initialize,\n  serve: () => serve,\n  transform: () => transform,\n  transformSync: () => transformSync,\n  version: () => version\n});\n\n// lib/shared/stdio_protocol.ts\nfunction encodePacket(packet) {\n  let visit = (value) => {\n    if (value === null) {\n      bb.write8(0);\n    } else if (typeof value === \"boolean\") {\n      bb.write8(1);\n      bb.write8(+value);\n    } else if (typeof value === \"number\") {\n      bb.write8(2);\n      bb.write32(value | 0);\n    } else if (typeof value === \"string\") {\n      bb.write8(3);\n      bb.write(encodeUTF8(value));\n    } else if (value instanceof Uint8Array) {\n      bb.write8(4);\n      bb.write(value);\n    } else if (value instanceof Array) {\n      bb.write8(5);\n      bb.write32(value.length);\n      for (let item of value) {\n        visit(item);\n      }\n    } else {\n      let keys = Object.keys(value);\n      bb.write8(6);\n      bb.write32(keys.length);\n      for (let key of keys) {\n        bb.write(encodeUTF8(key));\n        visit(value[key]);\n      }\n    }\n  };\n  let bb = new ByteBuffer();\n  bb.write32(0);\n  bb.write32(packet.id << 1 | +!packet.isRequest);\n  visit(packet.value);\n  writeUInt32LE(bb.buf, bb.len - 4, 0);\n  return bb.buf.subarray(0, bb.len);\n}\nfunction decodePacket(bytes) {\n  let visit = () => {\n    switch (bb.read8()) {\n      case 0:\n        return null;\n      case 1:\n        return !!bb.read8();\n      case 2:\n        return bb.read32();\n      case 3:\n        return decodeUTF8(bb.read());\n      case 4:\n        return bb.read();\n      case 5: {\n        let count = bb.read32();\n        let value2 = [];\n        for (let i = 0; i < count; i++) {\n          value2.push(visit());\n        }\n        return value2;\n      }\n      case 6: {\n        let count = bb.read32();\n        let value2 = {};\n        for (let i = 0; i < count; i++) {\n          value2[decodeUTF8(bb.read())] = visit();\n        }\n        return value2;\n      }\n      default:\n        throw new Error(\"Invalid packet\");\n    }\n  };\n  let bb = new ByteBuffer(bytes);\n  let id = bb.read32();\n  let isRequest = (id & 1) === 0;\n  id >>>= 1;\n  let value = visit();\n  if (bb.ptr !== bytes.length) {\n    throw new Error(\"Invalid packet\");\n  }\n  return { id, isRequest, value };\n}\nvar ByteBuffer = class {\n  constructor(buf = new Uint8Array(1024)) {\n    this.buf = buf;\n    this.len = 0;\n    this.ptr = 0;\n  }\n  _write(delta) {\n    if (this.len + delta > this.buf.length) {\n      let clone = new Uint8Array((this.len + delta) * 2);\n      clone.set(this.buf);\n      this.buf = clone;\n    }\n    this.len += delta;\n    return this.len - delta;\n  }\n  write8(value) {\n    let offset = this._write(1);\n    this.buf[offset] = value;\n  }\n  write32(value) {\n    let offset = this._write(4);\n    writeUInt32LE(this.buf, value, offset);\n  }\n  write(bytes) {\n    let offset = this._write(4 + bytes.length);\n    writeUInt32LE(this.buf, bytes.length, offset);\n    this.buf.set(bytes, offset + 4);\n  }\n  _read(delta) {\n    if (this.ptr + delta > this.buf.length) {\n      throw new Error(\"Invalid packet\");\n    }\n    this.ptr += delta;\n    return this.ptr - delta;\n  }\n  read8() {\n    return this.buf[this._read(1)];\n  }\n  read32() {\n    return readUInt32LE(this.buf, this._read(4));\n  }\n  read() {\n    let length = this.read32();\n    let bytes = new Uint8Array(length);\n    let ptr = this._read(bytes.length);\n    bytes.set(this.buf.subarray(ptr, ptr + length));\n    return bytes;\n  }\n};\nvar encodeUTF8;\nvar decodeUTF8;\nif (typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\") {\n  let encoder = new TextEncoder();\n  let decoder = new TextDecoder();\n  encodeUTF8 = (text) => encoder.encode(text);\n  decodeUTF8 = (bytes) => decoder.decode(bytes);\n} else if (typeof Buffer !== \"undefined\") {\n  encodeUTF8 = (text) => {\n    let buffer = Buffer.from(text);\n    if (!(buffer instanceof Uint8Array)) {\n      buffer = new Uint8Array(buffer);\n    }\n    return buffer;\n  };\n  decodeUTF8 = (bytes) => {\n    let { buffer, byteOffset, byteLength } = bytes;\n    return Buffer.from(buffer, byteOffset, byteLength).toString();\n  };\n} else {\n  throw new Error(\"No UTF-8 codec found\");\n}\nfunction readUInt32LE(buffer, offset) {\n  return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;\n}\nfunction writeUInt32LE(buffer, value, offset) {\n  buffer[offset++] = value;\n  buffer[offset++] = value >> 8;\n  buffer[offset++] = value >> 16;\n  buffer[offset++] = value >> 24;\n}\n\n// lib/shared/common.ts\nfunction validateTarget(target) {\n  target += \"\";\n  if (target.indexOf(\",\") >= 0)\n    throw new Error(`Invalid target: ${target}`);\n  return target;\n}\nvar canBeAnything = () => null;\nvar mustBeBoolean = (value) => typeof value === \"boolean\" ? null : \"a boolean\";\nvar mustBeBooleanOrObject = (value) => typeof value === \"boolean\" || typeof value === \"object\" && !Array.isArray(value) ? null : \"a boolean or an object\";\nvar mustBeString = (value) => typeof value === \"string\" ? null : \"a string\";\nvar mustBeRegExp = (value) => value instanceof RegExp ? null : \"a RegExp object\";\nvar mustBeInteger = (value) => typeof value === \"number\" && value === (value | 0) ? null : \"an integer\";\nvar mustBeFunction = (value) => typeof value === \"function\" ? null : \"a function\";\nvar mustBeArray = (value) => Array.isArray(value) ? null : \"an array\";\nvar mustBeObject = (value) => typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"an object\";\nvar mustBeArrayOrRecord = (value) => typeof value === \"object\" && value !== null ? null : \"an array or an object\";\nvar mustBeObjectOrNull = (value) => typeof value === \"object\" && !Array.isArray(value) ? null : \"an object or null\";\nvar mustBeStringOrBoolean = (value) => typeof value === \"string\" || typeof value === \"boolean\" ? null : \"a string or a boolean\";\nvar mustBeStringOrObject = (value) => typeof value === \"string\" || typeof value === \"object\" && value !== null && !Array.isArray(value) ? null : \"a string or an object\";\nvar mustBeStringOrArray = (value) => typeof value === \"string\" || Array.isArray(value) ? null : \"a string or an array\";\nvar mustBeStringOrUint8Array = (value) => typeof value === \"string\" || value instanceof Uint8Array ? null : \"a string or a Uint8Array\";\nfunction getFlag(object, keys, key, mustBeFn) {\n  let value = object[key];\n  keys[key + \"\"] = true;\n  if (value === void 0)\n    return void 0;\n  let mustBe = mustBeFn(value);\n  if (mustBe !== null)\n    throw new Error(`\"${key}\" must be ${mustBe}`);\n  return value;\n}\nfunction checkForInvalidFlags(object, keys, where) {\n  for (let key in object) {\n    if (!(key in keys)) {\n      throw new Error(`Invalid option ${where}: \"${key}\"`);\n    }\n  }\n}\nfunction validateInitializeOptions(options) {\n  let keys = /* @__PURE__ */ Object.create(null);\n  let wasmURL = getFlag(options, keys, \"wasmURL\", mustBeString);\n  let worker = getFlag(options, keys, \"worker\", mustBeBoolean);\n  checkForInvalidFlags(options, keys, \"in startService() call\");\n  return {\n    wasmURL,\n    worker\n  };\n}\nfunction validateMangleCache(mangleCache) {\n  let validated;\n  if (mangleCache !== void 0) {\n    validated = /* @__PURE__ */ Object.create(null);\n    for (let key of Object.keys(mangleCache)) {\n      let value = mangleCache[key];\n      if (typeof value === \"string\" || value === false) {\n        validated[key] = value;\n      } else {\n        throw new Error(`Expected ${JSON.stringify(key)} in mangle cache to map to either a string or false`);\n      }\n    }\n  }\n  return validated;\n}\nfunction pushLogFlags(flags, options, keys, isTTY, logLevelDefault) {\n  let color = getFlag(options, keys, \"color\", mustBeBoolean);\n  let logLevel = getFlag(options, keys, \"logLevel\", mustBeString);\n  let logLimit = getFlag(options, keys, \"logLimit\", mustBeInteger);\n  if (color !== void 0)\n    flags.push(`--color=${color}`);\n  else if (isTTY)\n    flags.push(`--color=true`);\n  flags.push(`--log-level=${logLevel || logLevelDefault}`);\n  flags.push(`--log-limit=${logLimit || 0}`);\n}\nfunction pushCommonFlags(flags, options, keys) {\n  let legalComments = getFlag(options, keys, \"legalComments\", mustBeString);\n  let sourceRoot = getFlag(options, keys, \"sourceRoot\", mustBeString);\n  let sourcesContent = getFlag(options, keys, \"sourcesContent\", mustBeBoolean);\n  let target = getFlag(options, keys, \"target\", mustBeStringOrArray);\n  let format = getFlag(options, keys, \"format\", mustBeString);\n  let globalName = getFlag(options, keys, \"globalName\", mustBeString);\n  let mangleProps = getFlag(options, keys, \"mangleProps\", mustBeRegExp);\n  let reserveProps = getFlag(options, keys, \"reserveProps\", mustBeRegExp);\n  let minify = getFlag(options, keys, \"minify\", mustBeBoolean);\n  let minifySyntax = getFlag(options, keys, \"minifySyntax\", mustBeBoolean);\n  let minifyWhitespace = getFlag(options, keys, \"minifyWhitespace\", mustBeBoolean);\n  let minifyIdentifiers = getFlag(options, keys, \"minifyIdentifiers\", mustBeBoolean);\n  let drop = getFlag(options, keys, \"drop\", mustBeArray);\n  let charset = getFlag(options, keys, \"charset\", mustBeString);\n  let treeShaking = getFlag(options, keys, \"treeShaking\", mustBeBoolean);\n  let ignoreAnnotations = getFlag(options, keys, \"ignoreAnnotations\", mustBeBoolean);\n  let jsx = getFlag(options, keys, \"jsx\", mustBeString);\n  let jsxFactory = getFlag(options, keys, \"jsxFactory\", mustBeString);\n  let jsxFragment = getFlag(options, keys, \"jsxFragment\", mustBeString);\n  let define = getFlag(options, keys, \"define\", mustBeObject);\n  let pure = getFlag(options, keys, \"pure\", mustBeArray);\n  let keepNames = getFlag(options, keys, \"keepNames\", mustBeBoolean);\n  if (legalComments)\n    flags.push(`--legal-comments=${legalComments}`);\n  if (sourceRoot !== void 0)\n    flags.push(`--source-root=${sourceRoot}`);\n  if (sourcesContent !== void 0)\n    flags.push(`--sources-content=${sourcesContent}`);\n  if (target) {\n    if (Array.isArray(target))\n      flags.push(`--target=${Array.from(target).map(validateTarget).join(\",\")}`);\n    else\n      flags.push(`--target=${validateTarget(target)}`);\n  }\n  if (format)\n    flags.push(`--format=${format}`);\n  if (globalName)\n    flags.push(`--global-name=${globalName}`);\n  if (minify)\n    flags.push(\"--minify\");\n  if (minifySyntax)\n    flags.push(\"--minify-syntax\");\n  if (minifyWhitespace)\n    flags.push(\"--minify-whitespace\");\n  if (minifyIdentifiers)\n    flags.push(\"--minify-identifiers\");\n  if (charset)\n    flags.push(`--charset=${charset}`);\n  if (treeShaking !== void 0)\n    flags.push(`--tree-shaking=${treeShaking}`);\n  if (ignoreAnnotations)\n    flags.push(`--ignore-annotations`);\n  if (drop)\n    for (let what of drop)\n      flags.push(`--drop:${what}`);\n  if (mangleProps)\n    flags.push(`--mangle-props=${mangleProps.source}`);\n  if (reserveProps)\n    flags.push(`--reserve-props=${reserveProps.source}`);\n  if (jsx)\n    flags.push(`--jsx=${jsx}`);\n  if (jsxFactory)\n    flags.push(`--jsx-factory=${jsxFactory}`);\n  if (jsxFragment)\n    flags.push(`--jsx-fragment=${jsxFragment}`);\n  if (define) {\n    for (let key in define) {\n      if (key.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid define: ${key}`);\n      flags.push(`--define:${key}=${define[key]}`);\n    }\n  }\n  if (pure)\n    for (let fn of pure)\n      flags.push(`--pure:${fn}`);\n  if (keepNames)\n    flags.push(`--keep-names`);\n}\nfunction flagsForBuildOptions(callName, options, isTTY, logLevelDefault, writeDefault) {\n  var _a;\n  let flags = [];\n  let entries = [];\n  let keys = /* @__PURE__ */ Object.create(null);\n  let stdinContents = null;\n  let stdinResolveDir = null;\n  let watchMode = null;\n  pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n  pushCommonFlags(flags, options, keys);\n  let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n  let bundle = getFlag(options, keys, \"bundle\", mustBeBoolean);\n  let watch = getFlag(options, keys, \"watch\", mustBeBooleanOrObject);\n  let splitting = getFlag(options, keys, \"splitting\", mustBeBoolean);\n  let preserveSymlinks = getFlag(options, keys, \"preserveSymlinks\", mustBeBoolean);\n  let metafile = getFlag(options, keys, \"metafile\", mustBeBoolean);\n  let outfile = getFlag(options, keys, \"outfile\", mustBeString);\n  let outdir = getFlag(options, keys, \"outdir\", mustBeString);\n  let outbase = getFlag(options, keys, \"outbase\", mustBeString);\n  let platform = getFlag(options, keys, \"platform\", mustBeString);\n  let tsconfig = getFlag(options, keys, \"tsconfig\", mustBeString);\n  let resolveExtensions = getFlag(options, keys, \"resolveExtensions\", mustBeArray);\n  let nodePathsInput = getFlag(options, keys, \"nodePaths\", mustBeArray);\n  let mainFields = getFlag(options, keys, \"mainFields\", mustBeArray);\n  let conditions = getFlag(options, keys, \"conditions\", mustBeArray);\n  let external = getFlag(options, keys, \"external\", mustBeArray);\n  let loader = getFlag(options, keys, \"loader\", mustBeObject);\n  let outExtension = getFlag(options, keys, \"outExtension\", mustBeObject);\n  let publicPath = getFlag(options, keys, \"publicPath\", mustBeString);\n  let entryNames = getFlag(options, keys, \"entryNames\", mustBeString);\n  let chunkNames = getFlag(options, keys, \"chunkNames\", mustBeString);\n  let assetNames = getFlag(options, keys, \"assetNames\", mustBeString);\n  let inject = getFlag(options, keys, \"inject\", mustBeArray);\n  let banner = getFlag(options, keys, \"banner\", mustBeObject);\n  let footer = getFlag(options, keys, \"footer\", mustBeObject);\n  let entryPoints = getFlag(options, keys, \"entryPoints\", mustBeArrayOrRecord);\n  let absWorkingDir = getFlag(options, keys, \"absWorkingDir\", mustBeString);\n  let stdin = getFlag(options, keys, \"stdin\", mustBeObject);\n  let write = (_a = getFlag(options, keys, \"write\", mustBeBoolean)) != null ? _a : writeDefault;\n  let allowOverwrite = getFlag(options, keys, \"allowOverwrite\", mustBeBoolean);\n  let incremental = getFlag(options, keys, \"incremental\", mustBeBoolean) === true;\n  let mangleCache = getFlag(options, keys, \"mangleCache\", mustBeObject);\n  keys.plugins = true;\n  checkForInvalidFlags(options, keys, `in ${callName}() call`);\n  if (sourcemap)\n    flags.push(`--sourcemap${sourcemap === true ? \"\" : `=${sourcemap}`}`);\n  if (bundle)\n    flags.push(\"--bundle\");\n  if (allowOverwrite)\n    flags.push(\"--allow-overwrite\");\n  if (watch) {\n    flags.push(\"--watch\");\n    if (typeof watch === \"boolean\") {\n      watchMode = {};\n    } else {\n      let watchKeys = /* @__PURE__ */ Object.create(null);\n      let onRebuild = getFlag(watch, watchKeys, \"onRebuild\", mustBeFunction);\n      checkForInvalidFlags(watch, watchKeys, `on \"watch\" in ${callName}() call`);\n      watchMode = { onRebuild };\n    }\n  }\n  if (splitting)\n    flags.push(\"--splitting\");\n  if (preserveSymlinks)\n    flags.push(\"--preserve-symlinks\");\n  if (metafile)\n    flags.push(`--metafile`);\n  if (outfile)\n    flags.push(`--outfile=${outfile}`);\n  if (outdir)\n    flags.push(`--outdir=${outdir}`);\n  if (outbase)\n    flags.push(`--outbase=${outbase}`);\n  if (platform)\n    flags.push(`--platform=${platform}`);\n  if (tsconfig)\n    flags.push(`--tsconfig=${tsconfig}`);\n  if (resolveExtensions) {\n    let values = [];\n    for (let value of resolveExtensions) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid resolve extension: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--resolve-extensions=${values.join(\",\")}`);\n  }\n  if (publicPath)\n    flags.push(`--public-path=${publicPath}`);\n  if (entryNames)\n    flags.push(`--entry-names=${entryNames}`);\n  if (chunkNames)\n    flags.push(`--chunk-names=${chunkNames}`);\n  if (assetNames)\n    flags.push(`--asset-names=${assetNames}`);\n  if (mainFields) {\n    let values = [];\n    for (let value of mainFields) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid main field: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--main-fields=${values.join(\",\")}`);\n  }\n  if (conditions) {\n    let values = [];\n    for (let value of conditions) {\n      value += \"\";\n      if (value.indexOf(\",\") >= 0)\n        throw new Error(`Invalid condition: ${value}`);\n      values.push(value);\n    }\n    flags.push(`--conditions=${values.join(\",\")}`);\n  }\n  if (external)\n    for (let name of external)\n      flags.push(`--external:${name}`);\n  if (banner) {\n    for (let type in banner) {\n      if (type.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid banner file type: ${type}`);\n      flags.push(`--banner:${type}=${banner[type]}`);\n    }\n  }\n  if (footer) {\n    for (let type in footer) {\n      if (type.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid footer file type: ${type}`);\n      flags.push(`--footer:${type}=${footer[type]}`);\n    }\n  }\n  if (inject)\n    for (let path of inject)\n      flags.push(`--inject:${path}`);\n  if (loader) {\n    for (let ext in loader) {\n      if (ext.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid loader extension: ${ext}`);\n      flags.push(`--loader:${ext}=${loader[ext]}`);\n    }\n  }\n  if (outExtension) {\n    for (let ext in outExtension) {\n      if (ext.indexOf(\"=\") >= 0)\n        throw new Error(`Invalid out extension: ${ext}`);\n      flags.push(`--out-extension:${ext}=${outExtension[ext]}`);\n    }\n  }\n  if (entryPoints) {\n    if (Array.isArray(entryPoints)) {\n      for (let entryPoint of entryPoints) {\n        entries.push([\"\", entryPoint + \"\"]);\n      }\n    } else {\n      for (let [key, value] of Object.entries(entryPoints)) {\n        entries.push([key + \"\", value + \"\"]);\n      }\n    }\n  }\n  if (stdin) {\n    let stdinKeys = /* @__PURE__ */ Object.create(null);\n    let contents = getFlag(stdin, stdinKeys, \"contents\", mustBeString);\n    let resolveDir = getFlag(stdin, stdinKeys, \"resolveDir\", mustBeString);\n    let sourcefile = getFlag(stdin, stdinKeys, \"sourcefile\", mustBeString);\n    let loader2 = getFlag(stdin, stdinKeys, \"loader\", mustBeString);\n    checkForInvalidFlags(stdin, stdinKeys, 'in \"stdin\" object');\n    if (sourcefile)\n      flags.push(`--sourcefile=${sourcefile}`);\n    if (loader2)\n      flags.push(`--loader=${loader2}`);\n    if (resolveDir)\n      stdinResolveDir = resolveDir + \"\";\n    stdinContents = contents ? contents + \"\" : \"\";\n  }\n  let nodePaths = [];\n  if (nodePathsInput) {\n    for (let value of nodePathsInput) {\n      value += \"\";\n      nodePaths.push(value);\n    }\n  }\n  return {\n    entries,\n    flags,\n    write,\n    stdinContents,\n    stdinResolveDir,\n    absWorkingDir,\n    incremental,\n    nodePaths,\n    watch: watchMode,\n    mangleCache: validateMangleCache(mangleCache)\n  };\n}\nfunction flagsForTransformOptions(callName, options, isTTY, logLevelDefault) {\n  let flags = [];\n  let keys = /* @__PURE__ */ Object.create(null);\n  pushLogFlags(flags, options, keys, isTTY, logLevelDefault);\n  pushCommonFlags(flags, options, keys);\n  let sourcemap = getFlag(options, keys, \"sourcemap\", mustBeStringOrBoolean);\n  let tsconfigRaw = getFlag(options, keys, \"tsconfigRaw\", mustBeStringOrObject);\n  let sourcefile = getFlag(options, keys, \"sourcefile\", mustBeString);\n  let loader = getFlag(options, keys, \"loader\", mustBeString);\n  let banner = getFlag(options, keys, \"banner\", mustBeString);\n  let footer = getFlag(options, keys, \"footer\", mustBeString);\n  let mangleCache = getFlag(options, keys, \"mangleCache\", mustBeObject);\n  checkForInvalidFlags(options, keys, `in ${callName}() call`);\n  if (sourcemap)\n    flags.push(`--sourcemap=${sourcemap === true ? \"external\" : sourcemap}`);\n  if (tsconfigRaw)\n    flags.push(`--tsconfig-raw=${typeof tsconfigRaw === \"string\" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);\n  if (sourcefile)\n    flags.push(`--sourcefile=${sourcefile}`);\n  if (loader)\n    flags.push(`--loader=${loader}`);\n  if (banner)\n    flags.push(`--banner=${banner}`);\n  if (footer)\n    flags.push(`--footer=${footer}`);\n  return {\n    flags,\n    mangleCache: validateMangleCache(mangleCache)\n  };\n}\nfunction createChannel(streamIn) {\n  let responseCallbacks = /* @__PURE__ */ new Map();\n  let pluginCallbacks = /* @__PURE__ */ new Map();\n  let watchCallbacks = /* @__PURE__ */ new Map();\n  let serveCallbacks = /* @__PURE__ */ new Map();\n  let isClosed = false;\n  let nextRequestID = 0;\n  let nextBuildKey = 0;\n  let stdout = new Uint8Array(16 * 1024);\n  let stdoutUsed = 0;\n  let readFromStdout = (chunk) => {\n    let limit = stdoutUsed + chunk.length;\n    if (limit > stdout.length) {\n      let swap = new Uint8Array(limit * 2);\n      swap.set(stdout);\n      stdout = swap;\n    }\n    stdout.set(chunk, stdoutUsed);\n    stdoutUsed += chunk.length;\n    let offset = 0;\n    while (offset + 4 <= stdoutUsed) {\n      let length = readUInt32LE(stdout, offset);\n      if (offset + 4 + length > stdoutUsed) {\n        break;\n      }\n      offset += 4;\n      handleIncomingPacket(stdout.subarray(offset, offset + length));\n      offset += length;\n    }\n    if (offset > 0) {\n      stdout.copyWithin(0, offset, stdoutUsed);\n      stdoutUsed -= offset;\n    }\n  };\n  let afterClose = () => {\n    isClosed = true;\n    for (let callback of responseCallbacks.values()) {\n      callback(\"The service was stopped\", null);\n    }\n    responseCallbacks.clear();\n    for (let callbacks of serveCallbacks.values()) {\n      callbacks.onWait(\"The service was stopped\");\n    }\n    serveCallbacks.clear();\n    for (let callback of watchCallbacks.values()) {\n      try {\n        callback(new Error(\"The service was stopped\"), null);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    watchCallbacks.clear();\n  };\n  let sendRequest = (refs, value, callback) => {\n    if (isClosed)\n      return callback(\"The service is no longer running\", null);\n    let id = nextRequestID++;\n    responseCallbacks.set(id, (error, response) => {\n      try {\n        callback(error, response);\n      } finally {\n        if (refs)\n          refs.unref();\n      }\n    });\n    if (refs)\n      refs.ref();\n    streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));\n  };\n  let sendResponse = (id, value) => {\n    if (isClosed)\n      throw new Error(\"The service is no longer running\");\n    streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));\n  };\n  let handleRequest = (id, request) => __async(this, null, function* () {\n    try {\n      switch (request.command) {\n        case \"ping\": {\n          sendResponse(id, {});\n          break;\n        }\n        case \"on-start\": {\n          let callback = pluginCallbacks.get(request.key);\n          if (!callback)\n            sendResponse(id, {});\n          else\n            sendResponse(id, yield callback(request));\n          break;\n        }\n        case \"on-resolve\": {\n          let callback = pluginCallbacks.get(request.key);\n          if (!callback)\n            sendResponse(id, {});\n          else\n            sendResponse(id, yield callback(request));\n          break;\n        }\n        case \"on-load\": {\n          let callback = pluginCallbacks.get(request.key);\n          if (!callback)\n            sendResponse(id, {});\n          else\n            sendResponse(id, yield callback(request));\n          break;\n        }\n        case \"serve-request\": {\n          let callbacks = serveCallbacks.get(request.key);\n          if (callbacks && callbacks.onRequest)\n            callbacks.onRequest(request.args);\n          sendResponse(id, {});\n          break;\n        }\n        case \"serve-wait\": {\n          let callbacks = serveCallbacks.get(request.key);\n          if (callbacks)\n            callbacks.onWait(request.error);\n          sendResponse(id, {});\n          break;\n        }\n        case \"watch-rebuild\": {\n          let callback = watchCallbacks.get(request.key);\n          try {\n            if (callback)\n              callback(null, request.args);\n          } catch (err) {\n            console.error(err);\n          }\n          sendResponse(id, {});\n          break;\n        }\n        default:\n          throw new Error(`Invalid command: ` + request.command);\n      }\n    } catch (e) {\n      sendResponse(id, { errors: [extractErrorMessageV8(e, streamIn, null, void 0, \"\")] });\n    }\n  });\n  let isFirstPacket = true;\n  let handleIncomingPacket = (bytes) => {\n    if (isFirstPacket) {\n      isFirstPacket = false;\n      let binaryVersion = String.fromCharCode(...bytes);\n      if (binaryVersion !== \"0.14.22\") {\n        throw new Error(`Cannot start service: Host version \"${\"0.14.22\"}\" does not match binary version ${JSON.stringify(binaryVersion)}`);\n      }\n      return;\n    }\n    let packet = decodePacket(bytes);\n    if (packet.isRequest) {\n      handleRequest(packet.id, packet.value);\n    } else {\n      let callback = responseCallbacks.get(packet.id);\n      responseCallbacks.delete(packet.id);\n      if (packet.value.error)\n        callback(packet.value.error, {});\n      else\n        callback(null, packet.value);\n    }\n  };\n  let handlePlugins = (initialOptions, plugins, buildKey, stash, refs) => __async(this, null, function* () {\n    let onStartCallbacks = [];\n    let onEndCallbacks = [];\n    let onResolveCallbacks = {};\n    let onLoadCallbacks = {};\n    let nextCallbackID = 0;\n    let i = 0;\n    let requestPlugins = [];\n    let isSetupDone = false;\n    plugins = [...plugins];\n    for (let item of plugins) {\n      let keys = {};\n      if (typeof item !== \"object\")\n        throw new Error(`Plugin at index ${i} must be an object`);\n      const name = getFlag(item, keys, \"name\", mustBeString);\n      if (typeof name !== \"string\" || name === \"\")\n        throw new Error(`Plugin at index ${i} is missing a name`);\n      try {\n        let setup = getFlag(item, keys, \"setup\", mustBeFunction);\n        if (typeof setup !== \"function\")\n          throw new Error(`Plugin is missing a setup function`);\n        checkForInvalidFlags(item, keys, `on plugin ${JSON.stringify(name)}`);\n        let plugin = {\n          name,\n          onResolve: [],\n          onLoad: []\n        };\n        i++;\n        let resolve = (path, options = {}) => {\n          if (!isSetupDone)\n            throw new Error('Cannot call \"resolve\" before plugin setup has completed');\n          if (typeof path !== \"string\")\n            throw new Error(`The path to resolve must be a string`);\n          let keys2 = /* @__PURE__ */ Object.create(null);\n          let pluginName = getFlag(options, keys2, \"pluginName\", mustBeString);\n          let importer = getFlag(options, keys2, \"importer\", mustBeString);\n          let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n          let resolveDir = getFlag(options, keys2, \"resolveDir\", mustBeString);\n          let kind = getFlag(options, keys2, \"kind\", mustBeString);\n          let pluginData = getFlag(options, keys2, \"pluginData\", canBeAnything);\n          checkForInvalidFlags(options, keys2, \"in resolve() call\");\n          return new Promise((resolve2, reject) => {\n            const request = {\n              command: \"resolve\",\n              path,\n              key: buildKey,\n              pluginName: name\n            };\n            if (pluginName != null)\n              request.pluginName = pluginName;\n            if (importer != null)\n              request.importer = importer;\n            if (namespace != null)\n              request.namespace = namespace;\n            if (resolveDir != null)\n              request.resolveDir = resolveDir;\n            if (kind != null)\n              request.kind = kind;\n            if (pluginData != null)\n              request.pluginData = stash.store(pluginData);\n            sendRequest(refs, request, (error, response) => {\n              if (error !== null)\n                reject(new Error(error));\n              else\n                resolve2({\n                  errors: replaceDetailsInMessages(response.errors, stash),\n                  warnings: replaceDetailsInMessages(response.warnings, stash),\n                  path: response.path,\n                  external: response.external,\n                  sideEffects: response.sideEffects,\n                  namespace: response.namespace,\n                  suffix: response.suffix,\n                  pluginData: stash.load(response.pluginData)\n                });\n            });\n          });\n        };\n        let promise = setup({\n          initialOptions,\n          resolve,\n          onStart(callback2) {\n            let registeredText = `This error came from the \"onStart\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onStart\");\n            onStartCallbacks.push({ name, callback: callback2, note: registeredNote });\n          },\n          onEnd(callback2) {\n            let registeredText = `This error came from the \"onEnd\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onEnd\");\n            onEndCallbacks.push({ name, callback: callback2, note: registeredNote });\n          },\n          onResolve(options, callback2) {\n            let registeredText = `This error came from the \"onResolve\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onResolve\");\n            let keys2 = {};\n            let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n            let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n            checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${JSON.stringify(name)}`);\n            if (filter == null)\n              throw new Error(`onResolve() call is missing a filter`);\n            let id = nextCallbackID++;\n            onResolveCallbacks[id] = { name, callback: callback2, note: registeredNote };\n            plugin.onResolve.push({ id, filter: filter.source, namespace: namespace || \"\" });\n          },\n          onLoad(options, callback2) {\n            let registeredText = `This error came from the \"onLoad\" callback registered here:`;\n            let registeredNote = extractCallerV8(new Error(registeredText), streamIn, \"onLoad\");\n            let keys2 = {};\n            let filter = getFlag(options, keys2, \"filter\", mustBeRegExp);\n            let namespace = getFlag(options, keys2, \"namespace\", mustBeString);\n            checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${JSON.stringify(name)}`);\n            if (filter == null)\n              throw new Error(`onLoad() call is missing a filter`);\n            let id = nextCallbackID++;\n            onLoadCallbacks[id] = { name, callback: callback2, note: registeredNote };\n            plugin.onLoad.push({ id, filter: filter.source, namespace: namespace || \"\" });\n          },\n          esbuild: streamIn.esbuild\n        });\n        if (promise)\n          yield promise;\n        requestPlugins.push(plugin);\n      } catch (e) {\n        return { ok: false, error: e, pluginName: name };\n      }\n    }\n    const callback = (request) => __async(this, null, function* () {\n      switch (request.command) {\n        case \"on-start\": {\n          let response = { errors: [], warnings: [] };\n          yield Promise.all(onStartCallbacks.map((_0) => __async(this, [_0], function* ({ name, callback: callback2, note }) {\n            try {\n              let result = yield callback2();\n              if (result != null) {\n                if (typeof result !== \"object\")\n                  throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(name)} to return an object`);\n                let keys = {};\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${JSON.stringify(name)}`);\n                if (errors != null)\n                  response.errors.push(...sanitizeMessages(errors, \"errors\", stash, name));\n                if (warnings != null)\n                  response.warnings.push(...sanitizeMessages(warnings, \"warnings\", stash, name));\n              }\n            } catch (e) {\n              response.errors.push(extractErrorMessageV8(e, streamIn, stash, note && note(), name));\n            }\n          })));\n          return response;\n        }\n        case \"on-resolve\": {\n          let response = {}, name = \"\", callback2, note;\n          for (let id of request.ids) {\n            try {\n              ({ name, callback: callback2, note } = onResolveCallbacks[id]);\n              let result = yield callback2({\n                path: request.path,\n                importer: request.importer,\n                namespace: request.namespace,\n                resolveDir: request.resolveDir,\n                kind: request.kind,\n                pluginData: stash.load(request.pluginData)\n              });\n              if (result != null) {\n                if (typeof result !== \"object\")\n                  throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(name)} to return an object`);\n                let keys = {};\n                let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                let path = getFlag(result, keys, \"path\", mustBeString);\n                let namespace = getFlag(result, keys, \"namespace\", mustBeString);\n                let suffix = getFlag(result, keys, \"suffix\", mustBeString);\n                let external = getFlag(result, keys, \"external\", mustBeBoolean);\n                let sideEffects = getFlag(result, keys, \"sideEffects\", mustBeBoolean);\n                let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n                let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n                checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${JSON.stringify(name)}`);\n                response.id = id;\n                if (pluginName != null)\n                  response.pluginName = pluginName;\n                if (path != null)\n                  response.path = path;\n                if (namespace != null)\n                  response.namespace = namespace;\n                if (suffix != null)\n                  response.suffix = suffix;\n                if (external != null)\n                  response.external = external;\n                if (sideEffects != null)\n                  response.sideEffects = sideEffects;\n                if (pluginData != null)\n                  response.pluginData = stash.store(pluginData);\n                if (errors != null)\n                  response.errors = sanitizeMessages(errors, \"errors\", stash, name);\n                if (warnings != null)\n                  response.warnings = sanitizeMessages(warnings, \"warnings\", stash, name);\n                if (watchFiles != null)\n                  response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                if (watchDirs != null)\n                  response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                break;\n              }\n            } catch (e) {\n              return { id, errors: [extractErrorMessageV8(e, streamIn, stash, note && note(), name)] };\n            }\n          }\n          return response;\n        }\n        case \"on-load\": {\n          let response = {}, name = \"\", callback2, note;\n          for (let id of request.ids) {\n            try {\n              ({ name, callback: callback2, note } = onLoadCallbacks[id]);\n              let result = yield callback2({\n                path: request.path,\n                namespace: request.namespace,\n                suffix: request.suffix,\n                pluginData: stash.load(request.pluginData)\n              });\n              if (result != null) {\n                if (typeof result !== \"object\")\n                  throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(name)} to return an object`);\n                let keys = {};\n                let pluginName = getFlag(result, keys, \"pluginName\", mustBeString);\n                let contents = getFlag(result, keys, \"contents\", mustBeStringOrUint8Array);\n                let resolveDir = getFlag(result, keys, \"resolveDir\", mustBeString);\n                let pluginData = getFlag(result, keys, \"pluginData\", canBeAnything);\n                let loader = getFlag(result, keys, \"loader\", mustBeString);\n                let errors = getFlag(result, keys, \"errors\", mustBeArray);\n                let warnings = getFlag(result, keys, \"warnings\", mustBeArray);\n                let watchFiles = getFlag(result, keys, \"watchFiles\", mustBeArray);\n                let watchDirs = getFlag(result, keys, \"watchDirs\", mustBeArray);\n                checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${JSON.stringify(name)}`);\n                response.id = id;\n                if (pluginName != null)\n                  response.pluginName = pluginName;\n                if (contents instanceof Uint8Array)\n                  response.contents = contents;\n                else if (contents != null)\n                  response.contents = encodeUTF8(contents);\n                if (resolveDir != null)\n                  response.resolveDir = resolveDir;\n                if (pluginData != null)\n                  response.pluginData = stash.store(pluginData);\n                if (loader != null)\n                  response.loader = loader;\n                if (errors != null)\n                  response.errors = sanitizeMessages(errors, \"errors\", stash, name);\n                if (warnings != null)\n                  response.warnings = sanitizeMessages(warnings, \"warnings\", stash, name);\n                if (watchFiles != null)\n                  response.watchFiles = sanitizeStringArray(watchFiles, \"watchFiles\");\n                if (watchDirs != null)\n                  response.watchDirs = sanitizeStringArray(watchDirs, \"watchDirs\");\n                break;\n              }\n            } catch (e) {\n              return { id, errors: [extractErrorMessageV8(e, streamIn, stash, note && note(), name)] };\n            }\n          }\n          return response;\n        }\n        default:\n          throw new Error(`Invalid command: ` + request.command);\n      }\n    });\n    let runOnEndCallbacks = (result, logPluginError, done) => done();\n    if (onEndCallbacks.length > 0) {\n      runOnEndCallbacks = (result, logPluginError, done) => {\n        (() => __async(this, null, function* () {\n          for (const { name, callback: callback2, note } of onEndCallbacks) {\n            try {\n              yield callback2(result);\n            } catch (e) {\n              result.errors.push(yield new Promise((resolve) => logPluginError(e, name, note && note(), resolve)));\n            }\n          }\n        }))().then(done);\n      };\n    }\n    isSetupDone = true;\n    let refCount = 0;\n    return {\n      ok: true,\n      requestPlugins,\n      runOnEndCallbacks,\n      pluginRefs: {\n        ref() {\n          if (++refCount === 1)\n            pluginCallbacks.set(buildKey, callback);\n        },\n        unref() {\n          if (--refCount === 0)\n            pluginCallbacks.delete(buildKey);\n        }\n      }\n    };\n  });\n  let buildServeData = (refs, options, request, key) => {\n    let keys = {};\n    let port = getFlag(options, keys, \"port\", mustBeInteger);\n    let host = getFlag(options, keys, \"host\", mustBeString);\n    let servedir = getFlag(options, keys, \"servedir\", mustBeString);\n    let onRequest = getFlag(options, keys, \"onRequest\", mustBeFunction);\n    let onWait;\n    let wait = new Promise((resolve, reject) => {\n      onWait = (error) => {\n        serveCallbacks.delete(key);\n        if (error !== null)\n          reject(new Error(error));\n        else\n          resolve();\n      };\n    });\n    request.serve = {};\n    checkForInvalidFlags(options, keys, `in serve() call`);\n    if (port !== void 0)\n      request.serve.port = port;\n    if (host !== void 0)\n      request.serve.host = host;\n    if (servedir !== void 0)\n      request.serve.servedir = servedir;\n    serveCallbacks.set(key, {\n      onRequest,\n      onWait\n    });\n    return {\n      wait,\n      stop() {\n        sendRequest(refs, { command: \"serve-stop\", key }, () => {\n        });\n      }\n    };\n  };\n  const buildLogLevelDefault = \"warning\";\n  const transformLogLevelDefault = \"silent\";\n  let buildOrServe = (args) => {\n    let key = nextBuildKey++;\n    const details = createObjectStash();\n    let plugins;\n    let { refs, options, isTTY, callback } = args;\n    if (typeof options === \"object\") {\n      let value = options.plugins;\n      if (value !== void 0) {\n        if (!Array.isArray(value))\n          throw new Error(`\"plugins\" must be an array`);\n        plugins = value;\n      }\n    }\n    let logPluginError = (e, pluginName, note, done) => {\n      let flags = [];\n      try {\n        pushLogFlags(flags, options, {}, isTTY, buildLogLevelDefault);\n      } catch (e2) {\n      }\n      const message = extractErrorMessageV8(e, streamIn, details, note, pluginName);\n      sendRequest(refs, { command: \"error\", flags, error: message }, () => {\n        message.detail = details.load(message.detail);\n        done(message);\n      });\n    };\n    let handleError = (e, pluginName) => {\n      logPluginError(e, pluginName, void 0, (error) => {\n        callback(failureErrorWithLog(\"Build failed\", [error], []), null);\n      });\n    };\n    if (plugins && plugins.length > 0) {\n      if (streamIn.isSync)\n        return handleError(new Error(\"Cannot use plugins in synchronous API calls\"), \"\");\n      handlePlugins(options, plugins, key, details, refs).then((result) => {\n        if (!result.ok) {\n          handleError(result.error, result.pluginName);\n        } else {\n          try {\n            buildOrServeContinue(__spreadProps(__spreadValues({}, args), {\n              key,\n              details,\n              logPluginError,\n              requestPlugins: result.requestPlugins,\n              runOnEndCallbacks: result.runOnEndCallbacks,\n              pluginRefs: result.pluginRefs\n            }));\n          } catch (e) {\n            handleError(e, \"\");\n          }\n        }\n      }, (e) => handleError(e, \"\"));\n    } else {\n      try {\n        buildOrServeContinue(__spreadProps(__spreadValues({}, args), {\n          key,\n          details,\n          logPluginError,\n          requestPlugins: null,\n          runOnEndCallbacks: (result, logPluginError2, done) => done(),\n          pluginRefs: null\n        }));\n      } catch (e) {\n        handleError(e, \"\");\n      }\n    }\n  };\n  let buildOrServeContinue = ({\n    callName,\n    refs: callerRefs,\n    serveOptions,\n    options,\n    isTTY,\n    defaultWD,\n    callback,\n    key,\n    details,\n    logPluginError,\n    requestPlugins,\n    runOnEndCallbacks,\n    pluginRefs\n  }) => {\n    const refs = {\n      ref() {\n        if (pluginRefs)\n          pluginRefs.ref();\n        if (callerRefs)\n          callerRefs.ref();\n      },\n      unref() {\n        if (pluginRefs)\n          pluginRefs.unref();\n        if (callerRefs)\n          callerRefs.unref();\n      }\n    };\n    let writeDefault = !streamIn.isBrowser;\n    let {\n      entries,\n      flags,\n      write,\n      stdinContents,\n      stdinResolveDir,\n      absWorkingDir,\n      incremental,\n      nodePaths,\n      watch,\n      mangleCache\n    } = flagsForBuildOptions(callName, options, isTTY, buildLogLevelDefault, writeDefault);\n    let request = {\n      command: \"build\",\n      key,\n      entries,\n      flags,\n      write,\n      stdinContents,\n      stdinResolveDir,\n      absWorkingDir: absWorkingDir || defaultWD,\n      incremental,\n      nodePaths\n    };\n    if (requestPlugins)\n      request.plugins = requestPlugins;\n    if (mangleCache)\n      request.mangleCache = mangleCache;\n    let serve2 = serveOptions && buildServeData(refs, serveOptions, request, key);\n    let rebuild;\n    let stop;\n    let copyResponseToResult = (response, result) => {\n      if (response.outputFiles)\n        result.outputFiles = response.outputFiles.map(convertOutputFiles);\n      if (response.metafile)\n        result.metafile = JSON.parse(response.metafile);\n      if (response.mangleCache)\n        result.mangleCache = response.mangleCache;\n      if (response.writeToStdout !== void 0)\n        console.log(decodeUTF8(response.writeToStdout).replace(/\\n$/, \"\"));\n    };\n    let buildResponseToResult = (response, callback2) => {\n      let result = {\n        errors: replaceDetailsInMessages(response.errors, details),\n        warnings: replaceDetailsInMessages(response.warnings, details)\n      };\n      copyResponseToResult(response, result);\n      runOnEndCallbacks(result, logPluginError, () => {\n        if (result.errors.length > 0) {\n          return callback2(failureErrorWithLog(\"Build failed\", result.errors, result.warnings), null);\n        }\n        if (response.rebuild) {\n          if (!rebuild) {\n            let isDisposed = false;\n            rebuild = () => new Promise((resolve, reject) => {\n              if (isDisposed || isClosed)\n                throw new Error(\"Cannot rebuild\");\n              sendRequest(refs, { command: \"rebuild\", key }, (error2, response2) => {\n                if (error2) {\n                  const message = { pluginName: \"\", text: error2, location: null, notes: [], detail: void 0 };\n                  return callback2(failureErrorWithLog(\"Build failed\", [message], []), null);\n                }\n                buildResponseToResult(response2, (error3, result3) => {\n                  if (error3)\n                    reject(error3);\n                  else\n                    resolve(result3);\n                });\n              });\n            });\n            refs.ref();\n            rebuild.dispose = () => {\n              if (isDisposed)\n                return;\n              isDisposed = true;\n              sendRequest(refs, { command: \"rebuild-dispose\", key }, () => {\n              });\n              refs.unref();\n            };\n          }\n          result.rebuild = rebuild;\n        }\n        if (response.watch) {\n          if (!stop) {\n            let isStopped = false;\n            refs.ref();\n            stop = () => {\n              if (isStopped)\n                return;\n              isStopped = true;\n              watchCallbacks.delete(key);\n              sendRequest(refs, { command: \"watch-stop\", key }, () => {\n              });\n              refs.unref();\n            };\n            if (watch) {\n              watchCallbacks.set(key, (serviceStopError, watchResponse) => {\n                if (serviceStopError) {\n                  if (watch.onRebuild)\n                    watch.onRebuild(serviceStopError, null);\n                  return;\n                }\n                let result2 = {\n                  errors: replaceDetailsInMessages(watchResponse.errors, details),\n                  warnings: replaceDetailsInMessages(watchResponse.warnings, details)\n                };\n                copyResponseToResult(watchResponse, result2);\n                runOnEndCallbacks(result2, logPluginError, () => {\n                  if (result2.errors.length > 0) {\n                    if (watch.onRebuild)\n                      watch.onRebuild(failureErrorWithLog(\"Build failed\", result2.errors, result2.warnings), null);\n                    return;\n                  }\n                  if (watchResponse.rebuildID !== void 0)\n                    result2.rebuild = rebuild;\n                  result2.stop = stop;\n                  if (watch.onRebuild)\n                    watch.onRebuild(null, result2);\n                });\n              });\n            }\n          }\n          result.stop = stop;\n        }\n        callback2(null, result);\n      });\n    };\n    if (write && streamIn.isBrowser)\n      throw new Error(`Cannot enable \"write\" in the browser`);\n    if (incremental && streamIn.isSync)\n      throw new Error(`Cannot use \"incremental\" with a synchronous build`);\n    if (watch && streamIn.isSync)\n      throw new Error(`Cannot use \"watch\" with a synchronous build`);\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      if (serve2) {\n        let serveResponse = response;\n        let isStopped = false;\n        refs.ref();\n        let result = {\n          port: serveResponse.port,\n          host: serveResponse.host,\n          wait: serve2.wait,\n          stop() {\n            if (isStopped)\n              return;\n            isStopped = true;\n            serve2.stop();\n            refs.unref();\n          }\n        };\n        refs.ref();\n        serve2.wait.then(refs.unref, refs.unref);\n        return callback(null, result);\n      }\n      return buildResponseToResult(response, callback);\n    });\n  };\n  let transform2 = ({ callName, refs, input, options, isTTY, fs, callback }) => {\n    const details = createObjectStash();\n    let start = (inputPath) => {\n      try {\n        if (typeof input !== \"string\")\n          throw new Error('The input to \"transform\" must be a string');\n        let {\n          flags,\n          mangleCache\n        } = flagsForTransformOptions(callName, options, isTTY, transformLogLevelDefault);\n        let request = {\n          command: \"transform\",\n          flags,\n          inputFS: inputPath !== null,\n          input: inputPath !== null ? inputPath : input\n        };\n        if (mangleCache)\n          request.mangleCache = mangleCache;\n        sendRequest(refs, request, (error, response) => {\n          if (error)\n            return callback(new Error(error), null);\n          let errors = replaceDetailsInMessages(response.errors, details);\n          let warnings = replaceDetailsInMessages(response.warnings, details);\n          let outstanding = 1;\n          let next = () => {\n            if (--outstanding === 0) {\n              let result = { warnings, code: response.code, map: response.map };\n              if (response.mangleCache)\n                result.mangleCache = response == null ? void 0 : response.mangleCache;\n              callback(null, result);\n            }\n          };\n          if (errors.length > 0)\n            return callback(failureErrorWithLog(\"Transform failed\", errors, warnings), null);\n          if (response.codeFS) {\n            outstanding++;\n            fs.readFile(response.code, (err, contents) => {\n              if (err !== null) {\n                callback(err, null);\n              } else {\n                response.code = contents;\n                next();\n              }\n            });\n          }\n          if (response.mapFS) {\n            outstanding++;\n            fs.readFile(response.map, (err, contents) => {\n              if (err !== null) {\n                callback(err, null);\n              } else {\n                response.map = contents;\n                next();\n              }\n            });\n          }\n          next();\n        });\n      } catch (e) {\n        let flags = [];\n        try {\n          pushLogFlags(flags, options, {}, isTTY, transformLogLevelDefault);\n        } catch (e2) {\n        }\n        const error = extractErrorMessageV8(e, streamIn, details, void 0, \"\");\n        sendRequest(refs, { command: \"error\", flags, error }, () => {\n          error.detail = details.load(error.detail);\n          callback(failureErrorWithLog(\"Transform failed\", [error], []), null);\n        });\n      }\n    };\n    if (typeof input === \"string\" && input.length > 1024 * 1024) {\n      let next = start;\n      start = () => fs.writeFile(input, next);\n    }\n    start(null);\n  };\n  let formatMessages2 = ({ callName, refs, messages, options, callback }) => {\n    let result = sanitizeMessages(messages, \"messages\", null, \"\");\n    if (!options)\n      throw new Error(`Missing second argument in ${callName}() call`);\n    let keys = {};\n    let kind = getFlag(options, keys, \"kind\", mustBeString);\n    let color = getFlag(options, keys, \"color\", mustBeBoolean);\n    let terminalWidth = getFlag(options, keys, \"terminalWidth\", mustBeInteger);\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    if (kind === void 0)\n      throw new Error(`Missing \"kind\" in ${callName}() call`);\n    if (kind !== \"error\" && kind !== \"warning\")\n      throw new Error(`Expected \"kind\" to be \"error\" or \"warning\" in ${callName}() call`);\n    let request = {\n      command: \"format-msgs\",\n      messages: result,\n      isWarning: kind === \"warning\"\n    };\n    if (color !== void 0)\n      request.color = color;\n    if (terminalWidth !== void 0)\n      request.terminalWidth = terminalWidth;\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      callback(null, response.messages);\n    });\n  };\n  let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {\n    if (options === void 0)\n      options = {};\n    let keys = {};\n    let color = getFlag(options, keys, \"color\", mustBeBoolean);\n    let verbose = getFlag(options, keys, \"verbose\", mustBeBoolean);\n    checkForInvalidFlags(options, keys, `in ${callName}() call`);\n    let request = {\n      command: \"analyze-metafile\",\n      metafile\n    };\n    if (color !== void 0)\n      request.color = color;\n    if (verbose !== void 0)\n      request.verbose = verbose;\n    sendRequest(refs, request, (error, response) => {\n      if (error)\n        return callback(new Error(error), null);\n      callback(null, response.result);\n    });\n  };\n  return {\n    readFromStdout,\n    afterClose,\n    service: {\n      buildOrServe,\n      transform: transform2,\n      formatMessages: formatMessages2,\n      analyzeMetafile: analyzeMetafile2\n    }\n  };\n}\nfunction createObjectStash() {\n  const map = /* @__PURE__ */ new Map();\n  let nextID = 0;\n  return {\n    load(id) {\n      return map.get(id);\n    },\n    store(value) {\n      if (value === void 0)\n        return -1;\n      const id = nextID++;\n      map.set(id, value);\n      return id;\n    }\n  };\n}\nfunction extractCallerV8(e, streamIn, ident) {\n  let note;\n  let tried = false;\n  return () => {\n    if (tried)\n      return note;\n    tried = true;\n    try {\n      let lines = (e.stack + \"\").split(\"\\n\");\n      lines.splice(1, 1);\n      let location = parseStackLinesV8(streamIn, lines, ident);\n      if (location) {\n        note = { text: e.message, location };\n        return note;\n      }\n    } catch (e2) {\n    }\n  };\n}\nfunction extractErrorMessageV8(e, streamIn, stash, note, pluginName) {\n  let text = \"Internal error\";\n  let location = null;\n  try {\n    text = (e && e.message || e) + \"\";\n  } catch (e2) {\n  }\n  try {\n    location = parseStackLinesV8(streamIn, (e.stack + \"\").split(\"\\n\"), \"\");\n  } catch (e2) {\n  }\n  return { pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };\n}\nfunction parseStackLinesV8(streamIn, lines, ident) {\n  let at = \"    at \";\n  if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {\n    for (let i = 1; i < lines.length; i++) {\n      let line = lines[i];\n      if (!line.startsWith(at))\n        continue;\n      line = line.slice(at.length);\n      while (true) {\n        let match = /^(?:new |async )?\\S+ \\((.*)\\)$/.exec(line);\n        if (match) {\n          line = match[1];\n          continue;\n        }\n        match = /^eval at \\S+ \\((.*)\\)(?:, \\S+:\\d+:\\d+)?$/.exec(line);\n        if (match) {\n          line = match[1];\n          continue;\n        }\n        match = /^(\\S+):(\\d+):(\\d+)$/.exec(line);\n        if (match) {\n          let contents;\n          try {\n            contents = streamIn.readFileSync(match[1], \"utf8\");\n          } catch (e) {\n            break;\n          }\n          let lineText = contents.split(/\\r\\n|\\r|\\n|\\u2028|\\u2029/)[+match[2] - 1] || \"\";\n          let column = +match[3] - 1;\n          let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;\n          return {\n            file: match[1],\n            namespace: \"file\",\n            line: +match[2],\n            column: encodeUTF8(lineText.slice(0, column)).length,\n            length: encodeUTF8(lineText.slice(column, column + length)).length,\n            lineText: lineText + \"\\n\" + lines.slice(1).join(\"\\n\"),\n            suggestion: \"\"\n          };\n        }\n        break;\n      }\n    }\n  }\n  return null;\n}\nfunction failureErrorWithLog(text, errors, warnings) {\n  let limit = 5;\n  let summary = errors.length < 1 ? \"\" : ` with ${errors.length} error${errors.length < 2 ? \"\" : \"s\"}:` + errors.slice(0, limit + 1).map((e, i) => {\n    if (i === limit)\n      return \"\\n...\";\n    if (!e.location)\n      return `\nerror: ${e.text}`;\n    let { file, line, column } = e.location;\n    let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : \"\";\n    return `\n${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;\n  }).join(\"\");\n  let error = new Error(`${text}${summary}`);\n  error.errors = errors;\n  error.warnings = warnings;\n  return error;\n}\nfunction replaceDetailsInMessages(messages, stash) {\n  for (const message of messages) {\n    message.detail = stash.load(message.detail);\n  }\n  return messages;\n}\nfunction sanitizeLocation(location, where) {\n  if (location == null)\n    return null;\n  let keys = {};\n  let file = getFlag(location, keys, \"file\", mustBeString);\n  let namespace = getFlag(location, keys, \"namespace\", mustBeString);\n  let line = getFlag(location, keys, \"line\", mustBeInteger);\n  let column = getFlag(location, keys, \"column\", mustBeInteger);\n  let length = getFlag(location, keys, \"length\", mustBeInteger);\n  let lineText = getFlag(location, keys, \"lineText\", mustBeString);\n  let suggestion = getFlag(location, keys, \"suggestion\", mustBeString);\n  checkForInvalidFlags(location, keys, where);\n  return {\n    file: file || \"\",\n    namespace: namespace || \"\",\n    line: line || 0,\n    column: column || 0,\n    length: length || 0,\n    lineText: lineText || \"\",\n    suggestion: suggestion || \"\"\n  };\n}\nfunction sanitizeMessages(messages, property, stash, fallbackPluginName) {\n  let messagesClone = [];\n  let index = 0;\n  for (const message of messages) {\n    let keys = {};\n    let pluginName = getFlag(message, keys, \"pluginName\", mustBeString);\n    let text = getFlag(message, keys, \"text\", mustBeString);\n    let location = getFlag(message, keys, \"location\", mustBeObjectOrNull);\n    let notes = getFlag(message, keys, \"notes\", mustBeArray);\n    let detail = getFlag(message, keys, \"detail\", canBeAnything);\n    let where = `in element ${index} of \"${property}\"`;\n    checkForInvalidFlags(message, keys, where);\n    let notesClone = [];\n    if (notes) {\n      for (const note of notes) {\n        let noteKeys = {};\n        let noteText = getFlag(note, noteKeys, \"text\", mustBeString);\n        let noteLocation = getFlag(note, noteKeys, \"location\", mustBeObjectOrNull);\n        checkForInvalidFlags(note, noteKeys, where);\n        notesClone.push({\n          text: noteText || \"\",\n          location: sanitizeLocation(noteLocation, where)\n        });\n      }\n    }\n    messagesClone.push({\n      pluginName: pluginName || fallbackPluginName,\n      text: text || \"\",\n      location: sanitizeLocation(location, where),\n      notes: notesClone,\n      detail: stash ? stash.store(detail) : -1\n    });\n    index++;\n  }\n  return messagesClone;\n}\nfunction sanitizeStringArray(values, property) {\n  const result = [];\n  for (const value of values) {\n    if (typeof value !== \"string\")\n      throw new Error(`${JSON.stringify(property)} must be an array of strings`);\n    result.push(value);\n  }\n  return result;\n}\nfunction convertOutputFiles({ path, contents }) {\n  let text = null;\n  return {\n    path,\n    contents,\n    get text() {\n      if (text === null)\n        text = decodeUTF8(contents);\n      return text;\n    }\n  };\n}\n\n// lib/npm/browser.ts\nvar version = \"0.14.22\";\nvar build = (options) => ensureServiceIsRunning().build(options);\nvar serve = () => {\n  throw new Error(`The \"serve\" API only works in node`);\n};\nvar transform = (input, options) => ensureServiceIsRunning().transform(input, options);\nvar formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);\nvar analyzeMetafile = (metafile, options) => ensureServiceIsRunning().analyzeMetafile(metafile, options);\nvar buildSync = () => {\n  throw new Error(`The \"buildSync\" API only works in node`);\n};\nvar transformSync = () => {\n  throw new Error(`The \"transformSync\" API only works in node`);\n};\nvar formatMessagesSync = () => {\n  throw new Error(`The \"formatMessagesSync\" API only works in node`);\n};\nvar analyzeMetafileSync = () => {\n  throw new Error(`The \"analyzeMetafileSync\" API only works in node`);\n};\nvar initializePromise;\nvar longLivedService;\nvar ensureServiceIsRunning = () => {\n  if (longLivedService)\n    return longLivedService;\n  if (initializePromise)\n    throw new Error('You need to wait for the promise returned from \"initialize\" to be resolved before calling this');\n  throw new Error('You need to call \"initialize\" before calling this');\n};\nvar initialize = (options) => {\n  options = validateInitializeOptions(options || {});\n  let wasmURL = options.wasmURL;\n  let useWorker = options.worker !== false;\n  if (!wasmURL)\n    throw new Error('Must provide the \"wasmURL\" option');\n  wasmURL += \"\";\n  if (initializePromise)\n    throw new Error('Cannot call \"initialize\" more than once');\n  initializePromise = startRunningService(wasmURL, useWorker);\n  initializePromise.catch(() => {\n    initializePromise = void 0;\n  });\n  return initializePromise;\n};\nvar startRunningService = (wasmURL, useWorker) => __async(void 0, null, function* () {\n  let res = yield fetch(wasmURL);\n  if (!res.ok)\n    throw new Error(`Failed to download ${JSON.stringify(wasmURL)}`);\n  let wasm = yield res.arrayBuffer();\n  let code = `{let global={};for(let o=self;o;o=Object.getPrototypeOf(o))for(let k of Object.getOwnPropertyNames(o))if(!(k in global))Object.defineProperty(global,k,{get:()=>self[k]});// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n(() => {\n\t// Map multiple JavaScript environments to a single common API,\n\t// preferring web standards over Node.js API.\n\t//\n\t// Environments considered:\n\t// - Browsers\n\t// - Node.js\n\t// - Electron\n\t// - Parcel\n\t// - Webpack\n\n\tif (typeof global !== \"undefined\") {\n\t\t// global already exists\n\t} else if (typeof window !== \"undefined\") {\n\t\twindow.global = window;\n\t} else if (typeof self !== \"undefined\") {\n\t\tself.global = self;\n\t} else {\n\t\tthrow new Error(\"cannot export Go (neither global, window nor self is defined)\");\n\t}\n\n\tif (!global.require && typeof require !== \"undefined\") {\n\t\tglobal.require = require;\n\t}\n\n\tif (!global.fs && global.require) {\n\t\tconst fs = require(\"fs\");\n\t\tif (typeof fs === \"object\" && fs !== null && Object.keys(fs).length !== 0) {\n\t\t\t\n    global.fs = Object.assign({}, fs, {\n      // Hack around a Unicode bug in node: https://github.com/nodejs/node/issues/24550\n      write(fd, buf, offset, length, position, callback) {\n        if (offset === 0 && length === buf.length && position === null) {\n          if (fd === process.stdout.fd) {\n            try {\n              process.stdout.write(buf, err => err ? callback(err, 0, null) : callback(null, length, buf));\n            } catch (err) {\n              callback(err, 0, null);\n            }\n            return;\n          }\n          if (fd === process.stderr.fd) {\n            try {\n              process.stderr.write(buf, err => err ? callback(err, 0, null) : callback(null, length, buf));\n            } catch (err) {\n              callback(err, 0, null);\n            }\n            return;\n          }\n        }\n        fs.write(fd, buf, offset, length, position, callback);\n      },\n    });\n  \n\t\t}\n\t}\n\n\tconst enosys = () => {\n\t\tconst err = new Error(\"not implemented\");\n\t\terr.code = \"ENOSYS\";\n\t\treturn err;\n\t};\n\n\tif (!global.fs) {\n\t\tlet outputBuf = \"\";\n\t\tglobal.fs = {\n\t\t\tconstants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 }, // unused\n\t\t\twriteSync(fd, buf) {\n\t\t\t\toutputBuf += decoder.decode(buf);\n\t\t\t\tconst nl = outputBuf.lastIndexOf(\"\\\\n\");\n\t\t\t\tif (nl != -1) {\n\t\t\t\t\tconsole.log(outputBuf.substr(0, nl));\n\t\t\t\t\toutputBuf = outputBuf.substr(nl + 1);\n\t\t\t\t}\n\t\t\t\treturn buf.length;\n\t\t\t},\n\t\t\twrite(fd, buf, offset, length, position, callback) {\n\t\t\t\tif (offset !== 0 || length !== buf.length || position !== null) {\n\t\t\t\t\tcallback(enosys());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst n = this.writeSync(fd, buf);\n\t\t\t\tcallback(null, n);\n\t\t\t},\n\t\t\tchmod(path, mode, callback) { callback(enosys()); },\n\t\t\tchown(path, uid, gid, callback) { callback(enosys()); },\n\t\t\tclose(fd, callback) { callback(enosys()); },\n\t\t\tfchmod(fd, mode, callback) { callback(enosys()); },\n\t\t\tfchown(fd, uid, gid, callback) { callback(enosys()); },\n\t\t\tfstat(fd, callback) { callback(enosys()); },\n\t\t\tfsync(fd, callback) { callback(null); },\n\t\t\tftruncate(fd, length, callback) { callback(enosys()); },\n\t\t\tlchown(path, uid, gid, callback) { callback(enosys()); },\n\t\t\tlink(path, link, callback) { callback(enosys()); },\n\t\t\tlstat(path, callback) { callback(enosys()); },\n\t\t\tmkdir(path, perm, callback) { callback(enosys()); },\n\t\t\topen(path, flags, mode, callback) { callback(enosys()); },\n\t\t\tread(fd, buffer, offset, length, position, callback) { callback(enosys()); },\n\t\t\treaddir(path, callback) { callback(enosys()); },\n\t\t\treadlink(path, callback) { callback(enosys()); },\n\t\t\trename(from, to, callback) { callback(enosys()); },\n\t\t\trmdir(path, callback) { callback(enosys()); },\n\t\t\tstat(path, callback) { callback(enosys()); },\n\t\t\tsymlink(path, link, callback) { callback(enosys()); },\n\t\t\ttruncate(path, length, callback) { callback(enosys()); },\n\t\t\tunlink(path, callback) { callback(enosys()); },\n\t\t\tutimes(path, atime, mtime, callback) { callback(enosys()); },\n\t\t};\n\t}\n\n\tif (!global.process) {\n\t\tglobal.process = {\n\t\t\tgetuid() { return -1; },\n\t\t\tgetgid() { return -1; },\n\t\t\tgeteuid() { return -1; },\n\t\t\tgetegid() { return -1; },\n\t\t\tgetgroups() { throw enosys(); },\n\t\t\tpid: -1,\n\t\t\tppid: -1,\n\t\t\tumask() { throw enosys(); },\n\t\t\tcwd() { throw enosys(); },\n\t\t\tchdir() { throw enosys(); },\n\t\t}\n\t}\n\n\tif (!global.crypto && global.require) {\n\t\tconst nodeCrypto = require(\"crypto\");\n\t\tglobal.crypto = {\n\t\t\tgetRandomValues(b) {\n\t\t\t\tnodeCrypto.randomFillSync(b);\n\t\t\t},\n\t\t};\n\t}\n\tif (!global.crypto) {\n\t\tthrow new Error(\"global.crypto is not available, polyfill required (getRandomValues only)\");\n\t}\n\n\tif (!global.performance) {\n\t\tglobal.performance = {\n\t\t\tnow() {\n\t\t\t\tconst [sec, nsec] = process.hrtime();\n\t\t\t\treturn sec * 1000 + nsec / 1000000;\n\t\t\t},\n\t\t};\n\t}\n\n\tif (!global.TextEncoder && global.require) {\n\t\tglobal.TextEncoder = require(\"util\").TextEncoder;\n\t}\n\tif (!global.TextEncoder) {\n\t\tthrow new Error(\"global.TextEncoder is not available, polyfill required\");\n\t}\n\n\tif (!global.TextDecoder && global.require) {\n\t\tglobal.TextDecoder = require(\"util\").TextDecoder;\n\t}\n\tif (!global.TextDecoder) {\n\t\tthrow new Error(\"global.TextDecoder is not available, polyfill required\");\n\t}\n\n\t\n    // Make sure Go sees the shadowed \"fs\" global\n    const { fs } = global;\n  \n\n\tconst encoder = new TextEncoder(\"utf-8\");\n\tconst decoder = new TextDecoder(\"utf-8\");\n\n\tglobal.Go = class {\n\t\tconstructor() {\n\t\t\tthis.argv = [\"js\"];\n\t\t\tthis.env = {};\n\t\t\tthis.exit = (code) => {\n\t\t\t\tif (code !== 0) {\n\t\t\t\t\tconsole.warn(\"exit code:\", code);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._exitPromise = new Promise((resolve) => {\n\t\t\t\tthis._resolveExitPromise = resolve;\n\t\t\t});\n\t\t\tthis._pendingEvent = null;\n\t\t\tthis._scheduledTimeouts = new Map();\n\t\t\tthis._nextCallbackTimeoutID = 1;\n\n\t\t\tconst setInt64 = (addr, v) => {\n\t\t\t\tthis.mem.setUint32(addr + 0, v, true);\n\t\t\t\tthis.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n\t\t\t}\n\n\t\t\tconst getInt64 = (addr) => {\n\t\t\t\tconst low = this.mem.getUint32(addr + 0, true);\n\t\t\t\tconst high = this.mem.getInt32(addr + 4, true);\n\t\t\t\treturn low + high * 4294967296;\n\t\t\t}\n\n\t\t\tconst loadValue = (addr) => {\n\t\t\t\tconst f = this.mem.getFloat64(addr, true);\n\t\t\t\tif (f === 0) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (!isNaN(f)) {\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\n\t\t\t\tconst id = this.mem.getUint32(addr, true);\n\t\t\t\treturn this._values[id];\n\t\t\t}\n\n\t\t\tconst storeValue = (addr, v) => {\n\t\t\t\tconst nanHead = 0x7FF80000;\n\n\t\t\t\tif (typeof v === \"number\" && v !== 0) {\n\t\t\t\t\tif (isNaN(v)) {\n\t\t\t\t\t\tthis.mem.setUint32(addr + 4, nanHead, true);\n\t\t\t\t\t\tthis.mem.setUint32(addr, 0, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.mem.setFloat64(addr, v, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (v === undefined) {\n\t\t\t\t\tthis.mem.setFloat64(addr, 0, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet id = this._ids.get(v);\n\t\t\t\tif (id === undefined) {\n\t\t\t\t\tid = this._idPool.pop();\n\t\t\t\t\tif (id === undefined) {\n\t\t\t\t\t\tid = this._values.length;\n\t\t\t\t\t}\n\t\t\t\t\tthis._values[id] = v;\n\t\t\t\t\tthis._goRefCounts[id] = 0;\n\t\t\t\t\tthis._ids.set(v, id);\n\t\t\t\t}\n\t\t\t\tthis._goRefCounts[id]++;\n\t\t\t\tlet typeFlag = 0;\n\t\t\t\tswitch (typeof v) {\n\t\t\t\t\tcase \"object\":\n\t\t\t\t\t\tif (v !== null) {\n\t\t\t\t\t\t\ttypeFlag = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\ttypeFlag = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"symbol\":\n\t\t\t\t\t\ttypeFlag = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\ttypeFlag = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n\t\t\t\tthis.mem.setUint32(addr, id, true);\n\t\t\t}\n\n\t\t\tconst loadSlice = (addr) => {\n\t\t\t\tconst array = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\treturn new Uint8Array(this._inst.exports.mem.buffer, array, len);\n\t\t\t}\n\n\t\t\tconst loadSliceOfValues = (addr) => {\n\t\t\t\tconst array = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\tconst a = new Array(len);\n\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\ta[i] = loadValue(array + i * 8);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tconst loadString = (addr) => {\n\t\t\t\tconst saddr = getInt64(addr + 0);\n\t\t\t\tconst len = getInt64(addr + 8);\n\t\t\t\treturn decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n\t\t\t}\n\n\t\t\tconst timeOrigin = Date.now() - performance.now();\n\t\t\tthis.importObject = {\n\t\t\t\tgo: {\n\t\t\t\t\t// Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n\t\t\t\t\t// may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n\t\t\t\t\t// function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n\t\t\t\t\t// This changes the SP, thus we have to update the SP used by the imported function.\n\n\t\t\t\t\t// func wasmExit(code int32)\n\t\t\t\t\t\"runtime.wasmExit\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst code = this.mem.getInt32(sp + 8, true);\n\t\t\t\t\t\tthis.exited = true;\n\t\t\t\t\t\tdelete this._inst;\n\t\t\t\t\t\tdelete this._values;\n\t\t\t\t\t\tdelete this._goRefCounts;\n\t\t\t\t\t\tdelete this._ids;\n\t\t\t\t\t\tdelete this._idPool;\n\t\t\t\t\t\tthis.exit(code);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n\t\t\t\t\t\"runtime.wasmWrite\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst fd = getInt64(sp + 8);\n\t\t\t\t\t\tconst p = getInt64(sp + 16);\n\t\t\t\t\t\tconst n = this.mem.getInt32(sp + 24, true);\n\t\t\t\t\t\tfs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func resetMemoryDataView()\n\t\t\t\t\t\"runtime.resetMemoryDataView\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tthis.mem = new DataView(this._inst.exports.mem.buffer);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func nanotime1() int64\n\t\t\t\t\t\"runtime.nanotime1\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tsetInt64(sp + 8, (timeOrigin + performance.now()) * 1000000);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func walltime() (sec int64, nsec int32)\n\t\t\t\t\t\"runtime.walltime\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst msec = (new Date).getTime();\n\t\t\t\t\t\tsetInt64(sp + 8, msec / 1000);\n\t\t\t\t\t\tthis.mem.setInt32(sp + 16, (msec % 1000) * 1000000, true);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func scheduleTimeoutEvent(delay int64) int32\n\t\t\t\t\t\"runtime.scheduleTimeoutEvent\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this._nextCallbackTimeoutID;\n\t\t\t\t\t\tthis._nextCallbackTimeoutID++;\n\t\t\t\t\t\tthis._scheduledTimeouts.set(id, setTimeout(\n\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\tthis._resume();\n\t\t\t\t\t\t\t\twhile (this._scheduledTimeouts.has(id)) {\n\t\t\t\t\t\t\t\t\t// for some reason Go failed to register the timeout event, log and try again\n\t\t\t\t\t\t\t\t\t// (temporary workaround for https://github.com/golang/go/issues/28975)\n\t\t\t\t\t\t\t\t\tconsole.warn(\"scheduleTimeoutEvent: missed timeout event\");\n\t\t\t\t\t\t\t\t\tthis._resume();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetInt64(sp + 8) + 1, // setTimeout has been seen to fire up to 1 millisecond early\n\t\t\t\t\t\t));\n\t\t\t\t\t\tthis.mem.setInt32(sp + 16, id, true);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func clearTimeoutEvent(id int32)\n\t\t\t\t\t\"runtime.clearTimeoutEvent\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this.mem.getInt32(sp + 8, true);\n\t\t\t\t\t\tclearTimeout(this._scheduledTimeouts.get(id));\n\t\t\t\t\t\tthis._scheduledTimeouts.delete(id);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func getRandomData(r []byte)\n\t\t\t\t\t\"runtime.getRandomData\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tcrypto.getRandomValues(loadSlice(sp + 8));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func finalizeRef(v ref)\n\t\t\t\t\t\"syscall/js.finalizeRef\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst id = this.mem.getUint32(sp + 8, true);\n\t\t\t\t\t\tthis._goRefCounts[id]--;\n\t\t\t\t\t\tif (this._goRefCounts[id] === 0) {\n\t\t\t\t\t\t\tconst v = this._values[id];\n\t\t\t\t\t\t\tthis._values[id] = null;\n\t\t\t\t\t\t\tthis._ids.delete(v);\n\t\t\t\t\t\t\tthis._idPool.push(id);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func stringVal(value string) ref\n\t\t\t\t\t\"syscall/js.stringVal\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tstoreValue(sp + 24, loadString(sp + 8));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueGet(v ref, p string) ref\n\t\t\t\t\t\"syscall/js.valueGet\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\tstoreValue(sp + 32, result);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueSet(v ref, p string, x ref)\n\t\t\t\t\t\"syscall/js.valueSet\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueDelete(v ref, p string)\n\t\t\t\t\t\"syscall/js.valueDelete\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueIndex(v ref, i int) ref\n\t\t\t\t\t\"syscall/js.valueIndex\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tstoreValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueSetIndex(v ref, i int, x ref)\n\t\t\t\t\t\"syscall/js.valueSetIndex\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tReflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueCall(v ref, m string, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueCall\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst m = Reflect.get(v, loadString(sp + 16));\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 32);\n\t\t\t\t\t\t\tconst result = Reflect.apply(m, v, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 56, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 64, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 56, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 64, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInvoke(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueInvoke\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 16);\n\t\t\t\t\t\t\tconst result = Reflect.apply(v, undefined, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueNew(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueNew\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(sp + 8);\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(sp + 16);\n\t\t\t\t\t\t\tconst result = Reflect.construct(v, args);\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, result);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp() >>> 0; // see comment above\n\t\t\t\t\t\t\tstoreValue(sp + 40, err);\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueLength(v ref) int\n\t\t\t\t\t\"syscall/js.valueLength\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tsetInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n\t\t\t\t\t},\n\n\t\t\t\t\t// valuePrepareString(v ref) (ref, int)\n\t\t\t\t\t\"syscall/js.valuePrepareString\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst str = encoder.encode(String(loadValue(sp + 8)));\n\t\t\t\t\t\tstoreValue(sp + 16, str);\n\t\t\t\t\t\tsetInt64(sp + 24, str.length);\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueLoadString(v ref, b []byte)\n\t\t\t\t\t\"syscall/js.valueLoadString\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst str = loadValue(sp + 8);\n\t\t\t\t\t\tloadSlice(sp + 16).set(str);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInstanceOf(v ref, t ref) bool\n\t\t\t\t\t\"syscall/js.valueInstanceOf\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tthis.mem.setUint8(sp + 24, (loadValue(sp + 8) instanceof loadValue(sp + 16)) ? 1 : 0);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func copyBytesToGo(dst []byte, src ref) (int, bool)\n\t\t\t\t\t\"syscall/js.copyBytesToGo\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst dst = loadSlice(sp + 8);\n\t\t\t\t\t\tconst src = loadValue(sp + 32);\n\t\t\t\t\t\tif (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst toCopy = src.subarray(0, dst.length);\n\t\t\t\t\t\tdst.set(toCopy);\n\t\t\t\t\t\tsetInt64(sp + 40, toCopy.length);\n\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func copyBytesToJS(dst ref, src []byte) (int, bool)\n\t\t\t\t\t\"syscall/js.copyBytesToJS\": (sp) => {\n\t\t\t\t\t\tsp >>>= 0;\n\t\t\t\t\t\tconst dst = loadValue(sp + 8);\n\t\t\t\t\t\tconst src = loadSlice(sp + 16);\n\t\t\t\t\t\tif (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n\t\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst toCopy = src.subarray(0, dst.length);\n\t\t\t\t\t\tdst.set(toCopy);\n\t\t\t\t\t\tsetInt64(sp + 40, toCopy.length);\n\t\t\t\t\t\tthis.mem.setUint8(sp + 48, 1);\n\t\t\t\t\t},\n\n\t\t\t\t\t\"debug\": (value) => {\n\t\t\t\t\t\tconsole.log(value);\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tasync run(instance) {\n\t\t\tif (!(instance instanceof WebAssembly.Instance)) {\n\t\t\t\tthrow new Error(\"Go.run: WebAssembly.Instance expected\");\n\t\t\t}\n\t\t\tthis._inst = instance;\n\t\t\tthis.mem = new DataView(this._inst.exports.mem.buffer);\n\t\t\tthis._values = [ // JS values that Go currently has references to, indexed by reference id\n\t\t\t\tNaN,\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t\tglobal,\n\t\t\t\tthis,\n\t\t\t];\n\t\t\tthis._goRefCounts = new Array(this._values.length).fill(Infinity); // number of references that Go has to a JS value, indexed by reference id\n\t\t\tthis._ids = new Map([ // mapping from JS values to reference ids\n\t\t\t\t[0, 1],\n\t\t\t\t[null, 2],\n\t\t\t\t[true, 3],\n\t\t\t\t[false, 4],\n\t\t\t\t[global, 5],\n\t\t\t\t[this, 6],\n\t\t\t]);\n\t\t\tthis._idPool = [];   // unused ids that have been garbage collected\n\t\t\tthis.exited = false; // whether the Go program has exited\n\n\t\t\t// Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n\t\t\tlet offset = 4096;\n\n\t\t\tconst strPtr = (str) => {\n\t\t\t\tconst ptr = offset;\n\t\t\t\tconst bytes = encoder.encode(str + \"\\\\0\");\n\t\t\t\tnew Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n\t\t\t\toffset += bytes.length;\n\t\t\t\tif (offset % 8 !== 0) {\n\t\t\t\t\toffset += 8 - (offset % 8);\n\t\t\t\t}\n\t\t\t\treturn ptr;\n\t\t\t};\n\n\t\t\tconst argc = this.argv.length;\n\n\t\t\tconst argvPtrs = [];\n\t\t\tthis.argv.forEach((arg) => {\n\t\t\t\targvPtrs.push(strPtr(arg));\n\t\t\t});\n\t\t\targvPtrs.push(0);\n\n\t\t\tconst keys = Object.keys(this.env).sort();\n\t\t\tkeys.forEach((key) => {\n\t\t\t\targvPtrs.push(strPtr(\\`\\${key}=\\${this.env[key]}\\`));\n\t\t\t});\n\t\t\targvPtrs.push(0);\n\n\t\t\tconst argv = offset;\n\t\t\targvPtrs.forEach((ptr) => {\n\t\t\t\tthis.mem.setUint32(offset, ptr, true);\n\t\t\t\tthis.mem.setUint32(offset + 4, 0, true);\n\t\t\t\toffset += 8;\n\t\t\t});\n\n\t\t\t// The linker guarantees global data starts from at least wasmMinDataAddr.\n\t\t\t// Keep in sync with cmd/link/internal/ld/data.go:wasmMinDataAddr.\n\t\t\tconst wasmMinDataAddr = 4096 + 8192;\n\t\t\tif (offset >= wasmMinDataAddr) {\n\t\t\t\tthrow new Error(\"total length of command line and environment variables exceeds limit\");\n\t\t\t}\n\n\t\t\tthis._inst.exports.run(argc, argv);\n\t\t\tif (this.exited) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t\tawait this._exitPromise;\n\t\t}\n\n\t\t_resume() {\n\t\t\tif (this.exited) {\n\t\t\t\tthrow new Error(\"Go program has already exited\");\n\t\t\t}\n\t\t\tthis._inst.exports.resume();\n\t\t\tif (this.exited) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t}\n\n\t\t_makeFuncWrapper(id) {\n\t\t\tconst go = this;\n\t\t\treturn function () {\n\t\t\t\tconst event = { id: id, this: this, args: arguments };\n\t\t\t\tgo._pendingEvent = event;\n\t\t\t\tgo._resume();\n\t\t\t\treturn event.result;\n\t\t\t};\n\t\t}\n\t}\n\n\tif (\n\t\ttypeof module !== \"undefined\" &&\n\t\tglobal.require &&\n\t\tglobal.require.main === module &&\n\t\tglobal.process &&\n\t\tglobal.process.versions &&\n\t\t!global.process.versions.electron\n\t) {\n\t\tif (process.argv.length < 3) {\n\t\t\tconsole.error(\"usage: go_js_wasm_exec [wasm binary] [arguments]\");\n\t\t\tprocess.exit(1);\n\t\t}\n\n\t\tconst go = new Go();\n\t\tgo.argv = process.argv.slice(2);\n\t\tgo.env = Object.assign({ TMPDIR: require(\"os\").tmpdir() }, process.env);\n\t\tgo.exit = process.exit;\n\t\tWebAssembly.instantiate(fs.readFileSync(process.argv[2]), go.importObject).then((result) => {\n\t\t\tprocess.on(\"exit\", (code) => { // Node.js exits if no event handler is pending\n\t\t\t\tif (code === 0 && !go.exited) {\n\t\t\t\t\t// deadlock, make Go print error and stack traces\n\t\t\t\t\tgo._pendingEvent = { id: 0 };\n\t\t\t\t\tgo._resume();\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn go.run(result.instance);\n\t\t}).catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tprocess.exit(1);\n\t\t});\n\t}\n})();\nonmessage = ({ data: wasm }) => {\n  let decoder = new TextDecoder();\n  let fs = global.fs;\n  let stderr = \"\";\n  fs.writeSync = (fd, buffer) => {\n    if (fd === 1) {\n      postMessage(buffer);\n    } else if (fd === 2) {\n      stderr += decoder.decode(buffer);\n      let parts = stderr.split(\"\\\\n\");\n      if (parts.length > 1)\n        console.log(parts.slice(0, -1).join(\"\\\\n\"));\n      stderr = parts[parts.length - 1];\n    } else {\n      throw new Error(\"Bad write\");\n    }\n    return buffer.length;\n  };\n  let stdin = [];\n  let resumeStdin;\n  let stdinPos = 0;\n  onmessage = ({ data }) => {\n    if (data.length > 0) {\n      stdin.push(data);\n      if (resumeStdin)\n        resumeStdin();\n    }\n  };\n  fs.read = (fd, buffer, offset, length, position, callback) => {\n    if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\n      throw new Error(\"Bad read\");\n    }\n    if (stdin.length === 0) {\n      resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\n      return;\n    }\n    let first = stdin[0];\n    let count = Math.max(0, Math.min(length, first.length - stdinPos));\n    buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n    stdinPos += count;\n    if (stdinPos === first.length) {\n      stdin.shift();\n      stdinPos = 0;\n    }\n    callback(null, count);\n  };\n  let go = new global.Go();\n  go.argv = [\"\", \\`--service=\\${\"0.14.22\"}\\`];\n  WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));\n};}`;\n  let worker;\n  if (useWorker) {\n    let blob = new Blob([code], { type: \"text/javascript\" });\n    worker = new Worker(URL.createObjectURL(blob));\n  } else {\n    let fn = new Function(\"postMessage\", code + `var onmessage; return m => onmessage(m)`);\n    let onmessage = fn((data) => worker.onmessage({ data }));\n    worker = {\n      onmessage: null,\n      postMessage: (data) => onmessage({ data }),\n      terminate() {\n      }\n    };\n  }\n  worker.postMessage(wasm);\n  worker.onmessage = ({ data }) => readFromStdout(data);\n  let { readFromStdout, service } = createChannel({\n    writeToStdin(bytes) {\n      worker.postMessage(bytes);\n    },\n    isSync: false,\n    isBrowser: true,\n    esbuild: browser_exports\n  });\n  longLivedService = {\n    build: (options) => new Promise((resolve, reject) => service.buildOrServe({\n      callName: \"build\",\n      refs: null,\n      serveOptions: null,\n      options,\n      isTTY: false,\n      defaultWD: \"/\",\n      callback: (err, res2) => err ? reject(err) : resolve(res2)\n    })),\n    transform: (input, options) => new Promise((resolve, reject) => service.transform({\n      callName: \"transform\",\n      refs: null,\n      input,\n      options: options || {},\n      isTTY: false,\n      fs: {\n        readFile(_, callback) {\n          callback(new Error(\"Internal error\"), null);\n        },\n        writeFile(_, callback) {\n          callback(null);\n        }\n      },\n      callback: (err, res2) => err ? reject(err) : resolve(res2)\n    })),\n    formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({\n      callName: \"formatMessages\",\n      refs: null,\n      messages,\n      options,\n      callback: (err, res2) => err ? reject(err) : resolve(res2)\n    })),\n    analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({\n      callName: \"analyzeMetafile\",\n      refs: null,\n      metafile: typeof metafile === \"string\" ? metafile : JSON.stringify(metafile),\n      options,\n      callback: (err, res2) => err ? reject(err) : resolve(res2)\n    }))\n  };\n});\nvar browser_default = browser_exports;\nmodule.exports = __toCommonJS(browser_exports);\n})(typeof module===\"object\"?module:{set exports(x){(typeof self!==\"undefined\"?self:this).esbuild=x}});\n"]},"metadata":{},"sourceType":"script"}