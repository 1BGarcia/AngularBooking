{"ast":null,"code":"var _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nconst debug = require('debug')('streamroller:moveAndMaybeCompressFile');\n\nconst fs = require('fs-extra');\n\nconst zlib = require('zlib');\n\nconst _parseOption = function (rawOptions) {\n  const defaultOptions = {\n    mode: parseInt(\"0600\", 8),\n    compress: false\n  };\n  const options = Object.assign({}, defaultOptions, rawOptions);\n  debug(`_parseOption: moveAndMaybeCompressFile called with option=${JSON.stringify(options)}`);\n  return options;\n};\n\nconst moveAndMaybeCompressFile = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (sourceFilePath, targetFilePath, options) {\n    options = _parseOption(options);\n\n    if (sourceFilePath === targetFilePath) {\n      debug(`moveAndMaybeCompressFile: source and target are the same, not doing anything`);\n      return;\n    }\n\n    if (yield fs.pathExists(sourceFilePath)) {\n      debug(`moveAndMaybeCompressFile: moving file from ${sourceFilePath} to ${targetFilePath} ${options.compress ? \"with\" : \"without\"} compress`);\n\n      if (options.compress) {\n        yield new Promise((resolve, reject) => {\n          let isCreated = false; // to avoid concurrency, the forked process which can create the file will proceed (using flags wx)\n\n          const writeStream = fs.createWriteStream(targetFilePath, {\n            mode: options.mode,\n            flags: \"wx\"\n          }) // wait until writable stream is valid before proceeding to read\n          .on(\"open\", () => {\n            isCreated = true;\n            const readStream = fs.createReadStream(sourceFilePath) // wait until readable stream is valid before piping\n            .on(\"open\", () => {\n              readStream.pipe(zlib.createGzip()).pipe(writeStream);\n            }).on(\"error\", e => {\n              debug(`moveAndMaybeCompressFile: error reading ${sourceFilePath}`, e); // manually close writable: https://nodejs.org/api/stream.html#readablepipedestination-options\n\n              writeStream.destroy(e);\n            });\n          }).on(\"finish\", () => {\n            debug(`moveAndMaybeCompressFile: finished compressing ${targetFilePath}, deleting ${sourceFilePath}`); // delete sourceFilePath\n\n            fs.unlink(sourceFilePath).then(resolve).catch(e => {\n              debug(`moveAndMaybeCompressFile: error deleting ${sourceFilePath}, truncating instead`, e); // fallback to truncate\n\n              fs.truncate(sourceFilePath).then(resolve).catch(e => {\n                debug(`moveAndMaybeCompressFile: error truncating ${sourceFilePath}`, e);\n                reject(e);\n              });\n            });\n          }).on(\"error\", e => {\n            if (!isCreated) {\n              debug(`moveAndMaybeCompressFile: error creating ${targetFilePath}`, e); // do not do anything if handled by another forked process\n\n              reject(e);\n            } else {\n              debug(`moveAndMaybeCompressFile: error writing ${targetFilePath}, deleting`, e); // delete targetFilePath (taking as nothing happened)\n\n              fs.unlink(targetFilePath).then(() => {\n                reject(e);\n              }).catch(e => {\n                debug(`moveAndMaybeCompressFile: error deleting ${targetFilePath}`, e);\n                reject(e);\n              });\n            }\n          });\n        }).catch(() => {});\n      } else {\n        debug(`moveAndMaybeCompressFile: renaming ${sourceFilePath} to ${targetFilePath}`);\n\n        try {\n          yield fs.move(sourceFilePath, targetFilePath, {\n            overwrite: true\n          });\n        } catch (e) {\n          debug(`moveAndMaybeCompressFile: error renaming ${sourceFilePath} to ${targetFilePath}`, e);\n          debug(`moveAndMaybeCompressFile: trying copy+truncate instead`);\n          yield fs.copy(sourceFilePath, targetFilePath, {\n            overwrite: true\n          });\n          yield fs.truncate(sourceFilePath);\n        }\n      }\n    }\n  });\n\n  return function moveAndMaybeCompressFile(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = moveAndMaybeCompressFile;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/streamroller/lib/moveAndMaybeCompressFile.js"],"names":["debug","require","fs","zlib","_parseOption","rawOptions","defaultOptions","mode","parseInt","compress","options","Object","assign","JSON","stringify","moveAndMaybeCompressFile","sourceFilePath","targetFilePath","pathExists","Promise","resolve","reject","isCreated","writeStream","createWriteStream","flags","on","readStream","createReadStream","pipe","createGzip","e","destroy","unlink","then","catch","truncate","move","overwrite","copy","module","exports"],"mappings":"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","sourcesContent":["const debug = require('debug')('streamroller:moveAndMaybeCompressFile');\nconst fs = require('fs-extra');\nconst zlib = require('zlib');\n\nconst _parseOption = function(rawOptions){\n  const defaultOptions = {\n    mode: parseInt(\"0600\", 8),\n    compress: false,\n  };\n  const options = Object.assign({}, defaultOptions, rawOptions);\n  debug(`_parseOption: moveAndMaybeCompressFile called with option=${JSON.stringify(options)}`);\n  return options;\n};\n\nconst moveAndMaybeCompressFile = async (\n  sourceFilePath,\n  targetFilePath,\n  options\n) => {\n  options = _parseOption(options);\n\n  if (sourceFilePath === targetFilePath) {\n    debug(`moveAndMaybeCompressFile: source and target are the same, not doing anything`);\n    return;\n  }\n\n  if (await fs.pathExists(sourceFilePath)) {\n    debug(\n      `moveAndMaybeCompressFile: moving file from ${sourceFilePath} to ${targetFilePath} ${\n        options.compress ? \"with\" : \"without\"\n      } compress`\n    );\n    if (options.compress) {\n      await new Promise((resolve, reject) => {\n        let isCreated = false;\n        // to avoid concurrency, the forked process which can create the file will proceed (using flags wx)\n        const writeStream = fs.createWriteStream(targetFilePath, {mode: options.mode, flags: \"wx\"})\n          // wait until writable stream is valid before proceeding to read\n          .on(\"open\", () => {\n            isCreated = true;\n            const readStream = fs.createReadStream(sourceFilePath)\n              // wait until readable stream is valid before piping\n              .on(\"open\", () => {\n                readStream.pipe(zlib.createGzip()).pipe(writeStream);\n              })\n              .on(\"error\", (e) => {\n                debug(`moveAndMaybeCompressFile: error reading ${sourceFilePath}`, e);\n                // manually close writable: https://nodejs.org/api/stream.html#readablepipedestination-options\n                writeStream.destroy(e);\n              });\n          })\n          .on(\"finish\", () => {\n            debug(`moveAndMaybeCompressFile: finished compressing ${targetFilePath}, deleting ${sourceFilePath}`);\n            // delete sourceFilePath\n            fs.unlink(sourceFilePath)\n              .then(resolve)\n              .catch((e) => {\n                debug(`moveAndMaybeCompressFile: error deleting ${sourceFilePath}, truncating instead`, e);\n                // fallback to truncate\n                fs.truncate(sourceFilePath)\n                  .then(resolve)\n                  .catch((e) => {\n                    debug(`moveAndMaybeCompressFile: error truncating ${sourceFilePath}`, e);\n                    reject(e);\n                  });\n              });\n          })\n          .on(\"error\", (e) => {\n            if (!isCreated) {\n              debug(`moveAndMaybeCompressFile: error creating ${targetFilePath}`, e);\n              // do not do anything if handled by another forked process\n              reject(e);\n            } else {\n              debug(`moveAndMaybeCompressFile: error writing ${targetFilePath}, deleting`, e);\n              // delete targetFilePath (taking as nothing happened)\n              fs.unlink(targetFilePath)\n                .then(() => { reject(e); })\n                .catch((e) => {\n                  debug(`moveAndMaybeCompressFile: error deleting ${targetFilePath}`, e);\n                  reject(e);\n                });\n            }\n          });\n      }).catch(() => {});\n    } else {\n      debug(`moveAndMaybeCompressFile: renaming ${sourceFilePath} to ${targetFilePath}`);\n      try {\n        await fs.move(sourceFilePath, targetFilePath, { overwrite: true });\n      } catch (e) {\n        debug(`moveAndMaybeCompressFile: error renaming ${sourceFilePath} to ${targetFilePath}`, e);\n        debug(`moveAndMaybeCompressFile: trying copy+truncate instead`);\n        await fs.copy(sourceFilePath, targetFilePath, { overwrite: true });\n        await fs.truncate(sourceFilePath);\n      }\n    }\n  }\n};\n\nmodule.exports = moveAndMaybeCompressFile;\n"]},"metadata":{},"sourceType":"script"}