{"ast":null,"code":"let path = require('path');\n\nlet extend = require('util')._extend;\n\nlet BASE_ERROR = 'Circular dependency detected:\\r\\n';\nlet PluginTitle = 'CircularDependencyPlugin';\n\nclass CircularDependencyPlugin {\n  constructor(options) {\n    this.options = extend({\n      exclude: new RegExp('$^'),\n      include: new RegExp('.*'),\n      failOnError: false,\n      allowAsyncCycles: false,\n      onDetected: false,\n      cwd: process.cwd()\n    }, options);\n  }\n\n  apply(compiler) {\n    let plugin = this;\n    let cwd = this.options.cwd;\n    compiler.hooks.compilation.tap(PluginTitle, compilation => {\n      compilation.hooks.optimizeModules.tap(PluginTitle, modules => {\n        if (plugin.options.onStart) {\n          plugin.options.onStart({\n            compilation\n          });\n        }\n\n        for (let module of modules) {\n          const shouldSkip = module.resource == null || plugin.options.exclude.test(module.resource) || !plugin.options.include.test(module.resource); // skip the module if it matches the exclude pattern\n\n          if (shouldSkip) {\n            continue;\n          }\n\n          let maybeCyclicalPathsList = this.isCyclic(module, module, {}, compilation);\n\n          if (maybeCyclicalPathsList) {\n            // allow consumers to override all behavior with onDetected\n            if (plugin.options.onDetected) {\n              try {\n                plugin.options.onDetected({\n                  module: module,\n                  paths: maybeCyclicalPathsList,\n                  compilation: compilation\n                });\n              } catch (err) {\n                compilation.errors.push(err);\n              }\n\n              continue;\n            } // mark warnings or errors on webpack compilation\n\n\n            let error = new Error(BASE_ERROR.concat(maybeCyclicalPathsList.join(' -> ')));\n\n            if (plugin.options.failOnError) {\n              compilation.errors.push(error);\n            } else {\n              compilation.warnings.push(error);\n            }\n          }\n        }\n\n        if (plugin.options.onEnd) {\n          plugin.options.onEnd({\n            compilation\n          });\n        }\n      });\n    });\n  }\n\n  isCyclic(initialModule, currentModule, seenModules, compilation) {\n    let cwd = this.options.cwd; // Add the current module to the seen modules cache\n\n    seenModules[currentModule.debugId] = true; // If the modules aren't associated to resources\n    // it's not possible to display how they are cyclical\n\n    if (!currentModule.resource || !initialModule.resource) {\n      return false;\n    } // Iterate over the current modules dependencies\n\n\n    for (let dependency of currentModule.dependencies) {\n      if (dependency.constructor && dependency.constructor.name === 'CommonJsSelfReferenceDependency') {\n        continue;\n      }\n\n      let depModule = null;\n\n      if (compilation.moduleGraph) {\n        // handle getting a module for webpack 5\n        depModule = compilation.moduleGraph.getModule(dependency);\n      } else {\n        // handle getting a module for webpack 4\n        depModule = dependency.module;\n      }\n\n      if (!depModule) {\n        continue;\n      } // ignore dependencies that don't have an associated resource\n\n\n      if (!depModule.resource) {\n        continue;\n      } // ignore dependencies that are resolved asynchronously\n\n\n      if (this.options.allowAsyncCycles && dependency.weak) {\n        continue;\n      } // the dependency was resolved to the current module due to how webpack internals\n      // setup dependencies like CommonJsSelfReferenceDependency and ModuleDecoratorDependency\n\n\n      if (currentModule === depModule) {\n        continue;\n      }\n\n      if (depModule.debugId in seenModules) {\n        if (depModule.debugId === initialModule.debugId) {\n          // Initial module has a circular dependency\n          return [path.relative(cwd, currentModule.resource), path.relative(cwd, depModule.resource)];\n        } // Found a cycle, but not for this module\n\n\n        continue;\n      }\n\n      let maybeCyclicalPathsList = this.isCyclic(initialModule, depModule, seenModules, compilation);\n\n      if (maybeCyclicalPathsList) {\n        maybeCyclicalPathsList.unshift(path.relative(cwd, currentModule.resource));\n        return maybeCyclicalPathsList;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nmodule.exports = CircularDependencyPlugin;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/circular-dependency-plugin/index.js"],"names":["path","require","extend","_extend","BASE_ERROR","PluginTitle","CircularDependencyPlugin","constructor","options","exclude","RegExp","include","failOnError","allowAsyncCycles","onDetected","cwd","process","apply","compiler","plugin","hooks","compilation","tap","optimizeModules","modules","onStart","module","shouldSkip","resource","test","maybeCyclicalPathsList","isCyclic","paths","err","errors","push","error","Error","concat","join","warnings","onEnd","initialModule","currentModule","seenModules","debugId","dependency","dependencies","name","depModule","moduleGraph","getModule","weak","relative","unshift","exports"],"mappings":"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","sourcesContent":["let path = require('path')\nlet extend = require('util')._extend\nlet BASE_ERROR = 'Circular dependency detected:\\r\\n'\nlet PluginTitle = 'CircularDependencyPlugin'\n\nclass CircularDependencyPlugin {\n  constructor(options) {\n    this.options = extend({\n      exclude: new RegExp('$^'),\n      include: new RegExp('.*'),\n      failOnError: false,\n      allowAsyncCycles: false,\n      onDetected: false,\n      cwd: process.cwd()\n    }, options)\n  }\n\n  apply(compiler) {\n    let plugin = this\n    let cwd = this.options.cwd\n\n    compiler.hooks.compilation.tap(PluginTitle, (compilation) => {\n      compilation.hooks.optimizeModules.tap(PluginTitle, (modules) => {\n        if (plugin.options.onStart) {\n          plugin.options.onStart({ compilation });\n        }\n        for (let module of modules) {\n          const shouldSkip = (\n            module.resource == null ||\n            plugin.options.exclude.test(module.resource) ||\n            !plugin.options.include.test(module.resource)\n          )\n          // skip the module if it matches the exclude pattern\n          if (shouldSkip) {\n            continue\n          }\n\n          let maybeCyclicalPathsList = this.isCyclic(module, module, {}, compilation)\n          if (maybeCyclicalPathsList) {\n            // allow consumers to override all behavior with onDetected\n            if (plugin.options.onDetected) {\n              try {\n                plugin.options.onDetected({\n                  module: module,\n                  paths: maybeCyclicalPathsList,\n                  compilation: compilation\n                })\n              } catch(err) {\n                compilation.errors.push(err)\n              }\n              continue\n            }\n\n            // mark warnings or errors on webpack compilation\n            let error = new Error(BASE_ERROR.concat(maybeCyclicalPathsList.join(' -> ')))\n            if (plugin.options.failOnError) {\n              compilation.errors.push(error)\n            } else {\n              compilation.warnings.push(error)\n            }\n          }\n        }\n        if (plugin.options.onEnd) {\n          plugin.options.onEnd({ compilation });\n        }\n      })\n    })\n  }\n\n  isCyclic(initialModule, currentModule, seenModules, compilation) {\n    let cwd = this.options.cwd\n\n    // Add the current module to the seen modules cache\n    seenModules[currentModule.debugId] = true\n\n    // If the modules aren't associated to resources\n    // it's not possible to display how they are cyclical\n    if (!currentModule.resource || !initialModule.resource) {\n      return false\n    }\n\n    // Iterate over the current modules dependencies\n    for (let dependency of currentModule.dependencies) {\n      if (\n        dependency.constructor &&\n        dependency.constructor.name === 'CommonJsSelfReferenceDependency'\n      ) {\n        continue\n      }\n\n      let depModule = null\n      if (compilation.moduleGraph) {\n        // handle getting a module for webpack 5\n        depModule = compilation.moduleGraph.getModule(dependency)\n      } else {\n        // handle getting a module for webpack 4\n        depModule = dependency.module\n      }\n\n      if (!depModule) { continue }\n      // ignore dependencies that don't have an associated resource\n      if (!depModule.resource) { continue }\n      // ignore dependencies that are resolved asynchronously\n      if (this.options.allowAsyncCycles && dependency.weak) { continue }\n      // the dependency was resolved to the current module due to how webpack internals\n      // setup dependencies like CommonJsSelfReferenceDependency and ModuleDecoratorDependency\n      if (currentModule === depModule) {\n        continue\n      }\n\n      if (depModule.debugId in seenModules) {\n        if (depModule.debugId === initialModule.debugId) {\n          // Initial module has a circular dependency\n          return [\n            path.relative(cwd, currentModule.resource),\n            path.relative(cwd, depModule.resource)\n          ]\n        }\n        // Found a cycle, but not for this module\n        continue\n      }\n\n      let maybeCyclicalPathsList = this.isCyclic(initialModule, depModule, seenModules, compilation)\n      if (maybeCyclicalPathsList) {\n        maybeCyclicalPathsList.unshift(path.relative(cwd, currentModule.resource))\n        return maybeCyclicalPathsList\n      }\n    }\n\n    return false\n  }\n}\n\nmodule.exports = CircularDependencyPlugin\n"]},"metadata":{},"sourceType":"script"}