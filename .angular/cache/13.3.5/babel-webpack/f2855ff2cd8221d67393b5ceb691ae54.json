{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar _DirectlyTransferable_value, _ArrayBufferViewTransferable_view, _Piscina_pool;\n\nconst worker_threads_1 = require(\"worker_threads\");\n\nconst events_1 = require(\"events\");\n\nconst eventemitter_asyncresource_1 = __importDefault(require(\"eventemitter-asyncresource\"));\n\nconst async_hooks_1 = require(\"async_hooks\");\n\nconst os_1 = require(\"os\");\n\nconst url_1 = require(\"url\");\n\nconst path_1 = require(\"path\");\n\nconst util_1 = require(\"util\");\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst hdr_histogram_js_1 = require(\"hdr-histogram-js\");\n\nconst perf_hooks_1 = require(\"perf_hooks\");\n\nconst hdr_histogram_percentiles_obj_1 = __importDefault(require(\"hdr-histogram-percentiles-obj\"));\n\nconst common_1 = require(\"./common\");\n\nconst package_json_1 = require(\"../package.json\");\n\nconst cpuCount = (() => {\n  try {\n    return os_1.cpus().length;\n  } catch {\n    /* istanbul ignore next */\n    return 1;\n  }\n})();\n\n;\n\nfunction onabort(abortSignal, listener) {\n  if ('addEventListener' in abortSignal) {\n    abortSignal.addEventListener('abort', listener, {\n      once: true\n    });\n  } else {\n    abortSignal.once('abort', listener);\n  }\n}\n\nclass AbortError extends Error {\n  constructor() {\n    super('The task has been aborted');\n  }\n\n  get name() {\n    return 'AbortError';\n  }\n\n}\n\nclass ArrayTaskQueue {\n  constructor() {\n    this.tasks = [];\n  }\n\n  get size() {\n    return this.tasks.length;\n  }\n\n  shift() {\n    return this.tasks.shift();\n  }\n\n  push(task) {\n    this.tasks.push(task);\n  }\n\n  remove(task) {\n    const index = this.tasks.indexOf(task);\n    assert_1.default.notStrictEqual(index, -1);\n    this.tasks.splice(index, 1);\n  }\n\n}\n\nconst kDefaultOptions = {\n  filename: null,\n  name: 'default',\n  minThreads: Math.max(cpuCount / 2, 1),\n  maxThreads: cpuCount * 1.5,\n  idleTimeout: 0,\n  maxQueue: Infinity,\n  concurrentTasksPerWorker: 1,\n  useAtomics: true,\n  taskQueue: new ArrayTaskQueue(),\n  niceIncrement: 0,\n  trackUnmanagedFds: true\n};\nconst kDefaultRunOptions = {\n  transferList: undefined,\n  filename: null,\n  signal: null,\n  name: null\n};\n\nclass DirectlyTransferable {\n  constructor(value) {\n    _DirectlyTransferable_value.set(this, void 0);\n\n    __classPrivateFieldSet(this, _DirectlyTransferable_value, value, \"f\");\n  }\n\n  get [(_DirectlyTransferable_value = new WeakMap(), common_1.kTransferable)]() {\n    return __classPrivateFieldGet(this, _DirectlyTransferable_value, \"f\");\n  }\n\n  get [common_1.kValue]() {\n    return __classPrivateFieldGet(this, _DirectlyTransferable_value, \"f\");\n  }\n\n}\n\nclass ArrayBufferViewTransferable {\n  constructor(view) {\n    _ArrayBufferViewTransferable_view.set(this, void 0);\n\n    __classPrivateFieldSet(this, _ArrayBufferViewTransferable_view, view, \"f\");\n  }\n\n  get [(_ArrayBufferViewTransferable_view = new WeakMap(), common_1.kTransferable)]() {\n    return __classPrivateFieldGet(this, _ArrayBufferViewTransferable_view, \"f\").buffer;\n  }\n\n  get [common_1.kValue]() {\n    return __classPrivateFieldGet(this, _ArrayBufferViewTransferable_view, \"f\");\n  }\n\n}\n\nlet taskIdCounter = 0;\n\nfunction maybeFileURLToPath(filename) {\n  return filename.startsWith('file:') ? url_1.fileURLToPath(new url_1.URL(filename)) : filename;\n} // Extend AsyncResource so that async relations between posting a task and\n// receiving its result are visible to diagnostic tools.\n\n\nclass TaskInfo extends async_hooks_1.AsyncResource {\n  constructor(task, transferList, filename, name, callback, abortSignal, triggerAsyncId) {\n    super('Piscina.Task', {\n      requireManualDestroy: true,\n      triggerAsyncId\n    });\n    this.abortListener = null;\n    this.workerInfo = null;\n    this.callback = callback;\n    this.task = task;\n    this.transferList = transferList; // If the task is a Transferable returned by\n    // Piscina.move(), then add it to the transferList\n    // automatically\n\n    if (common_1.isMovable(task)) {\n      // This condition should never be hit but typescript\n      // complains if we dont do the check.\n\n      /* istanbul ignore if */\n      if (this.transferList == null) {\n        this.transferList = [];\n      }\n\n      this.transferList = this.transferList.concat(task[common_1.kTransferable]);\n      this.task = task[common_1.kValue];\n    }\n\n    this.filename = filename;\n    this.name = name;\n    this.taskId = taskIdCounter++;\n    this.abortSignal = abortSignal;\n    this.created = perf_hooks_1.performance.now();\n    this.started = 0;\n  }\n\n  releaseTask() {\n    const ret = this.task;\n    this.task = null;\n    return ret;\n  }\n\n  done(err, result) {\n    this.runInAsyncScope(this.callback, null, err, result);\n    this.emitDestroy(); // `TaskInfo`s are used only once.\n    // If an abort signal was used, remove the listener from it when\n    // done to make sure we do not accidentally leak.\n\n    if (this.abortSignal && this.abortListener) {\n      if ('removeEventListener' in this.abortSignal && this.abortListener) {\n        this.abortSignal.removeEventListener('abort', this.abortListener);\n      } else {\n        this.abortSignal.off('abort', this.abortListener);\n      }\n    }\n  }\n\n  get [common_1.kQueueOptions]() {\n    return common_1.kQueueOptions in this.task ? this.task[common_1.kQueueOptions] : null;\n  }\n\n}\n\nclass AsynchronouslyCreatedResource {\n  constructor() {\n    this.onreadyListeners = [];\n  }\n\n  markAsReady() {\n    const listeners = this.onreadyListeners;\n    assert_1.default(listeners !== null);\n    this.onreadyListeners = null;\n\n    for (const listener of listeners) {\n      listener();\n    }\n  }\n\n  isReady() {\n    return this.onreadyListeners === null;\n  }\n\n  onReady(fn) {\n    if (this.onreadyListeners === null) {\n      fn(); // Zalgo is okay here.\n\n      return;\n    }\n\n    this.onreadyListeners.push(fn);\n  }\n\n}\n\nclass AsynchronouslyCreatedResourcePool {\n  constructor(maximumUsage) {\n    this.pendingItems = new Set();\n    this.readyItems = new Set();\n    this.maximumUsage = maximumUsage;\n    this.onAvailableListeners = [];\n  }\n\n  add(item) {\n    this.pendingItems.add(item);\n    item.onReady(() => {\n      /* istanbul ignore else */\n      if (this.pendingItems.has(item)) {\n        this.pendingItems.delete(item);\n        this.readyItems.add(item);\n        this.maybeAvailable(item);\n      }\n    });\n  }\n\n  delete(item) {\n    this.pendingItems.delete(item);\n    this.readyItems.delete(item);\n  }\n\n  findAvailable() {\n    let minUsage = this.maximumUsage;\n    let candidate = null;\n\n    for (const item of this.readyItems) {\n      const usage = item.currentUsage();\n      if (usage === 0) return item;\n\n      if (usage < minUsage) {\n        candidate = item;\n        minUsage = usage;\n      }\n    }\n\n    return candidate;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.pendingItems;\n    yield* this.readyItems;\n  }\n\n  get size() {\n    return this.pendingItems.size + this.readyItems.size;\n  }\n\n  maybeAvailable(item) {\n    /* istanbul ignore else */\n    if (item.currentUsage() < this.maximumUsage) {\n      for (const listener of this.onAvailableListeners) {\n        listener(item);\n      }\n    }\n  }\n\n  onAvailable(fn) {\n    this.onAvailableListeners.push(fn);\n  }\n\n}\n\nconst Errors = {\n  ThreadTermination: () => new Error('Terminating worker thread'),\n  FilenameNotProvided: () => new Error('filename must be provided to run() or in options object'),\n  TaskQueueAtLimit: () => new Error('Task queue is at limit'),\n  NoTaskQueueAvailable: () => new Error('No task queue available and all Workers are busy')\n};\n\nclass WorkerInfo extends AsynchronouslyCreatedResource {\n  constructor(worker, port, onMessage) {\n    super();\n    this.idleTimeout = null; // eslint-disable-line no-undef\n\n    this.lastSeenResponseCount = 0;\n    this.worker = worker;\n    this.port = port;\n    this.port.on('message', message => this._handleResponse(message));\n    this.onMessage = onMessage;\n    this.taskInfos = new Map();\n    this.sharedBuffer = new Int32Array(new SharedArrayBuffer(common_1.kFieldCount * Int32Array.BYTES_PER_ELEMENT));\n  }\n\n  destroy() {\n    this.worker.terminate();\n    this.port.close();\n    this.clearIdleTimeout();\n\n    for (const taskInfo of this.taskInfos.values()) {\n      taskInfo.done(Errors.ThreadTermination());\n    }\n\n    this.taskInfos.clear();\n  }\n\n  clearIdleTimeout() {\n    if (this.idleTimeout !== null) {\n      clearTimeout(this.idleTimeout);\n      this.idleTimeout = null;\n    }\n  }\n\n  ref() {\n    this.port.ref();\n    return this;\n  }\n\n  unref() {\n    // Note: Do not call ref()/unref() on the Worker itself since that may cause\n    // a hard crash, see https://github.com/nodejs/node/pull/33394.\n    this.port.unref();\n    return this;\n  }\n\n  _handleResponse(message) {\n    this.onMessage(message);\n\n    if (this.taskInfos.size === 0) {\n      // No more tasks running on this Worker means it should not keep the\n      // process running.\n      this.unref();\n    }\n  }\n\n  postTask(taskInfo) {\n    assert_1.default(!this.taskInfos.has(taskInfo.taskId));\n    const message = {\n      task: taskInfo.releaseTask(),\n      taskId: taskInfo.taskId,\n      filename: taskInfo.filename,\n      name: taskInfo.name\n    };\n\n    try {\n      this.port.postMessage(message, taskInfo.transferList);\n    } catch (err) {\n      // This would mostly happen if e.g. message contains unserializable data\n      // or transferList is invalid.\n      taskInfo.done(err);\n      return;\n    }\n\n    taskInfo.workerInfo = this;\n    this.taskInfos.set(taskInfo.taskId, taskInfo);\n    this.ref();\n    this.clearIdleTimeout(); // Inform the worker that there are new messages posted, and wake it up\n    // if it is waiting for one.\n\n    Atomics.add(this.sharedBuffer, common_1.kRequestCountField, 1);\n    Atomics.notify(this.sharedBuffer, common_1.kRequestCountField, 1);\n  }\n\n  processPendingMessages() {\n    // If we *know* that there are more messages than we have received using\n    // 'message' events yet, then try to load and handle them synchronously,\n    // without the need to wait for more expensive events on the event loop.\n    // This would usually break async tracking, but in our case, we already have\n    // the extra TaskInfo/AsyncResource layer that rectifies that situation.\n    const actualResponseCount = Atomics.load(this.sharedBuffer, common_1.kResponseCountField);\n\n    if (actualResponseCount !== this.lastSeenResponseCount) {\n      this.lastSeenResponseCount = actualResponseCount;\n      let entry;\n\n      while ((entry = worker_threads_1.receiveMessageOnPort(this.port)) !== undefined) {\n        this._handleResponse(entry.message);\n      }\n    }\n  }\n\n  isRunningAbortableTask() {\n    // If there are abortable tasks, we are running one at most per Worker.\n    if (this.taskInfos.size !== 1) return false;\n    const [[, task]] = this.taskInfos;\n    return task.abortSignal !== null;\n  }\n\n  currentUsage() {\n    if (this.isRunningAbortableTask()) return Infinity;\n    return this.taskInfos.size;\n  }\n\n}\n\nclass ThreadPool {\n  constructor(publicInterface, options) {\n    var _a;\n\n    this.skipQueue = [];\n    this.completed = 0;\n    this.start = perf_hooks_1.performance.now();\n    this.inProcessPendingMessages = false;\n    this.startingUp = false;\n    this.workerFailsDuringBootstrap = false;\n    this.publicInterface = publicInterface;\n    this.taskQueue = options.taskQueue || new ArrayTaskQueue();\n    this.runTime = hdr_histogram_js_1.build({\n      lowestDiscernibleValue: 1\n    });\n    this.waitTime = hdr_histogram_js_1.build({\n      lowestDiscernibleValue: 1\n    });\n    const filename = options.filename ? maybeFileURLToPath(options.filename) : null;\n    this.options = { ...kDefaultOptions,\n      ...options,\n      filename,\n      maxQueue: 0\n    }; // The >= and <= could be > and < but this way we get 100 % coverage ðŸ™ƒ\n\n    if (options.maxThreads !== undefined && this.options.minThreads >= options.maxThreads) {\n      this.options.minThreads = options.maxThreads;\n    }\n\n    if (options.minThreads !== undefined && this.options.maxThreads <= options.minThreads) {\n      this.options.maxThreads = options.minThreads;\n    }\n\n    if (options.maxQueue === 'auto') {\n      this.options.maxQueue = this.options.maxThreads ** 2;\n    } else {\n      this.options.maxQueue = (_a = options.maxQueue) !== null && _a !== void 0 ? _a : kDefaultOptions.maxQueue;\n    }\n\n    this.workers = new AsynchronouslyCreatedResourcePool(this.options.concurrentTasksPerWorker);\n    this.workers.onAvailable(w => this._onWorkerAvailable(w));\n    this.startingUp = true;\n\n    this._ensureMinimumWorkers();\n\n    this.startingUp = false;\n  }\n\n  _ensureMinimumWorkers() {\n    while (this.workers.size < this.options.minThreads) {\n      this._addNewWorker();\n    }\n  }\n\n  _addNewWorker() {\n    const pool = this;\n    const worker = new worker_threads_1.Worker(path_1.resolve(__dirname, 'worker.js'), {\n      env: this.options.env,\n      argv: this.options.argv,\n      execArgv: this.options.execArgv,\n      resourceLimits: this.options.resourceLimits,\n      workerData: this.options.workerData,\n      trackUnmanagedFds: this.options.trackUnmanagedFds\n    });\n    const {\n      port1,\n      port2\n    } = new worker_threads_1.MessageChannel();\n    const workerInfo = new WorkerInfo(worker, port1, onMessage);\n\n    if (this.startingUp) {\n      // There is no point in waiting for the initial set of Workers to indicate\n      // that they are ready, we just mark them as such from the start.\n      workerInfo.markAsReady();\n    }\n\n    const message = {\n      filename: this.options.filename,\n      name: this.options.name,\n      port: port2,\n      sharedBuffer: workerInfo.sharedBuffer,\n      useAtomics: this.options.useAtomics,\n      niceIncrement: this.options.niceIncrement\n    };\n    worker.postMessage(message, [port2]);\n\n    function onMessage(message) {\n      const {\n        taskId,\n        result\n      } = message; // In case of success: Call the callback that was passed to `runTask`,\n      // remove the `TaskInfo` associated with the Worker, which marks it as\n      // free again.\n\n      const taskInfo = workerInfo.taskInfos.get(taskId);\n      workerInfo.taskInfos.delete(taskId);\n      pool.workers.maybeAvailable(workerInfo);\n      /* istanbul ignore if */\n\n      if (taskInfo === undefined) {\n        const err = new Error(`Unexpected message from Worker: ${util_1.inspect(message)}`);\n        pool.publicInterface.emit('error', err);\n      } else {\n        taskInfo.done(message.error, result);\n      }\n\n      pool._processPendingMessages();\n    }\n\n    worker.on('message', message => {\n      if (message.ready === true) {\n        if (workerInfo.currentUsage() === 0) {\n          workerInfo.unref();\n        }\n\n        if (!workerInfo.isReady()) {\n          workerInfo.markAsReady();\n        }\n\n        return;\n      }\n\n      worker.emit('error', new Error(`Unexpected message on Worker: ${util_1.inspect(message)}`));\n    });\n    worker.on('error', err => {\n      // Work around the bug in https://github.com/nodejs/node/pull/33394\n      worker.ref = () => {}; // In case of an uncaught exception: Call the callback that was passed to\n      // `postTask` with the error, or emit an 'error' event if there is none.\n\n\n      const taskInfos = [...workerInfo.taskInfos.values()];\n      workerInfo.taskInfos.clear(); // Remove the worker from the list and potentially start a new Worker to\n      // replace the current one.\n\n      this._removeWorker(workerInfo);\n\n      if (workerInfo.isReady() && !this.workerFailsDuringBootstrap) {\n        this._ensureMinimumWorkers();\n      } else {\n        // Do not start new workers over and over if they already fail during\n        // bootstrap, there's no point.\n        this.workerFailsDuringBootstrap = true;\n      }\n\n      if (taskInfos.length > 0) {\n        for (const taskInfo of taskInfos) {\n          taskInfo.done(err, null);\n        }\n      } else {\n        this.publicInterface.emit('error', err);\n      }\n    });\n    worker.unref();\n    port1.on('close', () => {\n      // The port is only closed if the Worker stops for some reason, but we\n      // always .unref() the Worker itself. We want to receive e.g. 'error'\n      // events on it, so we ref it once we know it's going to exit anyway.\n      worker.ref();\n    });\n    this.workers.add(workerInfo);\n  }\n\n  _processPendingMessages() {\n    if (this.inProcessPendingMessages || !this.options.useAtomics) {\n      return;\n    }\n\n    this.inProcessPendingMessages = true;\n\n    try {\n      for (const workerInfo of this.workers) {\n        workerInfo.processPendingMessages();\n      }\n    } finally {\n      this.inProcessPendingMessages = false;\n    }\n  }\n\n  _removeWorker(workerInfo) {\n    workerInfo.destroy();\n    this.workers.delete(workerInfo);\n  }\n\n  _onWorkerAvailable(workerInfo) {\n    while ((this.taskQueue.size > 0 || this.skipQueue.length > 0) && workerInfo.currentUsage() < this.options.concurrentTasksPerWorker) {\n      // The skipQueue will have tasks that we previously shifted off\n      // the task queue but had to skip over... we have to make sure\n      // we drain that before we drain the taskQueue.\n      const taskInfo = this.skipQueue.shift() || this.taskQueue.shift(); // If the task has an abortSignal and the worker has any other\n      // tasks, we cannot distribute the task to it. Skip for now.\n\n      if (taskInfo.abortSignal && workerInfo.taskInfos.size > 0) {\n        this.skipQueue.push(taskInfo);\n        break;\n      }\n\n      const now = perf_hooks_1.performance.now();\n      this.waitTime.recordValue(now - taskInfo.created);\n      taskInfo.started = now;\n      workerInfo.postTask(taskInfo);\n\n      this._maybeDrain();\n\n      return;\n    }\n\n    if (workerInfo.taskInfos.size === 0 && this.workers.size > this.options.minThreads) {\n      workerInfo.idleTimeout = setTimeout(() => {\n        assert_1.default.strictEqual(workerInfo.taskInfos.size, 0);\n\n        if (this.workers.size > this.options.minThreads) {\n          this._removeWorker(workerInfo);\n        }\n      }, this.options.idleTimeout).unref();\n    }\n  }\n\n  runTask(task, options) {\n    let {\n      filename,\n      name\n    } = options;\n    const {\n      transferList = [],\n      signal = null\n    } = options;\n\n    if (filename == null) {\n      filename = this.options.filename;\n    }\n\n    if (name == null) {\n      name = this.options.name;\n    }\n\n    if (typeof filename !== 'string') {\n      return Promise.reject(Errors.FilenameNotProvided());\n    }\n\n    filename = maybeFileURLToPath(filename);\n    let resolve;\n    let reject; // eslint-disable-next-line\n\n    const ret = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    const taskInfo = new TaskInfo(task, transferList, filename, name, (err, result) => {\n      this.completed++;\n\n      if (taskInfo.started) {\n        this.runTime.recordValue(perf_hooks_1.performance.now() - taskInfo.started);\n      }\n\n      if (err !== null) {\n        reject(err);\n      } else {\n        resolve(result);\n      }\n    }, signal, this.publicInterface.asyncResource.asyncId());\n\n    if (signal !== null) {\n      // If the AbortSignal has an aborted property and it's truthy,\n      // reject immediately.\n      if (signal.aborted) {\n        return Promise.reject(new AbortError());\n      }\n\n      taskInfo.abortListener = () => {\n        // Call reject() first to make sure we always reject with the AbortError\n        // if the task is aborted, not with an Error from the possible\n        // thread termination below.\n        reject(new AbortError());\n\n        if (taskInfo.workerInfo !== null) {\n          // Already running: We cancel the Worker this is running on.\n          this._removeWorker(taskInfo.workerInfo);\n\n          this._ensureMinimumWorkers();\n        } else {\n          // Not yet running: Remove it from the queue.\n          this.taskQueue.remove(taskInfo);\n        }\n      };\n\n      onabort(signal, taskInfo.abortListener);\n    } // If there is a task queue, there's no point in looking for an available\n    // Worker thread. Add this task to the queue, if possible.\n\n\n    if (this.taskQueue.size > 0) {\n      const totalCapacity = this.options.maxQueue + this.pendingCapacity();\n\n      if (this.taskQueue.size >= totalCapacity) {\n        if (this.options.maxQueue === 0) {\n          return Promise.reject(Errors.NoTaskQueueAvailable());\n        } else {\n          return Promise.reject(Errors.TaskQueueAtLimit());\n        }\n      } else {\n        if (this.workers.size < this.options.maxThreads) {\n          this._addNewWorker();\n        }\n\n        this.taskQueue.push(taskInfo);\n      }\n\n      return ret;\n    } // Look for a Worker with a minimum number of tasks it is currently running.\n\n\n    let workerInfo = this.workers.findAvailable(); // If we want the ability to abort this task, use only workers that have\n    // no running tasks.\n\n    if (workerInfo !== null && workerInfo.currentUsage() > 0 && signal) {\n      workerInfo = null;\n    } // If no Worker was found, or that Worker was handling another task in some\n    // way, and we still have the ability to spawn new threads, do so.\n\n\n    let waitingForNewWorker = false;\n\n    if ((workerInfo === null || workerInfo.currentUsage() > 0) && this.workers.size < this.options.maxThreads) {\n      this._addNewWorker();\n\n      waitingForNewWorker = true;\n    } // If no Worker is found, try to put the task into the queue.\n\n\n    if (workerInfo === null) {\n      if (this.options.maxQueue <= 0 && !waitingForNewWorker) {\n        return Promise.reject(Errors.NoTaskQueueAvailable());\n      } else {\n        this.taskQueue.push(taskInfo);\n      }\n\n      return ret;\n    } // TODO(addaleax): Clean up the waitTime/runTime recording.\n\n\n    const now = perf_hooks_1.performance.now();\n    this.waitTime.recordValue(now - taskInfo.created);\n    taskInfo.started = now;\n    workerInfo.postTask(taskInfo);\n\n    this._maybeDrain();\n\n    return ret;\n  }\n\n  pendingCapacity() {\n    return this.workers.pendingItems.size * this.options.concurrentTasksPerWorker;\n  }\n\n  _maybeDrain() {\n    if (this.taskQueue.size === 0 && this.skipQueue.length === 0) {\n      this.publicInterface.emit('drain');\n    }\n  }\n\n  destroy() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      while (_this.skipQueue.length > 0) {\n        const taskInfo = _this.skipQueue.shift();\n\n        taskInfo.done(new Error('Terminating worker thread'));\n      }\n\n      while (_this.taskQueue.size > 0) {\n        const taskInfo = _this.taskQueue.shift();\n\n        taskInfo.done(new Error('Terminating worker thread'));\n      }\n\n      const exitEvents = [];\n\n      while (_this.workers.size > 0) {\n        const [workerInfo] = _this.workers;\n        exitEvents.push(events_1.once(workerInfo.worker, 'exit'));\n\n        _this._removeWorker(workerInfo);\n      }\n\n      yield Promise.all(exitEvents);\n    })();\n  }\n\n}\n\nclass Piscina extends eventemitter_asyncresource_1.default {\n  constructor(options = {}) {\n    super({ ...options,\n      name: 'Piscina'\n    });\n\n    _Piscina_pool.set(this, void 0);\n\n    if (typeof options.filename !== 'string' && options.filename != null) {\n      throw new TypeError('options.filename must be a string or null');\n    }\n\n    if (typeof options.name !== 'string' && options.name != null) {\n      throw new TypeError('options.name must be a string or null');\n    }\n\n    if (options.minThreads !== undefined && (typeof options.minThreads !== 'number' || options.minThreads < 0)) {\n      throw new TypeError('options.minThreads must be a non-negative integer');\n    }\n\n    if (options.maxThreads !== undefined && (typeof options.maxThreads !== 'number' || options.maxThreads < 1)) {\n      throw new TypeError('options.maxThreads must be a positive integer');\n    }\n\n    if (options.minThreads !== undefined && options.maxThreads !== undefined && options.minThreads > options.maxThreads) {\n      throw new RangeError('options.minThreads and options.maxThreads must not conflict');\n    }\n\n    if (options.idleTimeout !== undefined && (typeof options.idleTimeout !== 'number' || options.idleTimeout < 0)) {\n      throw new TypeError('options.idleTimeout must be a non-negative integer');\n    }\n\n    if (options.maxQueue !== undefined && options.maxQueue !== 'auto' && (typeof options.maxQueue !== 'number' || options.maxQueue < 0)) {\n      throw new TypeError('options.maxQueue must be a non-negative integer');\n    }\n\n    if (options.concurrentTasksPerWorker !== undefined && (typeof options.concurrentTasksPerWorker !== 'number' || options.concurrentTasksPerWorker < 1)) {\n      throw new TypeError('options.concurrentTasksPerWorker must be a positive integer');\n    }\n\n    if (options.useAtomics !== undefined && typeof options.useAtomics !== 'boolean') {\n      throw new TypeError('options.useAtomics must be a boolean value');\n    }\n\n    if (options.resourceLimits !== undefined && (typeof options.resourceLimits !== 'object' || options.resourceLimits === null)) {\n      throw new TypeError('options.resourceLimits must be an object');\n    }\n\n    if (options.taskQueue !== undefined && !common_1.isTaskQueue(options.taskQueue)) {\n      throw new TypeError('options.taskQueue must be a TaskQueue object');\n    }\n\n    if (options.niceIncrement !== undefined && (typeof options.niceIncrement !== 'number' || options.niceIncrement < 0)) {\n      throw new TypeError('options.niceIncrement must be a non-negative integer');\n    }\n\n    if (options.trackUnmanagedFds !== undefined && typeof options.trackUnmanagedFds !== 'boolean') {\n      throw new TypeError('options.trackUnmanagedFds must be a boolean value');\n    }\n\n    __classPrivateFieldSet(this, _Piscina_pool, new ThreadPool(this, options), \"f\");\n  }\n  /** @deprecated Use run(task, options) instead **/\n\n\n  runTask(task, transferList, filename, signal) {\n    // If transferList is a string or AbortSignal, shift it.\n    if (typeof transferList === 'object' && !Array.isArray(transferList) || typeof transferList === 'string') {\n      signal = filename;\n      filename = transferList;\n      transferList = undefined;\n    } // If filename is an AbortSignal, shift it.\n\n\n    if (typeof filename === 'object' && !Array.isArray(filename)) {\n      signal = filename;\n      filename = undefined;\n    }\n\n    if (transferList !== undefined && !Array.isArray(transferList)) {\n      return Promise.reject(new TypeError('transferList argument must be an Array'));\n    }\n\n    if (filename !== undefined && typeof filename !== 'string') {\n      return Promise.reject(new TypeError('filename argument must be a string'));\n    }\n\n    if (signal !== undefined && typeof signal !== 'object') {\n      return Promise.reject(new TypeError('signal argument must be an object'));\n    }\n\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTask(task, {\n      transferList,\n      filename: filename || null,\n      name: 'default',\n      signal: signal || null\n    });\n  }\n\n  run(task, options = kDefaultRunOptions) {\n    if (options === null || typeof options !== 'object') {\n      return Promise.reject(new TypeError('options must be an object'));\n    }\n\n    const {\n      transferList,\n      filename,\n      name,\n      signal\n    } = options;\n\n    if (transferList !== undefined && !Array.isArray(transferList)) {\n      return Promise.reject(new TypeError('transferList argument must be an Array'));\n    }\n\n    if (filename != null && typeof filename !== 'string') {\n      return Promise.reject(new TypeError('filename argument must be a string'));\n    }\n\n    if (name != null && typeof name !== 'string') {\n      return Promise.reject(new TypeError('name argument must be a string'));\n    }\n\n    if (signal != null && typeof signal !== 'object') {\n      return Promise.reject(new TypeError('signal argument must be an object'));\n    }\n\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTask(task, {\n      transferList,\n      filename,\n      name,\n      signal\n    });\n  }\n\n  destroy() {\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").destroy();\n  }\n\n  get options() {\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").options;\n  }\n\n  get threads() {\n    const ret = [];\n\n    for (const workerInfo of __classPrivateFieldGet(this, _Piscina_pool, \"f\").workers) {\n      ret.push(workerInfo.worker);\n    }\n\n    return ret;\n  }\n\n  get queueSize() {\n    const pool = __classPrivateFieldGet(this, _Piscina_pool, \"f\");\n\n    return Math.max(pool.taskQueue.size - pool.pendingCapacity(), 0);\n  }\n\n  get completed() {\n    return __classPrivateFieldGet(this, _Piscina_pool, \"f\").completed;\n  }\n\n  get waitTime() {\n    const result = hdr_histogram_percentiles_obj_1.default.histAsObj(__classPrivateFieldGet(this, _Piscina_pool, \"f\").waitTime);\n    return hdr_histogram_percentiles_obj_1.default.addPercentiles(__classPrivateFieldGet(this, _Piscina_pool, \"f\").waitTime, result);\n  }\n\n  get runTime() {\n    const result = hdr_histogram_percentiles_obj_1.default.histAsObj(__classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime);\n    return hdr_histogram_percentiles_obj_1.default.addPercentiles(__classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime, result);\n  }\n\n  get utilization() {\n    // The capacity is the max compute time capacity of the\n    // pool to this point in time as determined by the length\n    // of time the pool has been running multiplied by the\n    // maximum number of threads.\n    const capacity = this.duration * __classPrivateFieldGet(this, _Piscina_pool, \"f\").options.maxThreads;\n\n    const totalMeanRuntime = __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime.mean * __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime.totalCount; // We calculate the appoximate pool utilization by multiplying\n    // the mean run time of all tasks by the number of runtime\n    // samples taken and dividing that by the capacity. The\n    // theory here is that capacity represents the absolute upper\n    // limit of compute time this pool could ever attain (but\n    // never will for a variety of reasons. Multiplying the\n    // mean run time by the number of tasks sampled yields an\n    // approximation of the realized compute time. The utilization\n    // then becomes a point-in-time measure of how active the\n    // pool is.\n\n\n    return totalMeanRuntime / capacity;\n  }\n\n  get duration() {\n    return perf_hooks_1.performance.now() - __classPrivateFieldGet(this, _Piscina_pool, \"f\").start;\n  }\n\n  static get isWorkerThread() {\n    return common_1.commonState.isWorkerThread;\n  }\n\n  static get workerData() {\n    return common_1.commonState.workerData;\n  }\n\n  static get version() {\n    return package_json_1.version;\n  }\n\n  static get Piscina() {\n    return Piscina;\n  }\n\n  static move(val) {\n    if (val != null && typeof val === 'object' && typeof val !== 'function') {\n      if (!common_1.isTransferable(val)) {\n        if (util_1.types.isArrayBufferView(val)) {\n          val = new ArrayBufferViewTransferable(val);\n        } else {\n          val = new DirectlyTransferable(val);\n        }\n      }\n\n      common_1.markMovable(val);\n    }\n\n    return val;\n  }\n\n  static get transferableSymbol() {\n    return common_1.kTransferable;\n  }\n\n  static get valueSymbol() {\n    return common_1.kValue;\n  }\n\n  static get queueOptionsSymbol() {\n    return common_1.kQueueOptions;\n  }\n\n}\n\n_Piscina_pool = new WeakMap();\nmodule.exports = Piscina;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/piscina/dist/src/index.js"],"names":["__classPrivateFieldSet","receiver","state","value","kind","f","TypeError","has","call","set","__classPrivateFieldGet","get","__importDefault","mod","__esModule","_DirectlyTransferable_value","_ArrayBufferViewTransferable_view","_Piscina_pool","worker_threads_1","require","events_1","eventemitter_asyncresource_1","async_hooks_1","os_1","url_1","path_1","util_1","assert_1","hdr_histogram_js_1","perf_hooks_1","hdr_histogram_percentiles_obj_1","common_1","package_json_1","cpuCount","cpus","length","onabort","abortSignal","listener","addEventListener","once","AbortError","Error","constructor","name","ArrayTaskQueue","tasks","size","shift","push","task","remove","index","indexOf","default","notStrictEqual","splice","kDefaultOptions","filename","minThreads","Math","max","maxThreads","idleTimeout","maxQueue","Infinity","concurrentTasksPerWorker","useAtomics","taskQueue","niceIncrement","trackUnmanagedFds","kDefaultRunOptions","transferList","undefined","signal","DirectlyTransferable","WeakMap","kTransferable","kValue","ArrayBufferViewTransferable","view","buffer","taskIdCounter","maybeFileURLToPath","startsWith","fileURLToPath","URL","TaskInfo","AsyncResource","callback","triggerAsyncId","requireManualDestroy","abortListener","workerInfo","isMovable","concat","taskId","created","performance","now","started","releaseTask","ret","done","err","result","runInAsyncScope","emitDestroy","removeEventListener","off","kQueueOptions","AsynchronouslyCreatedResource","onreadyListeners","markAsReady","listeners","isReady","onReady","fn","AsynchronouslyCreatedResourcePool","maximumUsage","pendingItems","Set","readyItems","onAvailableListeners","add","item","delete","maybeAvailable","findAvailable","minUsage","candidate","usage","currentUsage","Symbol","iterator","onAvailable","Errors","ThreadTermination","FilenameNotProvided","TaskQueueAtLimit","NoTaskQueueAvailable","WorkerInfo","worker","port","onMessage","lastSeenResponseCount","on","message","_handleResponse","taskInfos","Map","sharedBuffer","Int32Array","SharedArrayBuffer","kFieldCount","BYTES_PER_ELEMENT","destroy","terminate","close","clearIdleTimeout","taskInfo","values","clear","clearTimeout","ref","unref","postTask","postMessage","Atomics","kRequestCountField","notify","processPendingMessages","actualResponseCount","load","kResponseCountField","entry","receiveMessageOnPort","isRunningAbortableTask","ThreadPool","publicInterface","options","_a","skipQueue","completed","start","inProcessPendingMessages","startingUp","workerFailsDuringBootstrap","runTime","build","lowestDiscernibleValue","waitTime","workers","w","_onWorkerAvailable","_ensureMinimumWorkers","_addNewWorker","pool","Worker","resolve","__dirname","env","argv","execArgv","resourceLimits","workerData","port1","port2","MessageChannel","inspect","emit","error","_processPendingMessages","ready","_removeWorker","recordValue","_maybeDrain","setTimeout","strictEqual","runTask","Promise","reject","res","rej","asyncResource","asyncId","aborted","totalCapacity","pendingCapacity","waitingForNewWorker","exitEvents","all","Piscina","RangeError","isTaskQueue","Array","isArray","run","threads","queueSize","histAsObj","addPercentiles","utilization","capacity","duration","totalMeanRuntime","mean","totalCount","isWorkerThread","commonState","version","move","val","isTransferable","types","isArrayBufferView","markMovable","transferableSymbol","valueSymbol","queueOptionsSymbol","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _DirectlyTransferable_value, _ArrayBufferViewTransferable_view, _Piscina_pool;\nconst worker_threads_1 = require(\"worker_threads\");\nconst events_1 = require(\"events\");\nconst eventemitter_asyncresource_1 = __importDefault(require(\"eventemitter-asyncresource\"));\nconst async_hooks_1 = require(\"async_hooks\");\nconst os_1 = require(\"os\");\nconst url_1 = require(\"url\");\nconst path_1 = require(\"path\");\nconst util_1 = require(\"util\");\nconst assert_1 = __importDefault(require(\"assert\"));\nconst hdr_histogram_js_1 = require(\"hdr-histogram-js\");\nconst perf_hooks_1 = require(\"perf_hooks\");\nconst hdr_histogram_percentiles_obj_1 = __importDefault(require(\"hdr-histogram-percentiles-obj\"));\nconst common_1 = require(\"./common\");\nconst package_json_1 = require(\"../package.json\");\nconst cpuCount = (() => {\n    try {\n        return os_1.cpus().length;\n    }\n    catch {\n        /* istanbul ignore next */\n        return 1;\n    }\n})();\n;\nfunction onabort(abortSignal, listener) {\n    if ('addEventListener' in abortSignal) {\n        abortSignal.addEventListener('abort', listener, { once: true });\n    }\n    else {\n        abortSignal.once('abort', listener);\n    }\n}\nclass AbortError extends Error {\n    constructor() {\n        super('The task has been aborted');\n    }\n    get name() { return 'AbortError'; }\n}\nclass ArrayTaskQueue {\n    constructor() {\n        this.tasks = [];\n    }\n    get size() { return this.tasks.length; }\n    shift() {\n        return this.tasks.shift();\n    }\n    push(task) {\n        this.tasks.push(task);\n    }\n    remove(task) {\n        const index = this.tasks.indexOf(task);\n        assert_1.default.notStrictEqual(index, -1);\n        this.tasks.splice(index, 1);\n    }\n}\nconst kDefaultOptions = {\n    filename: null,\n    name: 'default',\n    minThreads: Math.max(cpuCount / 2, 1),\n    maxThreads: cpuCount * 1.5,\n    idleTimeout: 0,\n    maxQueue: Infinity,\n    concurrentTasksPerWorker: 1,\n    useAtomics: true,\n    taskQueue: new ArrayTaskQueue(),\n    niceIncrement: 0,\n    trackUnmanagedFds: true\n};\nconst kDefaultRunOptions = {\n    transferList: undefined,\n    filename: null,\n    signal: null,\n    name: null\n};\nclass DirectlyTransferable {\n    constructor(value) {\n        _DirectlyTransferable_value.set(this, void 0);\n        __classPrivateFieldSet(this, _DirectlyTransferable_value, value, \"f\");\n    }\n    get [(_DirectlyTransferable_value = new WeakMap(), common_1.kTransferable)]() { return __classPrivateFieldGet(this, _DirectlyTransferable_value, \"f\"); }\n    get [common_1.kValue]() { return __classPrivateFieldGet(this, _DirectlyTransferable_value, \"f\"); }\n}\nclass ArrayBufferViewTransferable {\n    constructor(view) {\n        _ArrayBufferViewTransferable_view.set(this, void 0);\n        __classPrivateFieldSet(this, _ArrayBufferViewTransferable_view, view, \"f\");\n    }\n    get [(_ArrayBufferViewTransferable_view = new WeakMap(), common_1.kTransferable)]() { return __classPrivateFieldGet(this, _ArrayBufferViewTransferable_view, \"f\").buffer; }\n    get [common_1.kValue]() { return __classPrivateFieldGet(this, _ArrayBufferViewTransferable_view, \"f\"); }\n}\nlet taskIdCounter = 0;\nfunction maybeFileURLToPath(filename) {\n    return filename.startsWith('file:')\n        ? url_1.fileURLToPath(new url_1.URL(filename))\n        : filename;\n}\n// Extend AsyncResource so that async relations between posting a task and\n// receiving its result are visible to diagnostic tools.\nclass TaskInfo extends async_hooks_1.AsyncResource {\n    constructor(task, transferList, filename, name, callback, abortSignal, triggerAsyncId) {\n        super('Piscina.Task', { requireManualDestroy: true, triggerAsyncId });\n        this.abortListener = null;\n        this.workerInfo = null;\n        this.callback = callback;\n        this.task = task;\n        this.transferList = transferList;\n        // If the task is a Transferable returned by\n        // Piscina.move(), then add it to the transferList\n        // automatically\n        if (common_1.isMovable(task)) {\n            // This condition should never be hit but typescript\n            // complains if we dont do the check.\n            /* istanbul ignore if */\n            if (this.transferList == null) {\n                this.transferList = [];\n            }\n            this.transferList =\n                this.transferList.concat(task[common_1.kTransferable]);\n            this.task = task[common_1.kValue];\n        }\n        this.filename = filename;\n        this.name = name;\n        this.taskId = taskIdCounter++;\n        this.abortSignal = abortSignal;\n        this.created = perf_hooks_1.performance.now();\n        this.started = 0;\n    }\n    releaseTask() {\n        const ret = this.task;\n        this.task = null;\n        return ret;\n    }\n    done(err, result) {\n        this.runInAsyncScope(this.callback, null, err, result);\n        this.emitDestroy(); // `TaskInfo`s are used only once.\n        // If an abort signal was used, remove the listener from it when\n        // done to make sure we do not accidentally leak.\n        if (this.abortSignal && this.abortListener) {\n            if ('removeEventListener' in this.abortSignal && this.abortListener) {\n                this.abortSignal.removeEventListener('abort', this.abortListener);\n            }\n            else {\n                this.abortSignal.off('abort', this.abortListener);\n            }\n        }\n    }\n    get [common_1.kQueueOptions]() {\n        return common_1.kQueueOptions in this.task ? this.task[common_1.kQueueOptions] : null;\n    }\n}\nclass AsynchronouslyCreatedResource {\n    constructor() {\n        this.onreadyListeners = [];\n    }\n    markAsReady() {\n        const listeners = this.onreadyListeners;\n        assert_1.default(listeners !== null);\n        this.onreadyListeners = null;\n        for (const listener of listeners) {\n            listener();\n        }\n    }\n    isReady() {\n        return this.onreadyListeners === null;\n    }\n    onReady(fn) {\n        if (this.onreadyListeners === null) {\n            fn(); // Zalgo is okay here.\n            return;\n        }\n        this.onreadyListeners.push(fn);\n    }\n}\nclass AsynchronouslyCreatedResourcePool {\n    constructor(maximumUsage) {\n        this.pendingItems = new Set();\n        this.readyItems = new Set();\n        this.maximumUsage = maximumUsage;\n        this.onAvailableListeners = [];\n    }\n    add(item) {\n        this.pendingItems.add(item);\n        item.onReady(() => {\n            /* istanbul ignore else */\n            if (this.pendingItems.has(item)) {\n                this.pendingItems.delete(item);\n                this.readyItems.add(item);\n                this.maybeAvailable(item);\n            }\n        });\n    }\n    delete(item) {\n        this.pendingItems.delete(item);\n        this.readyItems.delete(item);\n    }\n    findAvailable() {\n        let minUsage = this.maximumUsage;\n        let candidate = null;\n        for (const item of this.readyItems) {\n            const usage = item.currentUsage();\n            if (usage === 0)\n                return item;\n            if (usage < minUsage) {\n                candidate = item;\n                minUsage = usage;\n            }\n        }\n        return candidate;\n    }\n    *[Symbol.iterator]() {\n        yield* this.pendingItems;\n        yield* this.readyItems;\n    }\n    get size() {\n        return this.pendingItems.size + this.readyItems.size;\n    }\n    maybeAvailable(item) {\n        /* istanbul ignore else */\n        if (item.currentUsage() < this.maximumUsage) {\n            for (const listener of this.onAvailableListeners) {\n                listener(item);\n            }\n        }\n    }\n    onAvailable(fn) {\n        this.onAvailableListeners.push(fn);\n    }\n}\nconst Errors = {\n    ThreadTermination: () => new Error('Terminating worker thread'),\n    FilenameNotProvided: () => new Error('filename must be provided to run() or in options object'),\n    TaskQueueAtLimit: () => new Error('Task queue is at limit'),\n    NoTaskQueueAvailable: () => new Error('No task queue available and all Workers are busy')\n};\nclass WorkerInfo extends AsynchronouslyCreatedResource {\n    constructor(worker, port, onMessage) {\n        super();\n        this.idleTimeout = null; // eslint-disable-line no-undef\n        this.lastSeenResponseCount = 0;\n        this.worker = worker;\n        this.port = port;\n        this.port.on('message', (message) => this._handleResponse(message));\n        this.onMessage = onMessage;\n        this.taskInfos = new Map();\n        this.sharedBuffer = new Int32Array(new SharedArrayBuffer(common_1.kFieldCount * Int32Array.BYTES_PER_ELEMENT));\n    }\n    destroy() {\n        this.worker.terminate();\n        this.port.close();\n        this.clearIdleTimeout();\n        for (const taskInfo of this.taskInfos.values()) {\n            taskInfo.done(Errors.ThreadTermination());\n        }\n        this.taskInfos.clear();\n    }\n    clearIdleTimeout() {\n        if (this.idleTimeout !== null) {\n            clearTimeout(this.idleTimeout);\n            this.idleTimeout = null;\n        }\n    }\n    ref() {\n        this.port.ref();\n        return this;\n    }\n    unref() {\n        // Note: Do not call ref()/unref() on the Worker itself since that may cause\n        // a hard crash, see https://github.com/nodejs/node/pull/33394.\n        this.port.unref();\n        return this;\n    }\n    _handleResponse(message) {\n        this.onMessage(message);\n        if (this.taskInfos.size === 0) {\n            // No more tasks running on this Worker means it should not keep the\n            // process running.\n            this.unref();\n        }\n    }\n    postTask(taskInfo) {\n        assert_1.default(!this.taskInfos.has(taskInfo.taskId));\n        const message = {\n            task: taskInfo.releaseTask(),\n            taskId: taskInfo.taskId,\n            filename: taskInfo.filename,\n            name: taskInfo.name\n        };\n        try {\n            this.port.postMessage(message, taskInfo.transferList);\n        }\n        catch (err) {\n            // This would mostly happen if e.g. message contains unserializable data\n            // or transferList is invalid.\n            taskInfo.done(err);\n            return;\n        }\n        taskInfo.workerInfo = this;\n        this.taskInfos.set(taskInfo.taskId, taskInfo);\n        this.ref();\n        this.clearIdleTimeout();\n        // Inform the worker that there are new messages posted, and wake it up\n        // if it is waiting for one.\n        Atomics.add(this.sharedBuffer, common_1.kRequestCountField, 1);\n        Atomics.notify(this.sharedBuffer, common_1.kRequestCountField, 1);\n    }\n    processPendingMessages() {\n        // If we *know* that there are more messages than we have received using\n        // 'message' events yet, then try to load and handle them synchronously,\n        // without the need to wait for more expensive events on the event loop.\n        // This would usually break async tracking, but in our case, we already have\n        // the extra TaskInfo/AsyncResource layer that rectifies that situation.\n        const actualResponseCount = Atomics.load(this.sharedBuffer, common_1.kResponseCountField);\n        if (actualResponseCount !== this.lastSeenResponseCount) {\n            this.lastSeenResponseCount = actualResponseCount;\n            let entry;\n            while ((entry = worker_threads_1.receiveMessageOnPort(this.port)) !== undefined) {\n                this._handleResponse(entry.message);\n            }\n        }\n    }\n    isRunningAbortableTask() {\n        // If there are abortable tasks, we are running one at most per Worker.\n        if (this.taskInfos.size !== 1)\n            return false;\n        const [[, task]] = this.taskInfos;\n        return task.abortSignal !== null;\n    }\n    currentUsage() {\n        if (this.isRunningAbortableTask())\n            return Infinity;\n        return this.taskInfos.size;\n    }\n}\nclass ThreadPool {\n    constructor(publicInterface, options) {\n        var _a;\n        this.skipQueue = [];\n        this.completed = 0;\n        this.start = perf_hooks_1.performance.now();\n        this.inProcessPendingMessages = false;\n        this.startingUp = false;\n        this.workerFailsDuringBootstrap = false;\n        this.publicInterface = publicInterface;\n        this.taskQueue = options.taskQueue || new ArrayTaskQueue();\n        this.runTime = hdr_histogram_js_1.build({ lowestDiscernibleValue: 1 });\n        this.waitTime = hdr_histogram_js_1.build({ lowestDiscernibleValue: 1 });\n        const filename = options.filename ? maybeFileURLToPath(options.filename) : null;\n        this.options = { ...kDefaultOptions, ...options, filename, maxQueue: 0 };\n        // The >= and <= could be > and < but this way we get 100 % coverage ðŸ™ƒ\n        if (options.maxThreads !== undefined &&\n            this.options.minThreads >= options.maxThreads) {\n            this.options.minThreads = options.maxThreads;\n        }\n        if (options.minThreads !== undefined &&\n            this.options.maxThreads <= options.minThreads) {\n            this.options.maxThreads = options.minThreads;\n        }\n        if (options.maxQueue === 'auto') {\n            this.options.maxQueue = this.options.maxThreads ** 2;\n        }\n        else {\n            this.options.maxQueue = (_a = options.maxQueue) !== null && _a !== void 0 ? _a : kDefaultOptions.maxQueue;\n        }\n        this.workers = new AsynchronouslyCreatedResourcePool(this.options.concurrentTasksPerWorker);\n        this.workers.onAvailable((w) => this._onWorkerAvailable(w));\n        this.startingUp = true;\n        this._ensureMinimumWorkers();\n        this.startingUp = false;\n    }\n    _ensureMinimumWorkers() {\n        while (this.workers.size < this.options.minThreads) {\n            this._addNewWorker();\n        }\n    }\n    _addNewWorker() {\n        const pool = this;\n        const worker = new worker_threads_1.Worker(path_1.resolve(__dirname, 'worker.js'), {\n            env: this.options.env,\n            argv: this.options.argv,\n            execArgv: this.options.execArgv,\n            resourceLimits: this.options.resourceLimits,\n            workerData: this.options.workerData,\n            trackUnmanagedFds: this.options.trackUnmanagedFds\n        });\n        const { port1, port2 } = new worker_threads_1.MessageChannel();\n        const workerInfo = new WorkerInfo(worker, port1, onMessage);\n        if (this.startingUp) {\n            // There is no point in waiting for the initial set of Workers to indicate\n            // that they are ready, we just mark them as such from the start.\n            workerInfo.markAsReady();\n        }\n        const message = {\n            filename: this.options.filename,\n            name: this.options.name,\n            port: port2,\n            sharedBuffer: workerInfo.sharedBuffer,\n            useAtomics: this.options.useAtomics,\n            niceIncrement: this.options.niceIncrement\n        };\n        worker.postMessage(message, [port2]);\n        function onMessage(message) {\n            const { taskId, result } = message;\n            // In case of success: Call the callback that was passed to `runTask`,\n            // remove the `TaskInfo` associated with the Worker, which marks it as\n            // free again.\n            const taskInfo = workerInfo.taskInfos.get(taskId);\n            workerInfo.taskInfos.delete(taskId);\n            pool.workers.maybeAvailable(workerInfo);\n            /* istanbul ignore if */\n            if (taskInfo === undefined) {\n                const err = new Error(`Unexpected message from Worker: ${util_1.inspect(message)}`);\n                pool.publicInterface.emit('error', err);\n            }\n            else {\n                taskInfo.done(message.error, result);\n            }\n            pool._processPendingMessages();\n        }\n        worker.on('message', (message) => {\n            if (message.ready === true) {\n                if (workerInfo.currentUsage() === 0) {\n                    workerInfo.unref();\n                }\n                if (!workerInfo.isReady()) {\n                    workerInfo.markAsReady();\n                }\n                return;\n            }\n            worker.emit('error', new Error(`Unexpected message on Worker: ${util_1.inspect(message)}`));\n        });\n        worker.on('error', (err) => {\n            // Work around the bug in https://github.com/nodejs/node/pull/33394\n            worker.ref = () => { };\n            // In case of an uncaught exception: Call the callback that was passed to\n            // `postTask` with the error, or emit an 'error' event if there is none.\n            const taskInfos = [...workerInfo.taskInfos.values()];\n            workerInfo.taskInfos.clear();\n            // Remove the worker from the list and potentially start a new Worker to\n            // replace the current one.\n            this._removeWorker(workerInfo);\n            if (workerInfo.isReady() && !this.workerFailsDuringBootstrap) {\n                this._ensureMinimumWorkers();\n            }\n            else {\n                // Do not start new workers over and over if they already fail during\n                // bootstrap, there's no point.\n                this.workerFailsDuringBootstrap = true;\n            }\n            if (taskInfos.length > 0) {\n                for (const taskInfo of taskInfos) {\n                    taskInfo.done(err, null);\n                }\n            }\n            else {\n                this.publicInterface.emit('error', err);\n            }\n        });\n        worker.unref();\n        port1.on('close', () => {\n            // The port is only closed if the Worker stops for some reason, but we\n            // always .unref() the Worker itself. We want to receive e.g. 'error'\n            // events on it, so we ref it once we know it's going to exit anyway.\n            worker.ref();\n        });\n        this.workers.add(workerInfo);\n    }\n    _processPendingMessages() {\n        if (this.inProcessPendingMessages || !this.options.useAtomics) {\n            return;\n        }\n        this.inProcessPendingMessages = true;\n        try {\n            for (const workerInfo of this.workers) {\n                workerInfo.processPendingMessages();\n            }\n        }\n        finally {\n            this.inProcessPendingMessages = false;\n        }\n    }\n    _removeWorker(workerInfo) {\n        workerInfo.destroy();\n        this.workers.delete(workerInfo);\n    }\n    _onWorkerAvailable(workerInfo) {\n        while ((this.taskQueue.size > 0 || this.skipQueue.length > 0) &&\n            workerInfo.currentUsage() < this.options.concurrentTasksPerWorker) {\n            // The skipQueue will have tasks that we previously shifted off\n            // the task queue but had to skip over... we have to make sure\n            // we drain that before we drain the taskQueue.\n            const taskInfo = this.skipQueue.shift() ||\n                this.taskQueue.shift();\n            // If the task has an abortSignal and the worker has any other\n            // tasks, we cannot distribute the task to it. Skip for now.\n            if (taskInfo.abortSignal && workerInfo.taskInfos.size > 0) {\n                this.skipQueue.push(taskInfo);\n                break;\n            }\n            const now = perf_hooks_1.performance.now();\n            this.waitTime.recordValue(now - taskInfo.created);\n            taskInfo.started = now;\n            workerInfo.postTask(taskInfo);\n            this._maybeDrain();\n            return;\n        }\n        if (workerInfo.taskInfos.size === 0 &&\n            this.workers.size > this.options.minThreads) {\n            workerInfo.idleTimeout = setTimeout(() => {\n                assert_1.default.strictEqual(workerInfo.taskInfos.size, 0);\n                if (this.workers.size > this.options.minThreads) {\n                    this._removeWorker(workerInfo);\n                }\n            }, this.options.idleTimeout).unref();\n        }\n    }\n    runTask(task, options) {\n        let { filename, name } = options;\n        const { transferList = [], signal = null } = options;\n        if (filename == null) {\n            filename = this.options.filename;\n        }\n        if (name == null) {\n            name = this.options.name;\n        }\n        if (typeof filename !== 'string') {\n            return Promise.reject(Errors.FilenameNotProvided());\n        }\n        filename = maybeFileURLToPath(filename);\n        let resolve;\n        let reject;\n        // eslint-disable-next-line\n        const ret = new Promise((res, rej) => { resolve = res; reject = rej; });\n        const taskInfo = new TaskInfo(task, transferList, filename, name, (err, result) => {\n            this.completed++;\n            if (taskInfo.started) {\n                this.runTime.recordValue(perf_hooks_1.performance.now() - taskInfo.started);\n            }\n            if (err !== null) {\n                reject(err);\n            }\n            else {\n                resolve(result);\n            }\n        }, signal, this.publicInterface.asyncResource.asyncId());\n        if (signal !== null) {\n            // If the AbortSignal has an aborted property and it's truthy,\n            // reject immediately.\n            if (signal.aborted) {\n                return Promise.reject(new AbortError());\n            }\n            taskInfo.abortListener = () => {\n                // Call reject() first to make sure we always reject with the AbortError\n                // if the task is aborted, not with an Error from the possible\n                // thread termination below.\n                reject(new AbortError());\n                if (taskInfo.workerInfo !== null) {\n                    // Already running: We cancel the Worker this is running on.\n                    this._removeWorker(taskInfo.workerInfo);\n                    this._ensureMinimumWorkers();\n                }\n                else {\n                    // Not yet running: Remove it from the queue.\n                    this.taskQueue.remove(taskInfo);\n                }\n            };\n            onabort(signal, taskInfo.abortListener);\n        }\n        // If there is a task queue, there's no point in looking for an available\n        // Worker thread. Add this task to the queue, if possible.\n        if (this.taskQueue.size > 0) {\n            const totalCapacity = this.options.maxQueue + this.pendingCapacity();\n            if (this.taskQueue.size >= totalCapacity) {\n                if (this.options.maxQueue === 0) {\n                    return Promise.reject(Errors.NoTaskQueueAvailable());\n                }\n                else {\n                    return Promise.reject(Errors.TaskQueueAtLimit());\n                }\n            }\n            else {\n                if (this.workers.size < this.options.maxThreads) {\n                    this._addNewWorker();\n                }\n                this.taskQueue.push(taskInfo);\n            }\n            return ret;\n        }\n        // Look for a Worker with a minimum number of tasks it is currently running.\n        let workerInfo = this.workers.findAvailable();\n        // If we want the ability to abort this task, use only workers that have\n        // no running tasks.\n        if (workerInfo !== null && workerInfo.currentUsage() > 0 && signal) {\n            workerInfo = null;\n        }\n        // If no Worker was found, or that Worker was handling another task in some\n        // way, and we still have the ability to spawn new threads, do so.\n        let waitingForNewWorker = false;\n        if ((workerInfo === null || workerInfo.currentUsage() > 0) &&\n            this.workers.size < this.options.maxThreads) {\n            this._addNewWorker();\n            waitingForNewWorker = true;\n        }\n        // If no Worker is found, try to put the task into the queue.\n        if (workerInfo === null) {\n            if (this.options.maxQueue <= 0 && !waitingForNewWorker) {\n                return Promise.reject(Errors.NoTaskQueueAvailable());\n            }\n            else {\n                this.taskQueue.push(taskInfo);\n            }\n            return ret;\n        }\n        // TODO(addaleax): Clean up the waitTime/runTime recording.\n        const now = perf_hooks_1.performance.now();\n        this.waitTime.recordValue(now - taskInfo.created);\n        taskInfo.started = now;\n        workerInfo.postTask(taskInfo);\n        this._maybeDrain();\n        return ret;\n    }\n    pendingCapacity() {\n        return this.workers.pendingItems.size *\n            this.options.concurrentTasksPerWorker;\n    }\n    _maybeDrain() {\n        if (this.taskQueue.size === 0 && this.skipQueue.length === 0) {\n            this.publicInterface.emit('drain');\n        }\n    }\n    async destroy() {\n        while (this.skipQueue.length > 0) {\n            const taskInfo = this.skipQueue.shift();\n            taskInfo.done(new Error('Terminating worker thread'));\n        }\n        while (this.taskQueue.size > 0) {\n            const taskInfo = this.taskQueue.shift();\n            taskInfo.done(new Error('Terminating worker thread'));\n        }\n        const exitEvents = [];\n        while (this.workers.size > 0) {\n            const [workerInfo] = this.workers;\n            exitEvents.push(events_1.once(workerInfo.worker, 'exit'));\n            this._removeWorker(workerInfo);\n        }\n        await Promise.all(exitEvents);\n    }\n}\nclass Piscina extends eventemitter_asyncresource_1.default {\n    constructor(options = {}) {\n        super({ ...options, name: 'Piscina' });\n        _Piscina_pool.set(this, void 0);\n        if (typeof options.filename !== 'string' && options.filename != null) {\n            throw new TypeError('options.filename must be a string or null');\n        }\n        if (typeof options.name !== 'string' && options.name != null) {\n            throw new TypeError('options.name must be a string or null');\n        }\n        if (options.minThreads !== undefined &&\n            (typeof options.minThreads !== 'number' || options.minThreads < 0)) {\n            throw new TypeError('options.minThreads must be a non-negative integer');\n        }\n        if (options.maxThreads !== undefined &&\n            (typeof options.maxThreads !== 'number' || options.maxThreads < 1)) {\n            throw new TypeError('options.maxThreads must be a positive integer');\n        }\n        if (options.minThreads !== undefined && options.maxThreads !== undefined &&\n            options.minThreads > options.maxThreads) {\n            throw new RangeError('options.minThreads and options.maxThreads must not conflict');\n        }\n        if (options.idleTimeout !== undefined &&\n            (typeof options.idleTimeout !== 'number' || options.idleTimeout < 0)) {\n            throw new TypeError('options.idleTimeout must be a non-negative integer');\n        }\n        if (options.maxQueue !== undefined &&\n            options.maxQueue !== 'auto' &&\n            (typeof options.maxQueue !== 'number' || options.maxQueue < 0)) {\n            throw new TypeError('options.maxQueue must be a non-negative integer');\n        }\n        if (options.concurrentTasksPerWorker !== undefined &&\n            (typeof options.concurrentTasksPerWorker !== 'number' ||\n                options.concurrentTasksPerWorker < 1)) {\n            throw new TypeError('options.concurrentTasksPerWorker must be a positive integer');\n        }\n        if (options.useAtomics !== undefined &&\n            typeof options.useAtomics !== 'boolean') {\n            throw new TypeError('options.useAtomics must be a boolean value');\n        }\n        if (options.resourceLimits !== undefined &&\n            (typeof options.resourceLimits !== 'object' ||\n                options.resourceLimits === null)) {\n            throw new TypeError('options.resourceLimits must be an object');\n        }\n        if (options.taskQueue !== undefined && !common_1.isTaskQueue(options.taskQueue)) {\n            throw new TypeError('options.taskQueue must be a TaskQueue object');\n        }\n        if (options.niceIncrement !== undefined &&\n            (typeof options.niceIncrement !== 'number' || options.niceIncrement < 0)) {\n            throw new TypeError('options.niceIncrement must be a non-negative integer');\n        }\n        if (options.trackUnmanagedFds !== undefined &&\n            typeof options.trackUnmanagedFds !== 'boolean') {\n            throw new TypeError('options.trackUnmanagedFds must be a boolean value');\n        }\n        __classPrivateFieldSet(this, _Piscina_pool, new ThreadPool(this, options), \"f\");\n    }\n    /** @deprecated Use run(task, options) instead **/\n    runTask(task, transferList, filename, signal) {\n        // If transferList is a string or AbortSignal, shift it.\n        if ((typeof transferList === 'object' && !Array.isArray(transferList)) ||\n            typeof transferList === 'string') {\n            signal = filename;\n            filename = transferList;\n            transferList = undefined;\n        }\n        // If filename is an AbortSignal, shift it.\n        if (typeof filename === 'object' && !Array.isArray(filename)) {\n            signal = filename;\n            filename = undefined;\n        }\n        if (transferList !== undefined && !Array.isArray(transferList)) {\n            return Promise.reject(new TypeError('transferList argument must be an Array'));\n        }\n        if (filename !== undefined && typeof filename !== 'string') {\n            return Promise.reject(new TypeError('filename argument must be a string'));\n        }\n        if (signal !== undefined && typeof signal !== 'object') {\n            return Promise.reject(new TypeError('signal argument must be an object'));\n        }\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTask(task, {\n            transferList,\n            filename: filename || null,\n            name: 'default',\n            signal: signal || null\n        });\n    }\n    run(task, options = kDefaultRunOptions) {\n        if (options === null || typeof options !== 'object') {\n            return Promise.reject(new TypeError('options must be an object'));\n        }\n        const { transferList, filename, name, signal } = options;\n        if (transferList !== undefined && !Array.isArray(transferList)) {\n            return Promise.reject(new TypeError('transferList argument must be an Array'));\n        }\n        if (filename != null && typeof filename !== 'string') {\n            return Promise.reject(new TypeError('filename argument must be a string'));\n        }\n        if (name != null && typeof name !== 'string') {\n            return Promise.reject(new TypeError('name argument must be a string'));\n        }\n        if (signal != null && typeof signal !== 'object') {\n            return Promise.reject(new TypeError('signal argument must be an object'));\n        }\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTask(task, { transferList, filename, name, signal });\n    }\n    destroy() {\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").destroy();\n    }\n    get options() {\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").options;\n    }\n    get threads() {\n        const ret = [];\n        for (const workerInfo of __classPrivateFieldGet(this, _Piscina_pool, \"f\").workers) {\n            ret.push(workerInfo.worker);\n        }\n        return ret;\n    }\n    get queueSize() {\n        const pool = __classPrivateFieldGet(this, _Piscina_pool, \"f\");\n        return Math.max(pool.taskQueue.size - pool.pendingCapacity(), 0);\n    }\n    get completed() {\n        return __classPrivateFieldGet(this, _Piscina_pool, \"f\").completed;\n    }\n    get waitTime() {\n        const result = hdr_histogram_percentiles_obj_1.default.histAsObj(__classPrivateFieldGet(this, _Piscina_pool, \"f\").waitTime);\n        return hdr_histogram_percentiles_obj_1.default.addPercentiles(__classPrivateFieldGet(this, _Piscina_pool, \"f\").waitTime, result);\n    }\n    get runTime() {\n        const result = hdr_histogram_percentiles_obj_1.default.histAsObj(__classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime);\n        return hdr_histogram_percentiles_obj_1.default.addPercentiles(__classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime, result);\n    }\n    get utilization() {\n        // The capacity is the max compute time capacity of the\n        // pool to this point in time as determined by the length\n        // of time the pool has been running multiplied by the\n        // maximum number of threads.\n        const capacity = this.duration * __classPrivateFieldGet(this, _Piscina_pool, \"f\").options.maxThreads;\n        const totalMeanRuntime = __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime.mean *\n            __classPrivateFieldGet(this, _Piscina_pool, \"f\").runTime.totalCount;\n        // We calculate the appoximate pool utilization by multiplying\n        // the mean run time of all tasks by the number of runtime\n        // samples taken and dividing that by the capacity. The\n        // theory here is that capacity represents the absolute upper\n        // limit of compute time this pool could ever attain (but\n        // never will for a variety of reasons. Multiplying the\n        // mean run time by the number of tasks sampled yields an\n        // approximation of the realized compute time. The utilization\n        // then becomes a point-in-time measure of how active the\n        // pool is.\n        return totalMeanRuntime / capacity;\n    }\n    get duration() {\n        return perf_hooks_1.performance.now() - __classPrivateFieldGet(this, _Piscina_pool, \"f\").start;\n    }\n    static get isWorkerThread() {\n        return common_1.commonState.isWorkerThread;\n    }\n    static get workerData() {\n        return common_1.commonState.workerData;\n    }\n    static get version() {\n        return package_json_1.version;\n    }\n    static get Piscina() {\n        return Piscina;\n    }\n    static move(val) {\n        if (val != null && typeof val === 'object' && typeof val !== 'function') {\n            if (!common_1.isTransferable(val)) {\n                if (util_1.types.isArrayBufferView(val)) {\n                    val = new ArrayBufferViewTransferable(val);\n                }\n                else {\n                    val = new DirectlyTransferable(val);\n                }\n            }\n            common_1.markMovable(val);\n        }\n        return val;\n    }\n    static get transferableSymbol() { return common_1.kTransferable; }\n    static get valueSymbol() { return common_1.kValue; }\n    static get queueOptionsSymbol() { return common_1.kQueueOptions; }\n}\n_Piscina_pool = new WeakMap();\nmodule.exports = Piscina;\n"]},"metadata":{},"sourceType":"script"}