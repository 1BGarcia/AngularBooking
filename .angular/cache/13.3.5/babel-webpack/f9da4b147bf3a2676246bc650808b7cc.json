{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _postcssValueParser = _interopRequireDefault(require(\"postcss-value-parser\"));\n\nvar _utils = require(\"../utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction parseNode(atRule, key, options) {\n  // Convert only top-level @import\n  if (atRule.parent.type !== \"root\") {\n    return;\n  }\n\n  if (atRule.raws && atRule.raws.afterName && atRule.raws.afterName.trim().length > 0) {\n    const lastCommentIndex = atRule.raws.afterName.lastIndexOf(\"/*\");\n    const matched = atRule.raws.afterName.slice(lastCommentIndex).match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);\n\n    if (matched && matched[2] === \"true\") {\n      return;\n    }\n  }\n\n  const prevNode = atRule.prev();\n\n  if (prevNode && prevNode.type === \"comment\") {\n    const matched = prevNode.text.match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);\n\n    if (matched && matched[2] === \"true\") {\n      return;\n    }\n  } // Nodes do not exists - `@import url('http://') :root {}`\n\n\n  if (atRule.nodes) {\n    const error = new Error(\"It looks like you didn't end your @import statement correctly. Child nodes are attached to it.\");\n    error.node = atRule;\n    throw error;\n  }\n\n  const rawParams = atRule.raws && atRule.raws[key] && typeof atRule.raws[key].raw !== \"undefined\" ? atRule.raws[key].raw : atRule[key];\n  const {\n    nodes: paramsNodes\n  } = (0, _postcssValueParser.default)(rawParams); // No nodes - `@import ;`\n  // Invalid type - `@import foo-bar;`\n\n  if (paramsNodes.length === 0 || paramsNodes[0].type !== \"string\" && paramsNodes[0].type !== \"function\") {\n    const error = new Error(`Unable to find uri in \"${atRule.toString()}\"`);\n    error.node = atRule;\n    throw error;\n  }\n\n  let isStringValue;\n  let url;\n\n  if (paramsNodes[0].type === \"string\") {\n    isStringValue = true;\n    url = paramsNodes[0].value;\n  } else {\n    // Invalid function - `@import nourl(test.css);`\n    if (paramsNodes[0].value.toLowerCase() !== \"url\") {\n      const error = new Error(`Unable to find uri in \"${atRule.toString()}\"`);\n      error.node = atRule;\n      throw error;\n    }\n\n    isStringValue = paramsNodes[0].nodes.length !== 0 && paramsNodes[0].nodes[0].type === \"string\";\n    url = isStringValue ? paramsNodes[0].nodes[0].value : _postcssValueParser.default.stringify(paramsNodes[0].nodes);\n  }\n\n  url = (0, _utils.normalizeUrl)(url, isStringValue);\n  const {\n    requestable,\n    needResolve\n  } = (0, _utils.isURLRequestable)(url, options);\n  let prefix;\n\n  if (requestable && needResolve) {\n    const queryParts = url.split(\"!\");\n\n    if (queryParts.length > 1) {\n      url = queryParts.pop();\n      prefix = queryParts.join(\"!\");\n    }\n  } // Empty url - `@import \"\";` or `@import url();`\n\n\n  if (url.trim().length === 0) {\n    const error = new Error(`Unable to find uri in \"${atRule.toString()}\"`);\n    error.node = atRule;\n    throw error;\n  }\n\n  const additionalNodes = paramsNodes.slice(1);\n  let supports;\n  let layer;\n  let media;\n\n  if (additionalNodes.length > 0) {\n    let nodes = [];\n\n    for (const node of additionalNodes) {\n      nodes.push(node);\n      const isLayerFunction = node.type === \"function\" && node.value.toLowerCase() === \"layer\";\n      const isLayerWord = node.type === \"word\" && node.value.toLowerCase() === \"layer\";\n\n      if (isLayerFunction || isLayerWord) {\n        if (isLayerFunction) {\n          nodes.splice(nodes.length - 1, 1, ...node.nodes);\n        } else {\n          nodes.splice(nodes.length - 1, 1, {\n            type: \"string\",\n            value: \"\",\n            unclosed: false\n          });\n        }\n\n        layer = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();\n        nodes = [];\n      } else if (node.type === \"function\" && node.value.toLowerCase() === \"supports\") {\n        nodes.splice(nodes.length - 1, 1, ...node.nodes);\n        supports = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();\n        nodes = [];\n      }\n    }\n\n    if (nodes.length > 0) {\n      media = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();\n    }\n  } // eslint-disable-next-line consistent-return\n\n\n  return {\n    atRule,\n    prefix,\n    url,\n    layer,\n    supports,\n    media,\n    requestable,\n    needResolve\n  };\n}\n\nconst plugin = (options = {}) => {\n  return {\n    postcssPlugin: \"postcss-import-parser\",\n\n    prepare(result) {\n      const parsedAtRules = [];\n      return {\n        AtRule: {\n          import(atRule) {\n            if (options.isCSSStyleSheet) {\n              options.loaderContext.emitError(new Error(atRule.error(\"'@import' rules are not allowed here and will not be processed\").message));\n              return;\n            }\n\n            const {\n              isSupportDataURL,\n              isSupportAbsoluteURL\n            } = options;\n            let parsedAtRule;\n\n            try {\n              parsedAtRule = parseNode(atRule, \"params\", {\n                isSupportAbsoluteURL,\n                isSupportDataURL\n              });\n            } catch (error) {\n              result.warn(error.message, {\n                node: error.node\n              });\n            }\n\n            if (!parsedAtRule) {\n              return;\n            }\n\n            parsedAtRules.push(parsedAtRule);\n          }\n\n        },\n\n        OnceExit() {\n          return _asyncToGenerator(function* () {\n            if (parsedAtRules.length === 0) {\n              return;\n            }\n\n            const {\n              loaderContext\n            } = options;\n            const resolver = loaderContext.getResolve({\n              dependencyType: \"css\",\n              conditionNames: [\"style\"],\n              mainFields: [\"css\", \"style\", \"main\", \"...\"],\n              mainFiles: [\"index\", \"...\"],\n              extensions: [\".css\", \"...\"],\n              preferRelative: true\n            });\n            const resolvedAtRules = yield Promise.all(parsedAtRules.map( /*#__PURE__*/function () {\n              var _ref = _asyncToGenerator(function* (parsedAtRule) {\n                const {\n                  atRule,\n                  requestable,\n                  needResolve,\n                  prefix,\n                  url,\n                  layer,\n                  supports,\n                  media\n                } = parsedAtRule;\n\n                if (options.filter) {\n                  const needKeep = yield options.filter(url, media, loaderContext.resourcePath, supports, layer);\n\n                  if (!needKeep) {\n                    return;\n                  }\n                }\n\n                if (needResolve) {\n                  const request = (0, _utils.requestify)(url, loaderContext.rootContext);\n                  const resolvedUrl = yield (0, _utils.resolveRequests)(resolver, loaderContext.context, [...new Set([request, url])]);\n\n                  if (!resolvedUrl) {\n                    return;\n                  }\n\n                  if (resolvedUrl === loaderContext.resourcePath) {\n                    atRule.remove();\n                    return;\n                  }\n\n                  atRule.remove(); // eslint-disable-next-line consistent-return\n\n                  return {\n                    url: resolvedUrl,\n                    layer,\n                    supports,\n                    media,\n                    prefix,\n                    requestable\n                  };\n                }\n\n                atRule.remove(); // eslint-disable-next-line consistent-return\n\n                return {\n                  url,\n                  layer,\n                  supports,\n                  media,\n                  prefix,\n                  requestable\n                };\n              });\n\n              return function (_x) {\n                return _ref.apply(this, arguments);\n              };\n            }()));\n            const urlToNameMap = new Map();\n\n            for (let index = 0; index <= resolvedAtRules.length - 1; index++) {\n              const resolvedAtRule = resolvedAtRules[index];\n\n              if (!resolvedAtRule) {\n                // eslint-disable-next-line no-continue\n                continue;\n              }\n\n              const {\n                url,\n                requestable,\n                layer,\n                supports,\n                media\n              } = resolvedAtRule;\n\n              if (!requestable) {\n                options.api.push({\n                  url,\n                  layer,\n                  supports,\n                  media,\n                  index\n                }); // eslint-disable-next-line no-continue\n\n                continue;\n              }\n\n              const {\n                prefix\n              } = resolvedAtRule;\n              const newUrl = prefix ? `${prefix}!${url}` : url;\n              let importName = urlToNameMap.get(newUrl);\n\n              if (!importName) {\n                importName = `___CSS_LOADER_AT_RULE_IMPORT_${urlToNameMap.size}___`;\n                urlToNameMap.set(newUrl, importName);\n                options.imports.push({\n                  type: \"rule_import\",\n                  importName,\n                  url: options.urlHandler(newUrl),\n                  index\n                });\n              }\n\n              options.api.push({\n                importName,\n                layer,\n                supports,\n                media,\n                index\n              });\n            }\n          })();\n        }\n\n      };\n    }\n\n  };\n};\n\nplugin.postcss = true;\nvar _default = plugin;\nexports.default = _default;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/css-loader/dist/plugins/postcss-import-parser.js"],"names":["Object","defineProperty","exports","value","default","_postcssValueParser","_interopRequireDefault","require","_utils","obj","__esModule","parseNode","atRule","key","options","parent","type","raws","afterName","trim","length","lastCommentIndex","lastIndexOf","matched","slice","match","WEBPACK_IGNORE_COMMENT_REGEXP","prevNode","prev","text","nodes","error","Error","node","rawParams","raw","paramsNodes","toString","isStringValue","url","toLowerCase","stringify","normalizeUrl","requestable","needResolve","isURLRequestable","prefix","queryParts","split","pop","join","additionalNodes","supports","layer","media","push","isLayerFunction","isLayerWord","splice","unclosed","plugin","postcssPlugin","prepare","result","parsedAtRules","AtRule","import","isCSSStyleSheet","loaderContext","emitError","message","isSupportDataURL","isSupportAbsoluteURL","parsedAtRule","warn","OnceExit","resolver","getResolve","dependencyType","conditionNames","mainFields","mainFiles","extensions","preferRelative","resolvedAtRules","Promise","all","map","filter","needKeep","resourcePath","request","requestify","rootContext","resolvedUrl","resolveRequests","context","Set","remove","urlToNameMap","Map","index","resolvedAtRule","api","newUrl","importName","get","size","set","imports","urlHandler","postcss","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _postcssValueParser = _interopRequireDefault(require(\"postcss-value-parser\"));\n\nvar _utils = require(\"../utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parseNode(atRule, key, options) {\n  // Convert only top-level @import\n  if (atRule.parent.type !== \"root\") {\n    return;\n  }\n\n  if (atRule.raws && atRule.raws.afterName && atRule.raws.afterName.trim().length > 0) {\n    const lastCommentIndex = atRule.raws.afterName.lastIndexOf(\"/*\");\n    const matched = atRule.raws.afterName.slice(lastCommentIndex).match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);\n\n    if (matched && matched[2] === \"true\") {\n      return;\n    }\n  }\n\n  const prevNode = atRule.prev();\n\n  if (prevNode && prevNode.type === \"comment\") {\n    const matched = prevNode.text.match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);\n\n    if (matched && matched[2] === \"true\") {\n      return;\n    }\n  } // Nodes do not exists - `@import url('http://') :root {}`\n\n\n  if (atRule.nodes) {\n    const error = new Error(\"It looks like you didn't end your @import statement correctly. Child nodes are attached to it.\");\n    error.node = atRule;\n    throw error;\n  }\n\n  const rawParams = atRule.raws && atRule.raws[key] && typeof atRule.raws[key].raw !== \"undefined\" ? atRule.raws[key].raw : atRule[key];\n  const {\n    nodes: paramsNodes\n  } = (0, _postcssValueParser.default)(rawParams); // No nodes - `@import ;`\n  // Invalid type - `@import foo-bar;`\n\n  if (paramsNodes.length === 0 || paramsNodes[0].type !== \"string\" && paramsNodes[0].type !== \"function\") {\n    const error = new Error(`Unable to find uri in \"${atRule.toString()}\"`);\n    error.node = atRule;\n    throw error;\n  }\n\n  let isStringValue;\n  let url;\n\n  if (paramsNodes[0].type === \"string\") {\n    isStringValue = true;\n    url = paramsNodes[0].value;\n  } else {\n    // Invalid function - `@import nourl(test.css);`\n    if (paramsNodes[0].value.toLowerCase() !== \"url\") {\n      const error = new Error(`Unable to find uri in \"${atRule.toString()}\"`);\n      error.node = atRule;\n      throw error;\n    }\n\n    isStringValue = paramsNodes[0].nodes.length !== 0 && paramsNodes[0].nodes[0].type === \"string\";\n    url = isStringValue ? paramsNodes[0].nodes[0].value : _postcssValueParser.default.stringify(paramsNodes[0].nodes);\n  }\n\n  url = (0, _utils.normalizeUrl)(url, isStringValue);\n  const {\n    requestable,\n    needResolve\n  } = (0, _utils.isURLRequestable)(url, options);\n  let prefix;\n\n  if (requestable && needResolve) {\n    const queryParts = url.split(\"!\");\n\n    if (queryParts.length > 1) {\n      url = queryParts.pop();\n      prefix = queryParts.join(\"!\");\n    }\n  } // Empty url - `@import \"\";` or `@import url();`\n\n\n  if (url.trim().length === 0) {\n    const error = new Error(`Unable to find uri in \"${atRule.toString()}\"`);\n    error.node = atRule;\n    throw error;\n  }\n\n  const additionalNodes = paramsNodes.slice(1);\n  let supports;\n  let layer;\n  let media;\n\n  if (additionalNodes.length > 0) {\n    let nodes = [];\n\n    for (const node of additionalNodes) {\n      nodes.push(node);\n      const isLayerFunction = node.type === \"function\" && node.value.toLowerCase() === \"layer\";\n      const isLayerWord = node.type === \"word\" && node.value.toLowerCase() === \"layer\";\n\n      if (isLayerFunction || isLayerWord) {\n        if (isLayerFunction) {\n          nodes.splice(nodes.length - 1, 1, ...node.nodes);\n        } else {\n          nodes.splice(nodes.length - 1, 1, {\n            type: \"string\",\n            value: \"\",\n            unclosed: false\n          });\n        }\n\n        layer = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();\n        nodes = [];\n      } else if (node.type === \"function\" && node.value.toLowerCase() === \"supports\") {\n        nodes.splice(nodes.length - 1, 1, ...node.nodes);\n        supports = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();\n        nodes = [];\n      }\n    }\n\n    if (nodes.length > 0) {\n      media = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();\n    }\n  } // eslint-disable-next-line consistent-return\n\n\n  return {\n    atRule,\n    prefix,\n    url,\n    layer,\n    supports,\n    media,\n    requestable,\n    needResolve\n  };\n}\n\nconst plugin = (options = {}) => {\n  return {\n    postcssPlugin: \"postcss-import-parser\",\n\n    prepare(result) {\n      const parsedAtRules = [];\n      return {\n        AtRule: {\n          import(atRule) {\n            if (options.isCSSStyleSheet) {\n              options.loaderContext.emitError(new Error(atRule.error(\"'@import' rules are not allowed here and will not be processed\").message));\n              return;\n            }\n\n            const {\n              isSupportDataURL,\n              isSupportAbsoluteURL\n            } = options;\n            let parsedAtRule;\n\n            try {\n              parsedAtRule = parseNode(atRule, \"params\", {\n                isSupportAbsoluteURL,\n                isSupportDataURL\n              });\n            } catch (error) {\n              result.warn(error.message, {\n                node: error.node\n              });\n            }\n\n            if (!parsedAtRule) {\n              return;\n            }\n\n            parsedAtRules.push(parsedAtRule);\n          }\n\n        },\n\n        async OnceExit() {\n          if (parsedAtRules.length === 0) {\n            return;\n          }\n\n          const {\n            loaderContext\n          } = options;\n          const resolver = loaderContext.getResolve({\n            dependencyType: \"css\",\n            conditionNames: [\"style\"],\n            mainFields: [\"css\", \"style\", \"main\", \"...\"],\n            mainFiles: [\"index\", \"...\"],\n            extensions: [\".css\", \"...\"],\n            preferRelative: true\n          });\n          const resolvedAtRules = await Promise.all(parsedAtRules.map(async parsedAtRule => {\n            const {\n              atRule,\n              requestable,\n              needResolve,\n              prefix,\n              url,\n              layer,\n              supports,\n              media\n            } = parsedAtRule;\n\n            if (options.filter) {\n              const needKeep = await options.filter(url, media, loaderContext.resourcePath, supports, layer);\n\n              if (!needKeep) {\n                return;\n              }\n            }\n\n            if (needResolve) {\n              const request = (0, _utils.requestify)(url, loaderContext.rootContext);\n              const resolvedUrl = await (0, _utils.resolveRequests)(resolver, loaderContext.context, [...new Set([request, url])]);\n\n              if (!resolvedUrl) {\n                return;\n              }\n\n              if (resolvedUrl === loaderContext.resourcePath) {\n                atRule.remove();\n                return;\n              }\n\n              atRule.remove(); // eslint-disable-next-line consistent-return\n\n              return {\n                url: resolvedUrl,\n                layer,\n                supports,\n                media,\n                prefix,\n                requestable\n              };\n            }\n\n            atRule.remove(); // eslint-disable-next-line consistent-return\n\n            return {\n              url,\n              layer,\n              supports,\n              media,\n              prefix,\n              requestable\n            };\n          }));\n          const urlToNameMap = new Map();\n\n          for (let index = 0; index <= resolvedAtRules.length - 1; index++) {\n            const resolvedAtRule = resolvedAtRules[index];\n\n            if (!resolvedAtRule) {\n              // eslint-disable-next-line no-continue\n              continue;\n            }\n\n            const {\n              url,\n              requestable,\n              layer,\n              supports,\n              media\n            } = resolvedAtRule;\n\n            if (!requestable) {\n              options.api.push({\n                url,\n                layer,\n                supports,\n                media,\n                index\n              }); // eslint-disable-next-line no-continue\n\n              continue;\n            }\n\n            const {\n              prefix\n            } = resolvedAtRule;\n            const newUrl = prefix ? `${prefix}!${url}` : url;\n            let importName = urlToNameMap.get(newUrl);\n\n            if (!importName) {\n              importName = `___CSS_LOADER_AT_RULE_IMPORT_${urlToNameMap.size}___`;\n              urlToNameMap.set(newUrl, importName);\n              options.imports.push({\n                type: \"rule_import\",\n                importName,\n                url: options.urlHandler(newUrl),\n                index\n              });\n            }\n\n            options.api.push({\n              importName,\n              layer,\n              supports,\n              media,\n              index\n            });\n          }\n        }\n\n      };\n    }\n\n  };\n};\n\nplugin.postcss = true;\nvar _default = plugin;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}