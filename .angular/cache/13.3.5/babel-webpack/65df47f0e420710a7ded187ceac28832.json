{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NgccProcessor = void 0;\n\nconst child_process_1 = require(\"child_process\");\n\nconst crypto_1 = require(\"crypto\");\n\nconst fs_1 = require(\"fs\");\n\nconst path = __importStar(require(\"path\"));\n\nconst benchmark_1 = require(\"./benchmark\"); // We cannot create a plugin for this, because NGTSC requires addition type\n// information which ngcc creates when processing a package which was compiled with NGC.\n// Example of such errors:\n// ERROR in node_modules/@angular/platform-browser/platform-browser.d.ts(42,22):\n// error TS-996002: Appears in the NgModule.imports of AppModule,\n// but could not be resolved to an NgModule class\n// We now transform a package and it's typings when NGTSC is resolving a module.\n\n\nclass NgccProcessor {\n  constructor(compilerNgcc, propertiesToConsider, compilationWarnings, compilationErrors, basePath, tsConfigPath, inputFileSystem, resolver) {\n    this.compilerNgcc = compilerNgcc;\n    this.propertiesToConsider = propertiesToConsider;\n    this.compilationWarnings = compilationWarnings;\n    this.compilationErrors = compilationErrors;\n    this.basePath = basePath;\n    this.tsConfigPath = tsConfigPath;\n    this.inputFileSystem = inputFileSystem;\n    this.resolver = resolver;\n    this._processedModules = new Set();\n    this._logger = new NgccLogger(this.compilationWarnings, this.compilationErrors, compilerNgcc.LogLevel.info);\n    this._nodeModulesDirectory = this.findNodeModulesDirectory(this.basePath);\n  }\n  /** Process the entire node modules tree. */\n\n\n  process() {\n    // Under Bazel when running in sandbox mode parts of the filesystem is read-only.\n    if (process.env.BAZEL_TARGET) {\n      return;\n    } // Skip if node_modules are read-only\n\n\n    const corePackage = this.tryResolvePackage('@angular/core', this._nodeModulesDirectory);\n\n    if (corePackage && isReadOnlyFile(corePackage)) {\n      return;\n    } // Perform a ngcc run check to determine if an initial execution is required.\n    // If a run hash file exists that matches the current package manager lock file and the\n    // project's tsconfig, then an initial ngcc run has already been performed.\n\n\n    let skipProcessing = false;\n    let runHashFilePath;\n    const runHashBasePath = path.join(this._nodeModulesDirectory, '.cli-ngcc');\n    const projectBasePath = path.join(this._nodeModulesDirectory, '..');\n\n    try {\n      let ngccConfigData;\n\n      try {\n        ngccConfigData = (0, fs_1.readFileSync)(path.join(projectBasePath, 'ngcc.config.js'));\n      } catch {\n        ngccConfigData = '';\n      }\n\n      const relativeTsconfigPath = path.relative(projectBasePath, this.tsConfigPath);\n      const tsconfigData = (0, fs_1.readFileSync)(this.tsConfigPath);\n      const {\n        lockFileData,\n        lockFilePath\n      } = this.findPackageManagerLockFile(projectBasePath); // Generate a hash that represents the state of the package lock file and used tsconfig\n\n      const runHash = (0, crypto_1.createHash)('sha256').update(lockFileData).update(lockFilePath).update(ngccConfigData).update(tsconfigData).update(relativeTsconfigPath).digest('hex'); // The hash is used directly in the file name to mitigate potential read/write race\n      // conditions as well as to only require a file existence check\n\n      runHashFilePath = path.join(runHashBasePath, runHash + '.lock'); // If the run hash lock file exists, then ngcc was already run against this project state\n\n      if ((0, fs_1.existsSync)(runHashFilePath)) {\n        skipProcessing = true;\n      }\n    } catch {// Any error means an ngcc execution is needed\n    }\n\n    if (skipProcessing) {\n      return;\n    }\n\n    const timeLabel = 'NgccProcessor.process';\n    (0, benchmark_1.time)(timeLabel); // We spawn instead of using the API because:\n    // - NGCC Async uses clustering which is problematic when used via the API which means\n    // that we cannot setup multiple cluster masters with different options.\n    // - We will not be able to have concurrent builds otherwise Ex: App-Shell,\n    // as NGCC will create a lock file for both builds and it will cause builds to fails.\n\n    const {\n      status,\n      error\n    } = (0, child_process_1.spawnSync)(process.execPath, [this.compilerNgcc.ngccMainFilePath, '--source'\n    /** basePath */\n    , this._nodeModulesDirectory, '--properties'\n    /** propertiesToConsider */\n    , ...this.propertiesToConsider, '--first-only'\n    /** compileAllFormats */\n    , '--create-ivy-entry-points'\n    /** createNewEntryPointFormats */\n    , '--async', '--tsconfig'\n    /** tsConfigPath */\n    , this.tsConfigPath, '--use-program-dependencies'], {\n      stdio: ['inherit', process.stderr, process.stderr]\n    });\n\n    if (status !== 0) {\n      const errorMessage = (error === null || error === void 0 ? void 0 : error.message) || '';\n      throw new Error(errorMessage + `NGCC failed${errorMessage ? ', see above' : ''}.`);\n    }\n\n    (0, benchmark_1.timeEnd)(timeLabel); // ngcc was successful so if a run hash was generated, write it for next time\n\n    if (runHashFilePath) {\n      try {\n        if (!(0, fs_1.existsSync)(runHashBasePath)) {\n          (0, fs_1.mkdirSync)(runHashBasePath, {\n            recursive: true\n          });\n        }\n\n        (0, fs_1.writeFileSync)(runHashFilePath, '');\n      } catch {// Errors are non-fatal\n      }\n    }\n  }\n  /** Process a module and it's depedencies. */\n\n\n  processModule(moduleName, resolvedModule) {\n    var _a, _b;\n\n    const resolvedFileName = resolvedModule.resolvedFileName;\n\n    if (!resolvedFileName || moduleName.startsWith('.') || this._processedModules.has(resolvedFileName)) {\n      // Skip when module is unknown, relative or NGCC compiler is not found or already processed.\n      return;\n    }\n\n    const packageJsonPath = this.tryResolvePackage(moduleName, resolvedFileName); // If the package.json is read only we should skip calling NGCC.\n    // With Bazel when running under sandbox the filesystem is read-only.\n\n    if (!packageJsonPath || isReadOnlyFile(packageJsonPath)) {\n      // add it to processed so the second time round we skip this.\n      this._processedModules.add(resolvedFileName);\n\n      return;\n    }\n\n    const timeLabel = `NgccProcessor.processModule.ngcc.process+${moduleName}`;\n    (0, benchmark_1.time)(timeLabel);\n    this.compilerNgcc.process({\n      basePath: this._nodeModulesDirectory,\n      targetEntryPointPath: path.dirname(packageJsonPath),\n      propertiesToConsider: this.propertiesToConsider,\n      compileAllFormats: false,\n      createNewEntryPointFormats: true,\n      logger: this._logger,\n      tsConfigPath: this.tsConfigPath\n    });\n    (0, benchmark_1.timeEnd)(timeLabel); // Purge this file from cache, since NGCC add new mainFields. Ex: module_ivy_ngcc\n    // which are unknown in the cached file.\n\n    (_b = (_a = this.inputFileSystem).purge) === null || _b === void 0 ? void 0 : _b.call(_a, packageJsonPath);\n\n    this._processedModules.add(resolvedFileName);\n  }\n\n  invalidate(fileName) {\n    this._processedModules.delete(fileName);\n  }\n  /**\n   * Try resolve a package.json file from the resolved .d.ts file.\n   */\n\n\n  tryResolvePackage(moduleName, resolvedFileName) {\n    try {\n      const resolvedPath = this.resolver.resolveSync({}, resolvedFileName, `${moduleName}/package.json`);\n      return resolvedPath || undefined;\n    } catch {\n      // Ex: @angular/compiler/src/i18n/i18n_ast/package.json\n      // or local libraries which don't reside in node_modules\n      const packageJsonPath = path.resolve(resolvedFileName, '../package.json');\n      return (0, fs_1.existsSync)(packageJsonPath) ? packageJsonPath : undefined;\n    }\n  }\n\n  findNodeModulesDirectory(startPoint) {\n    let current = startPoint;\n\n    while (path.dirname(current) !== current) {\n      const nodePath = path.join(current, 'node_modules');\n\n      if ((0, fs_1.existsSync)(nodePath)) {\n        return nodePath;\n      }\n\n      current = path.dirname(current);\n    }\n\n    throw new Error(`Cannot locate the 'node_modules' directory.`);\n  }\n\n  findPackageManagerLockFile(projectBasePath) {\n    for (const lockFile of ['yarn.lock', 'pnpm-lock.yaml', 'package-lock.json']) {\n      const lockFilePath = path.join(projectBasePath, lockFile);\n\n      try {\n        return {\n          lockFilePath,\n          lockFileData: (0, fs_1.readFileSync)(lockFilePath)\n        };\n      } catch {}\n    }\n\n    throw new Error('Cannot locate a package manager lock file.');\n  }\n\n}\n\nexports.NgccProcessor = NgccProcessor;\n\nclass NgccLogger {\n  constructor(compilationWarnings, compilationErrors, level) {\n    this.compilationWarnings = compilationWarnings;\n    this.compilationErrors = compilationErrors;\n    this.level = level;\n  } // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n  debug() {}\n\n  info(...args) {\n    // Log to stderr because it's a progress-like info message.\n    process.stderr.write(`\\n${args.join(' ')}\\n`);\n  }\n\n  warn(...args) {\n    this.compilationWarnings.push(args.join(' '));\n  }\n\n  error(...args) {\n    this.compilationErrors.push(new Error(args.join(' ')));\n  }\n\n}\n\nfunction isReadOnlyFile(fileName) {\n  try {\n    (0, fs_1.accessSync)(fileName, fs_1.constants.W_OK);\n    return false;\n  } catch {\n    return true;\n  }\n}","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/@ngtools/webpack/src/ngcc_processor.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","NgccProcessor","child_process_1","require","crypto_1","fs_1","path","benchmark_1","constructor","compilerNgcc","propertiesToConsider","compilationWarnings","compilationErrors","basePath","tsConfigPath","inputFileSystem","resolver","_processedModules","Set","_logger","NgccLogger","LogLevel","info","_nodeModulesDirectory","findNodeModulesDirectory","process","env","BAZEL_TARGET","corePackage","tryResolvePackage","isReadOnlyFile","skipProcessing","runHashFilePath","runHashBasePath","join","projectBasePath","ngccConfigData","readFileSync","relativeTsconfigPath","relative","tsconfigData","lockFileData","lockFilePath","findPackageManagerLockFile","runHash","createHash","update","digest","existsSync","timeLabel","time","status","error","spawnSync","execPath","ngccMainFilePath","stdio","stderr","errorMessage","message","Error","timeEnd","mkdirSync","recursive","writeFileSync","processModule","moduleName","resolvedModule","_a","_b","resolvedFileName","startsWith","has","packageJsonPath","add","targetEntryPointPath","dirname","compileAllFormats","createNewEntryPointFormats","logger","purge","invalidate","fileName","delete","resolvedPath","resolveSync","resolve","startPoint","current","nodePath","lockFile","level","debug","args","write","warn","push","accessSync","constants","W_OK"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,KAAmCC,MAAM,CAACC,MAAP,GAAiB,UAASC,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkBC,EAAlB,EAAsB;AAC5F,MAAIA,EAAE,KAAKC,SAAX,EAAsBD,EAAE,GAAGD,CAAL;AACtB,MAAIG,IAAI,GAAGP,MAAM,CAACQ,wBAAP,CAAgCL,CAAhC,EAAmCC,CAAnC,CAAX;;AACA,MAAI,CAACG,IAAD,KAAU,SAASA,IAAT,GAAgB,CAACJ,CAAC,CAACM,UAAnB,GAAgCF,IAAI,CAACG,QAAL,IAAiBH,IAAI,CAACI,YAAhE,CAAJ,EAAmF;AACjFJ,IAAAA,IAAI,GAAG;AAAEK,MAAAA,UAAU,EAAE,IAAd;AAAoBC,MAAAA,GAAG,EAAE,YAAW;AAAE,eAAOV,CAAC,CAACC,CAAD,CAAR;AAAc;AAApD,KAAP;AACD;;AACDJ,EAAAA,MAAM,CAACc,cAAP,CAAsBZ,CAAtB,EAAyBG,EAAzB,EAA6BE,IAA7B;AACH,CAPwD,GAOnD,UAASL,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkBC,EAAlB,EAAsB;AACxB,MAAIA,EAAE,KAAKC,SAAX,EAAsBD,EAAE,GAAGD,CAAL;AACtBF,EAAAA,CAAC,CAACG,EAAD,CAAD,GAAQF,CAAC,CAACC,CAAD,CAAT;AACH,CAVqB,CAAtB;;AAWA,IAAIW,kBAAkB,GAAI,QAAQ,KAAKA,kBAAd,KAAsCf,MAAM,CAACC,MAAP,GAAiB,UAASC,CAAT,EAAYc,CAAZ,EAAe;AAC3FhB,EAAAA,MAAM,CAACc,cAAP,CAAsBZ,CAAtB,EAAyB,SAAzB,EAAoC;AAAEU,IAAAA,UAAU,EAAE,IAAd;AAAoBK,IAAAA,KAAK,EAAED;AAA3B,GAApC;AACH,CAF8D,GAE1D,UAASd,CAAT,EAAYc,CAAZ,EAAe;AAChBd,EAAAA,CAAC,CAAC,SAAD,CAAD,GAAec,CAAf;AACH,CAJwB,CAAzB;;AAKA,IAAIE,YAAY,GAAI,QAAQ,KAAKA,YAAd,IAA+B,UAAUC,GAAV,EAAe;AAC7D,MAAIA,GAAG,IAAIA,GAAG,CAACV,UAAf,EAA2B,OAAOU,GAAP;AAC3B,MAAIC,MAAM,GAAG,EAAb;AACA,MAAID,GAAG,IAAI,IAAX,EAAiB,KAAK,IAAIf,CAAT,IAAce,GAAd,EAAmB,IAAIf,CAAC,KAAK,SAAN,IAAmBJ,MAAM,CAACqB,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCJ,GAArC,EAA0Cf,CAA1C,CAAvB,EAAqEL,eAAe,CAACqB,MAAD,EAASD,GAAT,EAAcf,CAAd,CAAf;;AACzGW,EAAAA,kBAAkB,CAACK,MAAD,EAASD,GAAT,CAAlB;;AACA,SAAOC,MAAP;AACH,CAND;;AAOApB,MAAM,CAACc,cAAP,CAAsBU,OAAtB,EAA+B,YAA/B,EAA6C;AAAEP,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAO,OAAO,CAACC,aAAR,GAAwB,KAAK,CAA7B;;AACA,MAAMC,eAAe,GAAGC,OAAO,CAAC,eAAD,CAA/B;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,IAAD,CAApB;;AACA,MAAMG,IAAI,GAAGZ,YAAY,CAACS,OAAO,CAAC,MAAD,CAAR,CAAzB;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,aAAD,CAA3B,C,CACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMF,aAAN,CAAoB;AAChBO,EAAAA,WAAW,CAACC,YAAD,EAAeC,oBAAf,EAAqCC,mBAArC,EAA0DC,iBAA1D,EAA6EC,QAA7E,EAAuFC,YAAvF,EAAqGC,eAArG,EAAsHC,QAAtH,EAAgI;AACvI,SAAKP,YAAL,GAAoBA,YAApB;AACA,SAAKC,oBAAL,GAA4BA,oBAA5B;AACA,SAAKC,mBAAL,GAA2BA,mBAA3B;AACA,SAAKC,iBAAL,GAAyBA,iBAAzB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,eAAL,GAAuBA,eAAvB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,iBAAL,GAAyB,IAAIC,GAAJ,EAAzB;AACA,SAAKC,OAAL,GAAe,IAAIC,UAAJ,CAAe,KAAKT,mBAApB,EAAyC,KAAKC,iBAA9C,EAAiEH,YAAY,CAACY,QAAb,CAAsBC,IAAvF,CAAf;AACA,SAAKC,qBAAL,GAA6B,KAAKC,wBAAL,CAA8B,KAAKX,QAAnC,CAA7B;AACH;AACD;;;AACAY,EAAAA,OAAO,GAAG;AACN;AACA,QAAIA,OAAO,CAACC,GAAR,CAAYC,YAAhB,EAA8B;AAC1B;AACH,KAJK,CAKN;;;AACA,UAAMC,WAAW,GAAG,KAAKC,iBAAL,CAAuB,eAAvB,EAAwC,KAAKN,qBAA7C,CAApB;;AACA,QAAIK,WAAW,IAAIE,cAAc,CAACF,WAAD,CAAjC,EAAgD;AAC5C;AACH,KATK,CAUN;AACA;AACA;;;AACA,QAAIG,cAAc,GAAG,KAArB;AACA,QAAIC,eAAJ;AACA,UAAMC,eAAe,GAAG3B,IAAI,CAAC4B,IAAL,CAAU,KAAKX,qBAAf,EAAsC,WAAtC,CAAxB;AACA,UAAMY,eAAe,GAAG7B,IAAI,CAAC4B,IAAL,CAAU,KAAKX,qBAAf,EAAsC,IAAtC,CAAxB;;AACA,QAAI;AACA,UAAIa,cAAJ;;AACA,UAAI;AACAA,QAAAA,cAAc,GAAG,CAAC,GAAG/B,IAAI,CAACgC,YAAT,EAAuB/B,IAAI,CAAC4B,IAAL,CAAUC,eAAV,EAA2B,gBAA3B,CAAvB,CAAjB;AACH,OAFD,CAGA,MAAM;AACFC,QAAAA,cAAc,GAAG,EAAjB;AACH;;AACD,YAAME,oBAAoB,GAAGhC,IAAI,CAACiC,QAAL,CAAcJ,eAAd,EAA+B,KAAKrB,YAApC,CAA7B;AACA,YAAM0B,YAAY,GAAG,CAAC,GAAGnC,IAAI,CAACgC,YAAT,EAAuB,KAAKvB,YAA5B,CAArB;AACA,YAAM;AAAE2B,QAAAA,YAAF;AAAgBC,QAAAA;AAAhB,UAAiC,KAAKC,0BAAL,CAAgCR,eAAhC,CAAvC,CAVA,CAWA;;AACA,YAAMS,OAAO,GAAG,CAAC,GAAGxC,QAAQ,CAACyC,UAAb,EAAyB,QAAzB,EACXC,MADW,CACJL,YADI,EAEXK,MAFW,CAEJJ,YAFI,EAGXI,MAHW,CAGJV,cAHI,EAIXU,MAJW,CAIJN,YAJI,EAKXM,MALW,CAKJR,oBALI,EAMXS,MANW,CAMJ,KANI,CAAhB,CAZA,CAmBA;AACA;;AACAf,MAAAA,eAAe,GAAG1B,IAAI,CAAC4B,IAAL,CAAUD,eAAV,EAA2BW,OAAO,GAAG,OAArC,CAAlB,CArBA,CAsBA;;AACA,UAAI,CAAC,GAAGvC,IAAI,CAAC2C,UAAT,EAAqBhB,eAArB,CAAJ,EAA2C;AACvCD,QAAAA,cAAc,GAAG,IAAjB;AACH;AACJ,KA1BD,CA2BA,MAAM,CACF;AACH;;AACD,QAAIA,cAAJ,EAAoB;AAChB;AACH;;AACD,UAAMkB,SAAS,GAAG,uBAAlB;AACA,KAAC,GAAG1C,WAAW,CAAC2C,IAAhB,EAAsBD,SAAtB,EAnDM,CAoDN;AACA;AACA;AACA;AACA;;AACA,UAAM;AAAEE,MAAAA,MAAF;AAAUC,MAAAA;AAAV,QAAoB,CAAC,GAAGlD,eAAe,CAACmD,SAApB,EAA+B5B,OAAO,CAAC6B,QAAvC,EAAiD,CACvE,KAAK7C,YAAL,CAAkB8C,gBADqD,EAEvE;AAAW;AAF4D,MAGvE,KAAKhC,qBAHkE,EAIvE;AAAe;AAJwD,MAKvE,GAAG,KAAKb,oBAL+D,EAMvE;AAAe;AANwD,MAOvE;AAA4B;AAP2C,MAQvE,SARuE,EASvE;AAAa;AAT0D,MAUvE,KAAKI,YAVkE,EAWvE,4BAXuE,CAAjD,EAYvB;AACC0C,MAAAA,KAAK,EAAE,CAAC,SAAD,EAAY/B,OAAO,CAACgC,MAApB,EAA4BhC,OAAO,CAACgC,MAApC;AADR,KAZuB,CAA1B;;AAeA,QAAIN,MAAM,KAAK,CAAf,EAAkB;AACd,YAAMO,YAAY,GAAG,CAACN,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACO,OAArD,KAAiE,EAAtF;AACA,YAAM,IAAIC,KAAJ,CAAUF,YAAY,GAAI,cAAaA,YAAY,GAAG,aAAH,GAAmB,EAAG,GAAzE,CAAN;AACH;;AACD,KAAC,GAAGnD,WAAW,CAACsD,OAAhB,EAAyBZ,SAAzB,EA5EM,CA6EN;;AACA,QAAIjB,eAAJ,EAAqB;AACjB,UAAI;AACA,YAAI,CAAC,CAAC,GAAG3B,IAAI,CAAC2C,UAAT,EAAqBf,eAArB,CAAL,EAA4C;AACxC,WAAC,GAAG5B,IAAI,CAACyD,SAAT,EAAoB7B,eAApB,EAAqC;AAAE8B,YAAAA,SAAS,EAAE;AAAb,WAArC;AACH;;AACD,SAAC,GAAG1D,IAAI,CAAC2D,aAAT,EAAwBhC,eAAxB,EAAyC,EAAzC;AACH,OALD,CAMA,MAAM,CACF;AACH;AACJ;AACJ;AACD;;;AACAiC,EAAAA,aAAa,CAACC,UAAD,EAAaC,cAAb,EAA6B;AACtC,QAAIC,EAAJ,EAAQC,EAAR;;AACA,UAAMC,gBAAgB,GAAGH,cAAc,CAACG,gBAAxC;;AACA,QAAI,CAACA,gBAAD,IACAJ,UAAU,CAACK,UAAX,CAAsB,GAAtB,CADA,IAEA,KAAKtD,iBAAL,CAAuBuD,GAAvB,CAA2BF,gBAA3B,CAFJ,EAEkD;AAC9C;AACA;AACH;;AACD,UAAMG,eAAe,GAAG,KAAK5C,iBAAL,CAAuBqC,UAAvB,EAAmCI,gBAAnC,CAAxB,CATsC,CAUtC;AACA;;AACA,QAAI,CAACG,eAAD,IAAoB3C,cAAc,CAAC2C,eAAD,CAAtC,EAAyD;AACrD;AACA,WAAKxD,iBAAL,CAAuByD,GAAvB,CAA2BJ,gBAA3B;;AACA;AACH;;AACD,UAAMrB,SAAS,GAAI,4CAA2CiB,UAAW,EAAzE;AACA,KAAC,GAAG3D,WAAW,CAAC2C,IAAhB,EAAsBD,SAAtB;AACA,SAAKxC,YAAL,CAAkBgB,OAAlB,CAA0B;AACtBZ,MAAAA,QAAQ,EAAE,KAAKU,qBADO;AAEtBoD,MAAAA,oBAAoB,EAAErE,IAAI,CAACsE,OAAL,CAAaH,eAAb,CAFA;AAGtB/D,MAAAA,oBAAoB,EAAE,KAAKA,oBAHL;AAItBmE,MAAAA,iBAAiB,EAAE,KAJG;AAKtBC,MAAAA,0BAA0B,EAAE,IALN;AAMtBC,MAAAA,MAAM,EAAE,KAAK5D,OANS;AAOtBL,MAAAA,YAAY,EAAE,KAAKA;AAPG,KAA1B;AASA,KAAC,GAAGP,WAAW,CAACsD,OAAhB,EAAyBZ,SAAzB,EA5BsC,CA6BtC;AACA;;AACA,KAACoB,EAAE,GAAG,CAACD,EAAE,GAAG,KAAKrD,eAAX,EAA4BiE,KAAlC,MAA6C,IAA7C,IAAqDX,EAAE,KAAK,KAAK,CAAjE,GAAqE,KAAK,CAA1E,GAA8EA,EAAE,CAACtE,IAAH,CAAQqE,EAAR,EAAYK,eAAZ,CAA9E;;AACA,SAAKxD,iBAAL,CAAuByD,GAAvB,CAA2BJ,gBAA3B;AACH;;AACDW,EAAAA,UAAU,CAACC,QAAD,EAAW;AACjB,SAAKjE,iBAAL,CAAuBkE,MAAvB,CAA8BD,QAA9B;AACH;AACD;AACJ;AACA;;;AACIrD,EAAAA,iBAAiB,CAACqC,UAAD,EAAaI,gBAAb,EAA+B;AAC5C,QAAI;AACA,YAAMc,YAAY,GAAG,KAAKpE,QAAL,CAAcqE,WAAd,CAA0B,EAA1B,EAA8Bf,gBAA9B,EAAiD,GAAEJ,UAAW,eAA9D,CAArB;AACA,aAAOkB,YAAY,IAAItG,SAAvB;AACH,KAHD,CAIA,MAAM;AACF;AACA;AACA,YAAM2F,eAAe,GAAGnE,IAAI,CAACgF,OAAL,CAAahB,gBAAb,EAA+B,iBAA/B,CAAxB;AACA,aAAO,CAAC,GAAGjE,IAAI,CAAC2C,UAAT,EAAqByB,eAArB,IAAwCA,eAAxC,GAA0D3F,SAAjE;AACH;AACJ;;AACD0C,EAAAA,wBAAwB,CAAC+D,UAAD,EAAa;AACjC,QAAIC,OAAO,GAAGD,UAAd;;AACA,WAAOjF,IAAI,CAACsE,OAAL,CAAaY,OAAb,MAA0BA,OAAjC,EAA0C;AACtC,YAAMC,QAAQ,GAAGnF,IAAI,CAAC4B,IAAL,CAAUsD,OAAV,EAAmB,cAAnB,CAAjB;;AACA,UAAI,CAAC,GAAGnF,IAAI,CAAC2C,UAAT,EAAqByC,QAArB,CAAJ,EAAoC;AAChC,eAAOA,QAAP;AACH;;AACDD,MAAAA,OAAO,GAAGlF,IAAI,CAACsE,OAAL,CAAaY,OAAb,CAAV;AACH;;AACD,UAAM,IAAI5B,KAAJ,CAAW,6CAAX,CAAN;AACH;;AACDjB,EAAAA,0BAA0B,CAACR,eAAD,EAAkB;AACxC,SAAK,MAAMuD,QAAX,IAAuB,CAAC,WAAD,EAAc,gBAAd,EAAgC,mBAAhC,CAAvB,EAA6E;AACzE,YAAMhD,YAAY,GAAGpC,IAAI,CAAC4B,IAAL,CAAUC,eAAV,EAA2BuD,QAA3B,CAArB;;AACA,UAAI;AACA,eAAO;AACHhD,UAAAA,YADG;AAEHD,UAAAA,YAAY,EAAE,CAAC,GAAGpC,IAAI,CAACgC,YAAT,EAAuBK,YAAvB;AAFX,SAAP;AAIH,OALD,CAMA,MAAM,CAAG;AACZ;;AACD,UAAM,IAAIkB,KAAJ,CAAU,4CAAV,CAAN;AACH;;AArLe;;AAuLpB5D,OAAO,CAACC,aAAR,GAAwBA,aAAxB;;AACA,MAAMmB,UAAN,CAAiB;AACbZ,EAAAA,WAAW,CAACG,mBAAD,EAAsBC,iBAAtB,EAAyC+E,KAAzC,EAAgD;AACvD,SAAKhF,mBAAL,GAA2BA,mBAA3B;AACA,SAAKC,iBAAL,GAAyBA,iBAAzB;AACA,SAAK+E,KAAL,GAAaA,KAAb;AACH,GALY,CAMb;;;AACAC,EAAAA,KAAK,GAAG,CAAG;;AACXtE,EAAAA,IAAI,CAAC,GAAGuE,IAAJ,EAAU;AACV;AACApE,IAAAA,OAAO,CAACgC,MAAR,CAAeqC,KAAf,CAAsB,KAAID,IAAI,CAAC3D,IAAL,CAAU,GAAV,CAAe,IAAzC;AACH;;AACD6D,EAAAA,IAAI,CAAC,GAAGF,IAAJ,EAAU;AACV,SAAKlF,mBAAL,CAAyBqF,IAAzB,CAA8BH,IAAI,CAAC3D,IAAL,CAAU,GAAV,CAA9B;AACH;;AACDkB,EAAAA,KAAK,CAAC,GAAGyC,IAAJ,EAAU;AACX,SAAKjF,iBAAL,CAAuBoF,IAAvB,CAA4B,IAAIpC,KAAJ,CAAUiC,IAAI,CAAC3D,IAAL,CAAU,GAAV,CAAV,CAA5B;AACH;;AAjBY;;AAmBjB,SAASJ,cAAT,CAAwBoD,QAAxB,EAAkC;AAC9B,MAAI;AACA,KAAC,GAAG7E,IAAI,CAAC4F,UAAT,EAAqBf,QAArB,EAA+B7E,IAAI,CAAC6F,SAAL,CAAeC,IAA9C;AACA,WAAO,KAAP;AACH,GAHD,CAIA,MAAM;AACF,WAAO,IAAP;AACH;AACJ","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NgccProcessor = void 0;\nconst child_process_1 = require(\"child_process\");\nconst crypto_1 = require(\"crypto\");\nconst fs_1 = require(\"fs\");\nconst path = __importStar(require(\"path\"));\nconst benchmark_1 = require(\"./benchmark\");\n// We cannot create a plugin for this, because NGTSC requires addition type\n// information which ngcc creates when processing a package which was compiled with NGC.\n// Example of such errors:\n// ERROR in node_modules/@angular/platform-browser/platform-browser.d.ts(42,22):\n// error TS-996002: Appears in the NgModule.imports of AppModule,\n// but could not be resolved to an NgModule class\n// We now transform a package and it's typings when NGTSC is resolving a module.\nclass NgccProcessor {\n    constructor(compilerNgcc, propertiesToConsider, compilationWarnings, compilationErrors, basePath, tsConfigPath, inputFileSystem, resolver) {\n        this.compilerNgcc = compilerNgcc;\n        this.propertiesToConsider = propertiesToConsider;\n        this.compilationWarnings = compilationWarnings;\n        this.compilationErrors = compilationErrors;\n        this.basePath = basePath;\n        this.tsConfigPath = tsConfigPath;\n        this.inputFileSystem = inputFileSystem;\n        this.resolver = resolver;\n        this._processedModules = new Set();\n        this._logger = new NgccLogger(this.compilationWarnings, this.compilationErrors, compilerNgcc.LogLevel.info);\n        this._nodeModulesDirectory = this.findNodeModulesDirectory(this.basePath);\n    }\n    /** Process the entire node modules tree. */\n    process() {\n        // Under Bazel when running in sandbox mode parts of the filesystem is read-only.\n        if (process.env.BAZEL_TARGET) {\n            return;\n        }\n        // Skip if node_modules are read-only\n        const corePackage = this.tryResolvePackage('@angular/core', this._nodeModulesDirectory);\n        if (corePackage && isReadOnlyFile(corePackage)) {\n            return;\n        }\n        // Perform a ngcc run check to determine if an initial execution is required.\n        // If a run hash file exists that matches the current package manager lock file and the\n        // project's tsconfig, then an initial ngcc run has already been performed.\n        let skipProcessing = false;\n        let runHashFilePath;\n        const runHashBasePath = path.join(this._nodeModulesDirectory, '.cli-ngcc');\n        const projectBasePath = path.join(this._nodeModulesDirectory, '..');\n        try {\n            let ngccConfigData;\n            try {\n                ngccConfigData = (0, fs_1.readFileSync)(path.join(projectBasePath, 'ngcc.config.js'));\n            }\n            catch {\n                ngccConfigData = '';\n            }\n            const relativeTsconfigPath = path.relative(projectBasePath, this.tsConfigPath);\n            const tsconfigData = (0, fs_1.readFileSync)(this.tsConfigPath);\n            const { lockFileData, lockFilePath } = this.findPackageManagerLockFile(projectBasePath);\n            // Generate a hash that represents the state of the package lock file and used tsconfig\n            const runHash = (0, crypto_1.createHash)('sha256')\n                .update(lockFileData)\n                .update(lockFilePath)\n                .update(ngccConfigData)\n                .update(tsconfigData)\n                .update(relativeTsconfigPath)\n                .digest('hex');\n            // The hash is used directly in the file name to mitigate potential read/write race\n            // conditions as well as to only require a file existence check\n            runHashFilePath = path.join(runHashBasePath, runHash + '.lock');\n            // If the run hash lock file exists, then ngcc was already run against this project state\n            if ((0, fs_1.existsSync)(runHashFilePath)) {\n                skipProcessing = true;\n            }\n        }\n        catch {\n            // Any error means an ngcc execution is needed\n        }\n        if (skipProcessing) {\n            return;\n        }\n        const timeLabel = 'NgccProcessor.process';\n        (0, benchmark_1.time)(timeLabel);\n        // We spawn instead of using the API because:\n        // - NGCC Async uses clustering which is problematic when used via the API which means\n        // that we cannot setup multiple cluster masters with different options.\n        // - We will not be able to have concurrent builds otherwise Ex: App-Shell,\n        // as NGCC will create a lock file for both builds and it will cause builds to fails.\n        const { status, error } = (0, child_process_1.spawnSync)(process.execPath, [\n            this.compilerNgcc.ngccMainFilePath,\n            '--source' /** basePath */,\n            this._nodeModulesDirectory,\n            '--properties' /** propertiesToConsider */,\n            ...this.propertiesToConsider,\n            '--first-only' /** compileAllFormats */,\n            '--create-ivy-entry-points' /** createNewEntryPointFormats */,\n            '--async',\n            '--tsconfig' /** tsConfigPath */,\n            this.tsConfigPath,\n            '--use-program-dependencies',\n        ], {\n            stdio: ['inherit', process.stderr, process.stderr],\n        });\n        if (status !== 0) {\n            const errorMessage = (error === null || error === void 0 ? void 0 : error.message) || '';\n            throw new Error(errorMessage + `NGCC failed${errorMessage ? ', see above' : ''}.`);\n        }\n        (0, benchmark_1.timeEnd)(timeLabel);\n        // ngcc was successful so if a run hash was generated, write it for next time\n        if (runHashFilePath) {\n            try {\n                if (!(0, fs_1.existsSync)(runHashBasePath)) {\n                    (0, fs_1.mkdirSync)(runHashBasePath, { recursive: true });\n                }\n                (0, fs_1.writeFileSync)(runHashFilePath, '');\n            }\n            catch {\n                // Errors are non-fatal\n            }\n        }\n    }\n    /** Process a module and it's depedencies. */\n    processModule(moduleName, resolvedModule) {\n        var _a, _b;\n        const resolvedFileName = resolvedModule.resolvedFileName;\n        if (!resolvedFileName ||\n            moduleName.startsWith('.') ||\n            this._processedModules.has(resolvedFileName)) {\n            // Skip when module is unknown, relative or NGCC compiler is not found or already processed.\n            return;\n        }\n        const packageJsonPath = this.tryResolvePackage(moduleName, resolvedFileName);\n        // If the package.json is read only we should skip calling NGCC.\n        // With Bazel when running under sandbox the filesystem is read-only.\n        if (!packageJsonPath || isReadOnlyFile(packageJsonPath)) {\n            // add it to processed so the second time round we skip this.\n            this._processedModules.add(resolvedFileName);\n            return;\n        }\n        const timeLabel = `NgccProcessor.processModule.ngcc.process+${moduleName}`;\n        (0, benchmark_1.time)(timeLabel);\n        this.compilerNgcc.process({\n            basePath: this._nodeModulesDirectory,\n            targetEntryPointPath: path.dirname(packageJsonPath),\n            propertiesToConsider: this.propertiesToConsider,\n            compileAllFormats: false,\n            createNewEntryPointFormats: true,\n            logger: this._logger,\n            tsConfigPath: this.tsConfigPath,\n        });\n        (0, benchmark_1.timeEnd)(timeLabel);\n        // Purge this file from cache, since NGCC add new mainFields. Ex: module_ivy_ngcc\n        // which are unknown in the cached file.\n        (_b = (_a = this.inputFileSystem).purge) === null || _b === void 0 ? void 0 : _b.call(_a, packageJsonPath);\n        this._processedModules.add(resolvedFileName);\n    }\n    invalidate(fileName) {\n        this._processedModules.delete(fileName);\n    }\n    /**\n     * Try resolve a package.json file from the resolved .d.ts file.\n     */\n    tryResolvePackage(moduleName, resolvedFileName) {\n        try {\n            const resolvedPath = this.resolver.resolveSync({}, resolvedFileName, `${moduleName}/package.json`);\n            return resolvedPath || undefined;\n        }\n        catch {\n            // Ex: @angular/compiler/src/i18n/i18n_ast/package.json\n            // or local libraries which don't reside in node_modules\n            const packageJsonPath = path.resolve(resolvedFileName, '../package.json');\n            return (0, fs_1.existsSync)(packageJsonPath) ? packageJsonPath : undefined;\n        }\n    }\n    findNodeModulesDirectory(startPoint) {\n        let current = startPoint;\n        while (path.dirname(current) !== current) {\n            const nodePath = path.join(current, 'node_modules');\n            if ((0, fs_1.existsSync)(nodePath)) {\n                return nodePath;\n            }\n            current = path.dirname(current);\n        }\n        throw new Error(`Cannot locate the 'node_modules' directory.`);\n    }\n    findPackageManagerLockFile(projectBasePath) {\n        for (const lockFile of ['yarn.lock', 'pnpm-lock.yaml', 'package-lock.json']) {\n            const lockFilePath = path.join(projectBasePath, lockFile);\n            try {\n                return {\n                    lockFilePath,\n                    lockFileData: (0, fs_1.readFileSync)(lockFilePath),\n                };\n            }\n            catch { }\n        }\n        throw new Error('Cannot locate a package manager lock file.');\n    }\n}\nexports.NgccProcessor = NgccProcessor;\nclass NgccLogger {\n    constructor(compilationWarnings, compilationErrors, level) {\n        this.compilationWarnings = compilationWarnings;\n        this.compilationErrors = compilationErrors;\n        this.level = level;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    debug() { }\n    info(...args) {\n        // Log to stderr because it's a progress-like info message.\n        process.stderr.write(`\\n${args.join(' ')}\\n`);\n    }\n    warn(...args) {\n        this.compilationWarnings.push(args.join(' '));\n    }\n    error(...args) {\n        this.compilationErrors.push(new Error(args.join(' ')));\n    }\n}\nfunction isReadOnlyFile(fileName) {\n    try {\n        (0, fs_1.accessSync)(fileName, fs_1.constants.W_OK);\n        return false;\n    }\n    catch {\n        return true;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}