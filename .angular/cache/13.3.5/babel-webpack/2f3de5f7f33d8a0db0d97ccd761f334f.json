{"ast":null,"code":"var _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nconst debug = require(\"debug\")(\"streamroller:RollingFileWriteStream\");\n\nconst fs = require(\"fs-extra\");\n\nconst path = require(\"path\");\n\nconst newNow = require(\"./now\");\n\nconst format = require(\"date-format\");\n\nconst {\n  Writable\n} = require(\"stream\");\n\nconst fileNameFormatter = require(\"./fileNameFormatter\");\n\nconst fileNameParser = require(\"./fileNameParser\");\n\nconst moveAndMaybeCompressFile = require(\"./moveAndMaybeCompressFile\");\n\nconst deleteFiles = fileNames => {\n  debug(`deleteFiles: files to delete: ${fileNames}`);\n  return Promise.all(fileNames.map(f => fs.unlink(f).catch(e => {\n    debug(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);\n  })));\n};\n/**\n * RollingFileWriteStream is mainly used when writing to a file rolling by date or size.\n * RollingFileWriteStream inherits from stream.Writable\n */\n\n\nclass RollingFileWriteStream extends Writable {\n  /**\n   * Create a RollingFileWriteStream\n   * @constructor\n   * @param {string} filePath - The file path to write.\n   * @param {object} options - The extra options\n   * @param {number} options.numToKeep - The max numbers of files to keep.\n   * @param {number} options.maxSize - The maxSize one file can reach. Unit is Byte.\n   *                                   This should be more than 1024. The default is Number.MAX_SAFE_INTEGER.\n   * @param {string} options.mode - The mode of the files. The default is '0600'. Refer to stream.writable for more.\n   * @param {string} options.flags - The default is 'a'. Refer to stream.flags for more.\n   * @param {boolean} options.compress - Whether to compress backup files.\n   * @param {boolean} options.keepFileExt - Whether to keep the file extension.\n   * @param {string} options.pattern - The date string pattern in the file name.\n   * @param {boolean} options.alwaysIncludePattern - Whether to add date to the name of the first file.\n   */\n  constructor(filePath, options) {\n    debug(`constructor: creating RollingFileWriteStream. path=${filePath}`);\n\n    if (typeof filePath !== \"string\" || filePath.length === 0) {\n      throw new Error(`Invalid filename: ${filePath}`);\n    }\n\n    super(options);\n    this.options = this._parseOption(options);\n    this.fileObject = path.parse(filePath);\n\n    if (this.fileObject.dir === \"\") {\n      this.fileObject = path.parse(path.join(process.cwd(), filePath));\n    }\n\n    this.fileFormatter = fileNameFormatter({\n      file: this.fileObject,\n      alwaysIncludeDate: this.options.alwaysIncludePattern,\n      needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,\n      compress: this.options.compress,\n      keepFileExt: this.options.keepFileExt,\n      fileNameSep: this.options.fileNameSep\n    });\n    this.fileNameParser = fileNameParser({\n      file: this.fileObject,\n      keepFileExt: this.options.keepFileExt,\n      pattern: this.options.pattern,\n      fileNameSep: this.options.fileNameSep\n    });\n    this.state = {\n      currentSize: 0\n    };\n\n    if (this.options.pattern) {\n      this.state.currentDate = format(this.options.pattern, newNow());\n    }\n\n    this.filename = this.fileFormatter({\n      index: 0,\n      date: this.state.currentDate\n    });\n\n    if ([\"a\", \"a+\", \"as\", \"as+\"].includes(this.options.flags)) {\n      this._setExistingSizeAndDate();\n    }\n\n    debug(`constructor: create new file ${this.filename}, state=${JSON.stringify(this.state)}`);\n\n    this._renewWriteStream();\n  }\n\n  _setExistingSizeAndDate() {\n    try {\n      const stats = fs.statSync(this.filename);\n      this.state.currentSize = stats.size;\n\n      if (this.options.pattern) {\n        this.state.currentDate = format(this.options.pattern, stats.mtime);\n      }\n    } catch (e) {\n      //file does not exist, that's fine - move along\n      return;\n    }\n  }\n\n  _parseOption(rawOptions) {\n    const defaultOptions = {\n      maxSize: Number.MAX_SAFE_INTEGER,\n      numToKeep: Number.MAX_SAFE_INTEGER,\n      encoding: \"utf8\",\n      mode: parseInt(\"0600\", 8),\n      flags: \"a\",\n      compress: false,\n      keepFileExt: false,\n      alwaysIncludePattern: false\n    };\n    const options = Object.assign({}, defaultOptions, rawOptions);\n\n    if (options.maxSize <= 0) {\n      throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);\n    } // options.numBackups will supercede options.numToKeep\n\n\n    if (options.numBackups || options.numBackups === 0) {\n      if (options.numBackups < 0) {\n        throw new Error(`options.numBackups (${options.numBackups}) should be >= 0`);\n      } else if (options.numBackups >= Number.MAX_SAFE_INTEGER) {\n        // to cater for numToKeep (include the hot file) at Number.MAX_SAFE_INTEGER\n        throw new Error(`options.numBackups (${options.numBackups}) should be < Number.MAX_SAFE_INTEGER`);\n      } else {\n        options.numToKeep = options.numBackups + 1;\n      }\n    } else if (options.numToKeep <= 0) {\n      throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);\n    }\n\n    debug(`_parseOption: creating stream with option=${JSON.stringify(options)}`);\n    return options;\n  }\n\n  _final(callback) {\n    this.currentFileStream.end(\"\", this.options.encoding, callback);\n  }\n\n  _write(chunk, encoding, callback) {\n    this._shouldRoll().then(() => {\n      debug(`_write: writing chunk. ` + `file=${this.currentFileStream.path} ` + `state=${JSON.stringify(this.state)} ` + `chunk=${chunk}`);\n      this.currentFileStream.write(chunk, encoding, e => {\n        this.state.currentSize += chunk.length;\n        callback(e);\n      });\n    });\n  }\n\n  _shouldRoll() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this._dateChanged() || _this._tooBig()) {\n        debug(`_shouldRoll: rolling because dateChanged? ${_this._dateChanged()} or tooBig? ${_this._tooBig()}`);\n        yield _this._roll();\n      }\n    })();\n  }\n\n  _dateChanged() {\n    return this.state.currentDate && this.state.currentDate !== format(this.options.pattern, newNow());\n  }\n\n  _tooBig() {\n    return this.state.currentSize >= this.options.maxSize;\n  }\n\n  _roll() {\n    debug(`_roll: closing the current stream`);\n    return new Promise((resolve, reject) => {\n      this.currentFileStream.end(\"\", this.options.encoding, () => {\n        this._moveOldFiles().then(resolve).catch(reject);\n      });\n    });\n  }\n\n  _moveOldFiles() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const files = yield _this2._getExistingFiles();\n      const todaysFiles = _this2.state.currentDate ? files.filter(f => f.date === _this2.state.currentDate) : files;\n\n      for (let i = todaysFiles.length; i >= 0; i--) {\n        debug(`_moveOldFiles: i = ${i}`);\n\n        const sourceFilePath = _this2.fileFormatter({\n          date: _this2.state.currentDate,\n          index: i\n        });\n\n        const targetFilePath = _this2.fileFormatter({\n          date: _this2.state.currentDate,\n          index: i + 1\n        });\n\n        const moveAndCompressOptions = {\n          compress: _this2.options.compress && i === 0,\n          mode: _this2.options.mode\n        };\n        yield moveAndMaybeCompressFile(sourceFilePath, targetFilePath, moveAndCompressOptions);\n      }\n\n      _this2.state.currentSize = 0;\n      _this2.state.currentDate = _this2.state.currentDate ? format(_this2.options.pattern, newNow()) : null;\n      debug(`_moveOldFiles: finished rolling files. state=${JSON.stringify(_this2.state)}`);\n\n      _this2._renewWriteStream(); // wait for the file to be open before cleaning up old ones,\n      // otherwise the daysToKeep calculations can be off\n\n\n      yield new Promise((resolve, reject) => {\n        _this2.currentFileStream.write(\"\", \"utf8\", () => {\n          _this2._clean().then(resolve).catch(reject);\n        });\n      });\n    })();\n  } // Sorted from the oldest to the latest\n\n\n  _getExistingFiles() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const files = yield fs.readdir(_this3.fileObject.dir).catch(\n      /* istanbul ignore next: will not happen on windows */\n      () => []);\n      debug(`_getExistingFiles: files=${files}`);\n      const existingFileDetails = files.map(n => _this3.fileNameParser(n)).filter(n => n);\n\n      const getKey = n => (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;\n\n      existingFileDetails.sort((a, b) => getKey(a) - getKey(b));\n      return existingFileDetails;\n    })();\n  }\n\n  _renewWriteStream() {\n    const mkdir = dir => {\n      try {\n        return fs.mkdirSync(dir, {\n          recursive: true\n        });\n      } // backward-compatible fs.mkdirSync for nodejs pre-10.12.0 (without recursive option)\n      catch (e) {\n        // recursive creation of parent first\n        if (e.code === \"ENOENT\") {\n          mkdir(path.dirname(dir));\n          return mkdir(dir);\n        } // throw error for all except EEXIST and EROFS (read-only filesystem)\n\n\n        if (e.code !== \"EEXIST\" && e.code !== \"EROFS\") {\n          throw e;\n        } // EEXIST: throw if file and not directory\n        // EROFS : throw if directory not found\n        else {\n          try {\n            if (fs.statSync(dir).isDirectory()) {\n              return dir;\n            }\n\n            throw e;\n          } catch (err) {\n            throw e;\n          }\n        }\n      }\n    };\n\n    mkdir(this.fileObject.dir);\n    const filePath = this.fileFormatter({\n      date: this.state.currentDate,\n      index: 0\n    });\n    const ops = {\n      flags: this.options.flags,\n      encoding: this.options.encoding,\n      mode: this.options.mode\n    };\n    this.currentFileStream = fs.createWriteStream(filePath, ops);\n    this.currentFileStream.on(\"error\", e => {\n      this.emit(\"error\", e);\n    });\n  }\n\n  _clean() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const existingFileDetails = yield _this4._getExistingFiles();\n      debug(`_clean: numToKeep = ${_this4.options.numToKeep}, existingFiles = ${existingFileDetails.length}`);\n      debug(\"_clean: existing files are: \", existingFileDetails);\n\n      if (_this4._tooManyFiles(existingFileDetails.length)) {\n        const fileNamesToRemove = existingFileDetails.slice(0, existingFileDetails.length - _this4.options.numToKeep).map(f => path.format({\n          dir: _this4.fileObject.dir,\n          base: f.filename\n        }));\n        yield deleteFiles(fileNamesToRemove);\n      }\n    })();\n  }\n\n  _tooManyFiles(numFiles) {\n    return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;\n  }\n\n}\n\nmodule.exports = RollingFileWriteStream;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/streamroller/lib/RollingFileWriteStream.js"],"names":["debug","require","fs","path","newNow","format","Writable","fileNameFormatter","fileNameParser","moveAndMaybeCompressFile","deleteFiles","fileNames","Promise","all","map","f","unlink","catch","e","RollingFileWriteStream","constructor","filePath","options","length","Error","_parseOption","fileObject","parse","dir","join","process","cwd","fileFormatter","file","alwaysIncludeDate","alwaysIncludePattern","needsIndex","maxSize","Number","MAX_SAFE_INTEGER","compress","keepFileExt","fileNameSep","pattern","state","currentSize","currentDate","filename","index","date","includes","flags","_setExistingSizeAndDate","JSON","stringify","_renewWriteStream","stats","statSync","size","mtime","rawOptions","defaultOptions","numToKeep","encoding","mode","parseInt","Object","assign","numBackups","_final","callback","currentFileStream","end","_write","chunk","_shouldRoll","then","write","_dateChanged","_tooBig","_roll","resolve","reject","_moveOldFiles","files","_getExistingFiles","todaysFiles","filter","i","sourceFilePath","targetFilePath","moveAndCompressOptions","_clean","readdir","existingFileDetails","n","getKey","timestamp","getTime","sort","a","b","mkdir","mkdirSync","recursive","code","dirname","isDirectory","err","ops","createWriteStream","on","emit","_tooManyFiles","fileNamesToRemove","slice","base","numFiles","module","exports"],"mappings":";;AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,qCAAjB,CAAd;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,UAAD,CAAlB;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,aAAD,CAAtB;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAAeL,OAAO,CAAC,QAAD,CAA5B;;AACA,MAAMM,iBAAiB,GAAGN,OAAO,CAAC,qBAAD,CAAjC;;AACA,MAAMO,cAAc,GAAGP,OAAO,CAAC,kBAAD,CAA9B;;AACA,MAAMQ,wBAAwB,GAAGR,OAAO,CAAC,4BAAD,CAAxC;;AAEA,MAAMS,WAAW,GAAGC,SAAS,IAAI;AAC/BX,EAAAA,KAAK,CAAE,iCAAgCW,SAAU,EAA5C,CAAL;AACA,SAAOC,OAAO,CAACC,GAAR,CAAYF,SAAS,CAACG,GAAV,CAAcC,CAAC,IAAIb,EAAE,CAACc,MAAH,CAAUD,CAAV,EAAaE,KAAb,CAAoBC,CAAD,IAAO;AAC9DlB,IAAAA,KAAK,CAAE,qCAAoCe,CAAE,yBAAwBG,CAAE,EAAlE,CAAL;AACD,GAFqC,CAAnB,CAAZ,CAAP;AAGD,CALD;AAOA;AACA;AACA;AACA;;;AACA,MAAMC,sBAAN,SAAqCb,QAArC,CAA8C;AAC5C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEc,EAAAA,WAAW,CAACC,QAAD,EAAWC,OAAX,EAAoB;AAC7BtB,IAAAA,KAAK,CAAE,sDAAqDqB,QAAS,EAAhE,CAAL;;AACA,QAAI,OAAOA,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,CAACE,MAAT,KAAoB,CAAxD,EAA2D;AACzD,YAAM,IAAIC,KAAJ,CAAW,qBAAoBH,QAAS,EAAxC,CAAN;AACD;;AACD,UAAMC,OAAN;AACA,SAAKA,OAAL,GAAe,KAAKG,YAAL,CAAkBH,OAAlB,CAAf;AACA,SAAKI,UAAL,GAAkBvB,IAAI,CAACwB,KAAL,CAAWN,QAAX,CAAlB;;AACA,QAAI,KAAKK,UAAL,CAAgBE,GAAhB,KAAwB,EAA5B,EAAgC;AAC9B,WAAKF,UAAL,GAAkBvB,IAAI,CAACwB,KAAL,CAAWxB,IAAI,CAAC0B,IAAL,CAAUC,OAAO,CAACC,GAAR,EAAV,EAAyBV,QAAzB,CAAX,CAAlB;AACD;;AACD,SAAKW,aAAL,GAAqBzB,iBAAiB,CAAC;AACrC0B,MAAAA,IAAI,EAAE,KAAKP,UAD0B;AAErCQ,MAAAA,iBAAiB,EAAE,KAAKZ,OAAL,CAAaa,oBAFK;AAGrCC,MAAAA,UAAU,EAAE,KAAKd,OAAL,CAAae,OAAb,GAAuBC,MAAM,CAACC,gBAHL;AAIrCC,MAAAA,QAAQ,EAAE,KAAKlB,OAAL,CAAakB,QAJc;AAKrCC,MAAAA,WAAW,EAAE,KAAKnB,OAAL,CAAamB,WALW;AAMrCC,MAAAA,WAAW,EAAE,KAAKpB,OAAL,CAAaoB;AANW,KAAD,CAAtC;AASA,SAAKlC,cAAL,GAAsBA,cAAc,CAAC;AACnCyB,MAAAA,IAAI,EAAE,KAAKP,UADwB;AAEnCe,MAAAA,WAAW,EAAE,KAAKnB,OAAL,CAAamB,WAFS;AAGnCE,MAAAA,OAAO,EAAE,KAAKrB,OAAL,CAAaqB,OAHa;AAInCD,MAAAA,WAAW,EAAE,KAAKpB,OAAL,CAAaoB;AAJS,KAAD,CAApC;AAOA,SAAKE,KAAL,GAAa;AACXC,MAAAA,WAAW,EAAE;AADF,KAAb;;AAIA,QAAI,KAAKvB,OAAL,CAAaqB,OAAjB,EAA0B;AACxB,WAAKC,KAAL,CAAWE,WAAX,GAAyBzC,MAAM,CAAC,KAAKiB,OAAL,CAAaqB,OAAd,EAAuBvC,MAAM,EAA7B,CAA/B;AACD;;AAED,SAAK2C,QAAL,GAAgB,KAAKf,aAAL,CAAmB;AACjCgB,MAAAA,KAAK,EAAE,CAD0B;AAEjCC,MAAAA,IAAI,EAAE,KAAKL,KAAL,CAAWE;AAFgB,KAAnB,CAAhB;;AAIA,QAAI,CAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,EAAkB,KAAlB,EAAyBI,QAAzB,CAAkC,KAAK5B,OAAL,CAAa6B,KAA/C,CAAJ,EAA2D;AACzD,WAAKC,uBAAL;AACD;;AAEDpD,IAAAA,KAAK,CACF,gCAA+B,KAAK+C,QAAS,WAAUM,IAAI,CAACC,SAAL,CACtD,KAAKV,KADiD,CAEtD,EAHC,CAAL;;AAKA,SAAKW,iBAAL;AACD;;AAEDH,EAAAA,uBAAuB,GAAG;AACxB,QAAI;AACF,YAAMI,KAAK,GAAGtD,EAAE,CAACuD,QAAH,CAAY,KAAKV,QAAjB,CAAd;AACA,WAAKH,KAAL,CAAWC,WAAX,GAAyBW,KAAK,CAACE,IAA/B;;AACA,UAAI,KAAKpC,OAAL,CAAaqB,OAAjB,EAA0B;AACxB,aAAKC,KAAL,CAAWE,WAAX,GAAyBzC,MAAM,CAAC,KAAKiB,OAAL,CAAaqB,OAAd,EAAuBa,KAAK,CAACG,KAA7B,CAA/B;AACD;AACF,KAND,CAME,OAAOzC,CAAP,EAAU;AACV;AACA;AACD;AACF;;AAEDO,EAAAA,YAAY,CAACmC,UAAD,EAAa;AACvB,UAAMC,cAAc,GAAG;AACrBxB,MAAAA,OAAO,EAAEC,MAAM,CAACC,gBADK;AAErBuB,MAAAA,SAAS,EAAExB,MAAM,CAACC,gBAFG;AAGrBwB,MAAAA,QAAQ,EAAE,MAHW;AAIrBC,MAAAA,IAAI,EAAEC,QAAQ,CAAC,MAAD,EAAS,CAAT,CAJO;AAKrBd,MAAAA,KAAK,EAAE,GALc;AAMrBX,MAAAA,QAAQ,EAAE,KANW;AAOrBC,MAAAA,WAAW,EAAE,KAPQ;AAQrBN,MAAAA,oBAAoB,EAAE;AARD,KAAvB;AAUA,UAAMb,OAAO,GAAG4C,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBN,cAAlB,EAAkCD,UAAlC,CAAhB;;AACA,QAAItC,OAAO,CAACe,OAAR,IAAmB,CAAvB,EAA0B;AACxB,YAAM,IAAIb,KAAJ,CAAW,oBAAmBF,OAAO,CAACe,OAAQ,iBAA9C,CAAN;AACD,KAdsB,CAevB;;;AACA,QAAIf,OAAO,CAAC8C,UAAR,IAAsB9C,OAAO,CAAC8C,UAAR,KAAuB,CAAjD,EAAoD;AAClD,UAAI9C,OAAO,CAAC8C,UAAR,GAAqB,CAAzB,EAA4B;AAC1B,cAAM,IAAI5C,KAAJ,CAAW,uBAAsBF,OAAO,CAAC8C,UAAW,kBAApD,CAAN;AACD,OAFD,MAEO,IAAI9C,OAAO,CAAC8C,UAAR,IAAsB9B,MAAM,CAACC,gBAAjC,EAAmD;AACxD;AACA,cAAM,IAAIf,KAAJ,CAAW,uBAAsBF,OAAO,CAAC8C,UAAW,uCAApD,CAAN;AACD,OAHM,MAGA;AACL9C,QAAAA,OAAO,CAACwC,SAAR,GAAoBxC,OAAO,CAAC8C,UAAR,GAAqB,CAAzC;AACD;AACF,KATD,MASO,IAAI9C,OAAO,CAACwC,SAAR,IAAqB,CAAzB,EAA4B;AACjC,YAAM,IAAItC,KAAJ,CAAW,sBAAqBF,OAAO,CAACwC,SAAU,iBAAlD,CAAN;AACD;;AACD9D,IAAAA,KAAK,CACF,6CAA4CqD,IAAI,CAACC,SAAL,CAAehC,OAAf,CAAwB,EADlE,CAAL;AAGA,WAAOA,OAAP;AACD;;AAED+C,EAAAA,MAAM,CAACC,QAAD,EAAW;AACf,SAAKC,iBAAL,CAAuBC,GAAvB,CAA2B,EAA3B,EAA+B,KAAKlD,OAAL,CAAayC,QAA5C,EAAsDO,QAAtD;AACD;;AAEDG,EAAAA,MAAM,CAACC,KAAD,EAAQX,QAAR,EAAkBO,QAAlB,EAA4B;AAChC,SAAKK,WAAL,GAAmBC,IAAnB,CAAwB,MAAM;AAC5B5E,MAAAA,KAAK,CACF,yBAAD,GACG,QAAO,KAAKuE,iBAAL,CAAuBpE,IAAK,GADtC,GAEG,SAAQkD,IAAI,CAACC,SAAL,CAAe,KAAKV,KAApB,CAA2B,GAFtC,GAGG,SAAQ8B,KAAM,EAJd,CAAL;AAMA,WAAKH,iBAAL,CAAuBM,KAAvB,CAA6BH,KAA7B,EAAoCX,QAApC,EAA8C7C,CAAC,IAAI;AACjD,aAAK0B,KAAL,CAAWC,WAAX,IAA0B6B,KAAK,CAACnD,MAAhC;AACA+C,QAAAA,QAAQ,CAACpD,CAAD,CAAR;AACD,OAHD;AAID,KAXD;AAYD;;AAEKyD,EAAAA,WAAW,GAAG;AAAA;;AAAA;AAClB,UAAI,KAAI,CAACG,YAAL,MAAuB,KAAI,CAACC,OAAL,EAA3B,EAA2C;AACzC/E,QAAAA,KAAK,CACF,6CAA4C,KAAI,CAAC8E,YAAL,EAAoB,eAAc,KAAI,CAACC,OAAL,EAAe,EAD3F,CAAL;AAGA,cAAM,KAAI,CAACC,KAAL,EAAN;AACD;AANiB;AAOnB;;AAEDF,EAAAA,YAAY,GAAG;AACb,WACE,KAAKlC,KAAL,CAAWE,WAAX,IACA,KAAKF,KAAL,CAAWE,WAAX,KAA2BzC,MAAM,CAAC,KAAKiB,OAAL,CAAaqB,OAAd,EAAuBvC,MAAM,EAA7B,CAFnC;AAID;;AAED2E,EAAAA,OAAO,GAAG;AACR,WAAO,KAAKnC,KAAL,CAAWC,WAAX,IAA0B,KAAKvB,OAAL,CAAae,OAA9C;AACD;;AAED2C,EAAAA,KAAK,GAAG;AACNhF,IAAAA,KAAK,CAAE,mCAAF,CAAL;AACA,WAAO,IAAIY,OAAJ,CAAY,CAACqE,OAAD,EAAUC,MAAV,KAAqB;AACtC,WAAKX,iBAAL,CAAuBC,GAAvB,CAA2B,EAA3B,EAA+B,KAAKlD,OAAL,CAAayC,QAA5C,EAAsD,MAAM;AAC1D,aAAKoB,aAAL,GACGP,IADH,CACQK,OADR,EAEGhE,KAFH,CAESiE,MAFT;AAGD,OAJD;AAKD,KANM,CAAP;AAOD;;AAEKC,EAAAA,aAAa,GAAG;AAAA;;AAAA;AACpB,YAAMC,KAAK,SAAS,MAAI,CAACC,iBAAL,EAApB;AACA,YAAMC,WAAW,GAAG,MAAI,CAAC1C,KAAL,CAAWE,WAAX,GAChBsC,KAAK,CAACG,MAAN,CAAaxE,CAAC,IAAIA,CAAC,CAACkC,IAAF,KAAW,MAAI,CAACL,KAAL,CAAWE,WAAxC,CADgB,GAEhBsC,KAFJ;;AAGA,WAAK,IAAII,CAAC,GAAGF,WAAW,CAAC/D,MAAzB,EAAiCiE,CAAC,IAAI,CAAtC,EAAyCA,CAAC,EAA1C,EAA8C;AAC5CxF,QAAAA,KAAK,CAAE,sBAAqBwF,CAAE,EAAzB,CAAL;;AACA,cAAMC,cAAc,GAAG,MAAI,CAACzD,aAAL,CAAmB;AACxCiB,UAAAA,IAAI,EAAE,MAAI,CAACL,KAAL,CAAWE,WADuB;AAExCE,UAAAA,KAAK,EAAEwC;AAFiC,SAAnB,CAAvB;;AAIA,cAAME,cAAc,GAAG,MAAI,CAAC1D,aAAL,CAAmB;AACxCiB,UAAAA,IAAI,EAAE,MAAI,CAACL,KAAL,CAAWE,WADuB;AAExCE,UAAAA,KAAK,EAAEwC,CAAC,GAAG;AAF6B,SAAnB,CAAvB;;AAKA,cAAMG,sBAAsB,GAAG;AAC7BnD,UAAAA,QAAQ,EAAE,MAAI,CAAClB,OAAL,CAAakB,QAAb,IAAyBgD,CAAC,KAAK,CADZ;AAE7BxB,UAAAA,IAAI,EAAE,MAAI,CAAC1C,OAAL,CAAa0C;AAFU,SAA/B;AAIA,cAAMvD,wBAAwB,CAC5BgF,cAD4B,EAE5BC,cAF4B,EAG5BC,sBAH4B,CAA9B;AAKD;;AAED,MAAA,MAAI,CAAC/C,KAAL,CAAWC,WAAX,GAAyB,CAAzB;AACA,MAAA,MAAI,CAACD,KAAL,CAAWE,WAAX,GAAyB,MAAI,CAACF,KAAL,CAAWE,WAAX,GACrBzC,MAAM,CAAC,MAAI,CAACiB,OAAL,CAAaqB,OAAd,EAAuBvC,MAAM,EAA7B,CADe,GAErB,IAFJ;AAGAJ,MAAAA,KAAK,CACF,gDAA+CqD,IAAI,CAACC,SAAL,CAC9C,MAAI,CAACV,KADyC,CAE9C,EAHC,CAAL;;AAKA,MAAA,MAAI,CAACW,iBAAL,GApCoB,CAqCpB;AACA;;;AACA,YAAM,IAAI3C,OAAJ,CAAY,CAACqE,OAAD,EAAUC,MAAV,KAAqB;AACrC,QAAA,MAAI,CAACX,iBAAL,CAAuBM,KAAvB,CAA6B,EAA7B,EAAiC,MAAjC,EAAyC,MAAM;AAC7C,UAAA,MAAI,CAACe,MAAL,GACGhB,IADH,CACQK,OADR,EAEGhE,KAFH,CAESiE,MAFT;AAGD,SAJD;AAKD,OANK,CAAN;AAvCoB;AA8CrB,GAlN2C,CAoN5C;;;AACMG,EAAAA,iBAAiB,GAAG;AAAA;;AAAA;AACxB,YAAMD,KAAK,SAASlF,EAAE,CAAC2F,OAAH,CAAW,MAAI,CAACnE,UAAL,CAAgBE,GAA3B,EACjBX,KADiB;AACV;AAAuD,YAAM,EADnD,CAApB;AAGAjB,MAAAA,KAAK,CAAE,4BAA2BoF,KAAM,EAAnC,CAAL;AACA,YAAMU,mBAAmB,GAAGV,KAAK,CAC9BtE,GADyB,CACrBiF,CAAC,IAAI,MAAI,CAACvF,cAAL,CAAoBuF,CAApB,CADgB,EAEzBR,MAFyB,CAElBQ,CAAC,IAAIA,CAFa,CAA5B;;AAIA,YAAMC,MAAM,GAAGD,CAAC,IACd,CAACA,CAAC,CAACE,SAAF,GAAcF,CAAC,CAACE,SAAhB,GAA4B7F,MAAM,GAAG8F,OAAT,EAA7B,IAAmDH,CAAC,CAAC/C,KADvD;;AAEA8C,MAAAA,mBAAmB,CAACK,IAApB,CAAyB,CAACC,CAAD,EAAIC,CAAJ,KAAUL,MAAM,CAACI,CAAD,CAAN,GAAYJ,MAAM,CAACK,CAAD,CAArD;AAEA,aAAOP,mBAAP;AAbwB;AAczB;;AAEDvC,EAAAA,iBAAiB,GAAG;AAClB,UAAM+C,KAAK,GAAI1E,GAAD,IAAS;AACrB,UAAI;AACF,eAAO1B,EAAE,CAACqG,SAAH,CAAa3E,GAAb,EAAkB;AAAC4E,UAAAA,SAAS,EAAE;AAAZ,SAAlB,CAAP;AACD,OAFD,CAGA;AACA,aAAOtF,CAAP,EAAU;AACR;AACA,YAAIA,CAAC,CAACuF,IAAF,KAAW,QAAf,EAAyB;AACvBH,UAAAA,KAAK,CAACnG,IAAI,CAACuG,OAAL,CAAa9E,GAAb,CAAD,CAAL;AACA,iBAAO0E,KAAK,CAAC1E,GAAD,CAAZ;AACD,SALO,CAOR;;;AACA,YAAIV,CAAC,CAACuF,IAAF,KAAW,QAAX,IAAuBvF,CAAC,CAACuF,IAAF,KAAW,OAAtC,EAA+C;AAC7C,gBAAMvF,CAAN;AACD,SAFD,CAIA;AACA;AALA,aAMK;AACH,cAAI;AACF,gBAAIhB,EAAE,CAACuD,QAAH,CAAY7B,GAAZ,EAAiB+E,WAAjB,EAAJ,EAAoC;AAClC,qBAAO/E,GAAP;AACD;;AACD,kBAAMV,CAAN;AACD,WALD,CAKE,OAAO0F,GAAP,EAAY;AACZ,kBAAM1F,CAAN;AACD;AACF;AACF;AACF,KA9BD;;AA+BAoF,IAAAA,KAAK,CAAC,KAAK5E,UAAL,CAAgBE,GAAjB,CAAL;AACA,UAAMP,QAAQ,GAAG,KAAKW,aAAL,CAAmB;AAClCiB,MAAAA,IAAI,EAAE,KAAKL,KAAL,CAAWE,WADiB;AAElCE,MAAAA,KAAK,EAAE;AAF2B,KAAnB,CAAjB;AAIA,UAAM6D,GAAG,GAAG;AACV1D,MAAAA,KAAK,EAAE,KAAK7B,OAAL,CAAa6B,KADV;AAEVY,MAAAA,QAAQ,EAAE,KAAKzC,OAAL,CAAayC,QAFb;AAGVC,MAAAA,IAAI,EAAE,KAAK1C,OAAL,CAAa0C;AAHT,KAAZ;AAKA,SAAKO,iBAAL,GAAyBrE,EAAE,CAAC4G,iBAAH,CAAqBzF,QAArB,EAA+BwF,GAA/B,CAAzB;AACA,SAAKtC,iBAAL,CAAuBwC,EAAvB,CAA0B,OAA1B,EAAmC7F,CAAC,IAAI;AACtC,WAAK8F,IAAL,CAAU,OAAV,EAAmB9F,CAAnB;AACD,KAFD;AAGD;;AAEK0E,EAAAA,MAAM,GAAG;AAAA;;AAAA;AACb,YAAME,mBAAmB,SAAS,MAAI,CAACT,iBAAL,EAAlC;AACArF,MAAAA,KAAK,CACF,uBAAsB,MAAI,CAACsB,OAAL,CAAawC,SAAU,qBAAoBgC,mBAAmB,CAACvE,MAAO,EAD1F,CAAL;AAGAvB,MAAAA,KAAK,CAAC,8BAAD,EAAiC8F,mBAAjC,CAAL;;AACA,UAAI,MAAI,CAACmB,aAAL,CAAmBnB,mBAAmB,CAACvE,MAAvC,CAAJ,EAAoD;AAClD,cAAM2F,iBAAiB,GAAGpB,mBAAmB,CAC1CqB,KADuB,CACjB,CADiB,EACdrB,mBAAmB,CAACvE,MAApB,GAA6B,MAAI,CAACD,OAAL,CAAawC,SAD5B,EAEvBhD,GAFuB,CAEnBC,CAAC,IAAIZ,IAAI,CAACE,MAAL,CAAY;AAAEuB,UAAAA,GAAG,EAAE,MAAI,CAACF,UAAL,CAAgBE,GAAvB;AAA4BwF,UAAAA,IAAI,EAAErG,CAAC,CAACgC;AAApC,SAAZ,CAFc,CAA1B;AAGA,cAAMrC,WAAW,CAACwG,iBAAD,CAAjB;AACD;AAXY;AAYd;;AAEDD,EAAAA,aAAa,CAACI,QAAD,EAAW;AACtB,WAAO,KAAK/F,OAAL,CAAawC,SAAb,GAAyB,CAAzB,IAA8BuD,QAAQ,GAAG,KAAK/F,OAAL,CAAawC,SAA7D;AACD;;AArS2C;;AAwS9CwD,MAAM,CAACC,OAAP,GAAiBpG,sBAAjB","sourcesContent":["const debug = require(\"debug\")(\"streamroller:RollingFileWriteStream\");\nconst fs = require(\"fs-extra\");\nconst path = require(\"path\");\nconst newNow = require(\"./now\");\nconst format = require(\"date-format\");\nconst { Writable } = require(\"stream\");\nconst fileNameFormatter = require(\"./fileNameFormatter\");\nconst fileNameParser = require(\"./fileNameParser\");\nconst moveAndMaybeCompressFile = require(\"./moveAndMaybeCompressFile\");\n\nconst deleteFiles = fileNames => {\n  debug(`deleteFiles: files to delete: ${fileNames}`);\n  return Promise.all(fileNames.map(f => fs.unlink(f).catch((e) => {\n    debug(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);\n  })));\n};\n\n/**\n * RollingFileWriteStream is mainly used when writing to a file rolling by date or size.\n * RollingFileWriteStream inherits from stream.Writable\n */\nclass RollingFileWriteStream extends Writable {\n  /**\n   * Create a RollingFileWriteStream\n   * @constructor\n   * @param {string} filePath - The file path to write.\n   * @param {object} options - The extra options\n   * @param {number} options.numToKeep - The max numbers of files to keep.\n   * @param {number} options.maxSize - The maxSize one file can reach. Unit is Byte.\n   *                                   This should be more than 1024. The default is Number.MAX_SAFE_INTEGER.\n   * @param {string} options.mode - The mode of the files. The default is '0600'. Refer to stream.writable for more.\n   * @param {string} options.flags - The default is 'a'. Refer to stream.flags for more.\n   * @param {boolean} options.compress - Whether to compress backup files.\n   * @param {boolean} options.keepFileExt - Whether to keep the file extension.\n   * @param {string} options.pattern - The date string pattern in the file name.\n   * @param {boolean} options.alwaysIncludePattern - Whether to add date to the name of the first file.\n   */\n  constructor(filePath, options) {\n    debug(`constructor: creating RollingFileWriteStream. path=${filePath}`);\n    if (typeof filePath !== \"string\" || filePath.length === 0) {\n      throw new Error(`Invalid filename: ${filePath}`);\n    }\n    super(options);\n    this.options = this._parseOption(options);\n    this.fileObject = path.parse(filePath);\n    if (this.fileObject.dir === \"\") {\n      this.fileObject = path.parse(path.join(process.cwd(), filePath));\n    }\n    this.fileFormatter = fileNameFormatter({\n      file: this.fileObject,\n      alwaysIncludeDate: this.options.alwaysIncludePattern,\n      needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,\n      compress: this.options.compress,\n      keepFileExt: this.options.keepFileExt,\n      fileNameSep: this.options.fileNameSep\n    });\n\n    this.fileNameParser = fileNameParser({\n      file: this.fileObject,\n      keepFileExt: this.options.keepFileExt,\n      pattern: this.options.pattern,\n      fileNameSep: this.options.fileNameSep\n    });\n\n    this.state = {\n      currentSize: 0\n    };\n\n    if (this.options.pattern) {\n      this.state.currentDate = format(this.options.pattern, newNow());\n    }\n\n    this.filename = this.fileFormatter({\n      index: 0,\n      date: this.state.currentDate\n    });\n    if ([\"a\", \"a+\", \"as\", \"as+\"].includes(this.options.flags)) {\n      this._setExistingSizeAndDate();\n    }\n\n    debug(\n      `constructor: create new file ${this.filename}, state=${JSON.stringify(\n        this.state\n      )}`\n    );\n    this._renewWriteStream();\n  }\n\n  _setExistingSizeAndDate() {\n    try {\n      const stats = fs.statSync(this.filename);\n      this.state.currentSize = stats.size;\n      if (this.options.pattern) {\n        this.state.currentDate = format(this.options.pattern, stats.mtime);\n      }\n    } catch (e) {\n      //file does not exist, that's fine - move along\n      return;\n    }\n  }\n\n  _parseOption(rawOptions) {\n    const defaultOptions = {\n      maxSize: Number.MAX_SAFE_INTEGER,\n      numToKeep: Number.MAX_SAFE_INTEGER,\n      encoding: \"utf8\",\n      mode: parseInt(\"0600\", 8),\n      flags: \"a\",\n      compress: false,\n      keepFileExt: false,\n      alwaysIncludePattern: false\n    };\n    const options = Object.assign({}, defaultOptions, rawOptions);\n    if (options.maxSize <= 0) {\n      throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);\n    }\n    // options.numBackups will supercede options.numToKeep\n    if (options.numBackups || options.numBackups === 0) {\n      if (options.numBackups < 0) {\n        throw new Error(`options.numBackups (${options.numBackups}) should be >= 0`);\n      } else if (options.numBackups >= Number.MAX_SAFE_INTEGER) {\n        // to cater for numToKeep (include the hot file) at Number.MAX_SAFE_INTEGER\n        throw new Error(`options.numBackups (${options.numBackups}) should be < Number.MAX_SAFE_INTEGER`);\n      } else {\n        options.numToKeep = options.numBackups + 1;\n      }\n    } else if (options.numToKeep <= 0) {\n      throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);\n    }\n    debug(\n      `_parseOption: creating stream with option=${JSON.stringify(options)}`\n    );\n    return options;\n  }\n\n  _final(callback) {\n    this.currentFileStream.end(\"\", this.options.encoding, callback);\n  }\n\n  _write(chunk, encoding, callback) {\n    this._shouldRoll().then(() => {\n      debug(\n        `_write: writing chunk. ` +\n          `file=${this.currentFileStream.path} ` +\n          `state=${JSON.stringify(this.state)} ` +\n          `chunk=${chunk}`\n      );\n      this.currentFileStream.write(chunk, encoding, e => {\n        this.state.currentSize += chunk.length;\n        callback(e);\n      });\n    });\n  }\n\n  async _shouldRoll() {\n    if (this._dateChanged() || this._tooBig()) {\n      debug(\n        `_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`\n      );\n      await this._roll();\n    }\n  }\n\n  _dateChanged() {\n    return (\n      this.state.currentDate &&\n      this.state.currentDate !== format(this.options.pattern, newNow())\n    );\n  }\n\n  _tooBig() {\n    return this.state.currentSize >= this.options.maxSize;\n  }\n\n  _roll() {\n    debug(`_roll: closing the current stream`);\n    return new Promise((resolve, reject) => {\n      this.currentFileStream.end(\"\", this.options.encoding, () => {\n        this._moveOldFiles()\n          .then(resolve)\n          .catch(reject);\n      });\n    });\n  }\n\n  async _moveOldFiles() {\n    const files = await this._getExistingFiles();\n    const todaysFiles = this.state.currentDate\n      ? files.filter(f => f.date === this.state.currentDate)\n      : files;\n    for (let i = todaysFiles.length; i >= 0; i--) {\n      debug(`_moveOldFiles: i = ${i}`);\n      const sourceFilePath = this.fileFormatter({\n        date: this.state.currentDate,\n        index: i\n      });\n      const targetFilePath = this.fileFormatter({\n        date: this.state.currentDate,\n        index: i + 1\n      });\n\n      const moveAndCompressOptions = {\n        compress: this.options.compress && i === 0,\n        mode: this.options.mode\n      }\n      await moveAndMaybeCompressFile(\n        sourceFilePath,\n        targetFilePath,\n        moveAndCompressOptions                \n      );\n    }\n\n    this.state.currentSize = 0;\n    this.state.currentDate = this.state.currentDate\n      ? format(this.options.pattern, newNow())\n      : null;\n    debug(\n      `_moveOldFiles: finished rolling files. state=${JSON.stringify(\n        this.state\n      )}`\n    );\n    this._renewWriteStream();\n    // wait for the file to be open before cleaning up old ones,\n    // otherwise the daysToKeep calculations can be off\n    await new Promise((resolve, reject) => {\n      this.currentFileStream.write(\"\", \"utf8\", () => {\n        this._clean()\n          .then(resolve)\n          .catch(reject);\n      });\n    });\n  }\n\n  // Sorted from the oldest to the latest\n  async _getExistingFiles() {\n    const files = await fs.readdir(this.fileObject.dir)\n      .catch( /* istanbul ignore next: will not happen on windows */ () => []);\n\n    debug(`_getExistingFiles: files=${files}`);\n    const existingFileDetails = files\n      .map(n => this.fileNameParser(n))\n      .filter(n => n);\n\n    const getKey = n =>\n      (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;\n    existingFileDetails.sort((a, b) => getKey(a) - getKey(b));\n\n    return existingFileDetails;\n  }\n\n  _renewWriteStream() {\n    const mkdir = (dir) => {\n      try {\n        return fs.mkdirSync(dir, {recursive: true});\n      }\n      // backward-compatible fs.mkdirSync for nodejs pre-10.12.0 (without recursive option)\n      catch (e) {\n        // recursive creation of parent first\n        if (e.code === \"ENOENT\") {\n          mkdir(path.dirname(dir));\n          return mkdir(dir);\n        }\n\n        // throw error for all except EEXIST and EROFS (read-only filesystem)\n        if (e.code !== \"EEXIST\" && e.code !== \"EROFS\") {\n          throw e;\n        }\n\n        // EEXIST: throw if file and not directory\n        // EROFS : throw if directory not found\n        else {\n          try {\n            if (fs.statSync(dir).isDirectory()) {\n              return dir;\n            }\n            throw e;\n          } catch (err) {\n            throw e;\n          }\n        }\n      }\n    };\n    mkdir(this.fileObject.dir);\n    const filePath = this.fileFormatter({\n      date: this.state.currentDate,\n      index: 0\n    });\n    const ops = {\n      flags: this.options.flags,\n      encoding: this.options.encoding,\n      mode: this.options.mode\n    };\n    this.currentFileStream = fs.createWriteStream(filePath, ops);\n    this.currentFileStream.on(\"error\", e => {\n      this.emit(\"error\", e);\n    });\n  }\n\n  async _clean() {\n    const existingFileDetails = await this._getExistingFiles();\n    debug(\n      `_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`\n    );\n    debug(\"_clean: existing files are: \", existingFileDetails);\n    if (this._tooManyFiles(existingFileDetails.length)) {\n      const fileNamesToRemove = existingFileDetails\n        .slice(0, existingFileDetails.length - this.options.numToKeep)\n        .map(f => path.format({ dir: this.fileObject.dir, base: f.filename }));\n      await deleteFiles(fileNamesToRemove);\n    }\n  }\n\n  _tooManyFiles(numFiles) {\n    return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;\n  }\n}\n\nmodule.exports = RollingFileWriteStream;\n"]},"metadata":{},"sourceType":"script"}