{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scheduleTargetAndForget = exports.targetFromTargetString = exports.targetStringFromTarget = exports.fromAsyncIterable = exports.isBuilderOutput = exports.BuilderProgressState = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst progress_schema_1 = require(\"./progress-schema\");\n\nObject.defineProperty(exports, \"BuilderProgressState\", {\n  enumerable: true,\n  get: function () {\n    return progress_schema_1.State;\n  }\n}); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nfunction isBuilderOutput(obj) {\n  if (!obj || typeof obj.then === 'function' || typeof obj.subscribe === 'function') {\n    return false;\n  }\n\n  if (typeof obj[Symbol.asyncIterator] === 'function') {\n    return false;\n  }\n\n  return typeof obj.success === 'boolean';\n}\n\nexports.isBuilderOutput = isBuilderOutput;\n\nfunction fromAsyncIterable(iterable) {\n  return new rxjs_1.Observable(subscriber => {\n    handleAsyncIterator(subscriber, iterable[Symbol.asyncIterator]()).then(() => subscriber.complete(), error => subscriber.error(error));\n  });\n}\n\nexports.fromAsyncIterable = fromAsyncIterable;\n\nfunction handleAsyncIterator(_x, _x2) {\n  return _handleAsyncIterator.apply(this, arguments);\n}\n/**\n * Returns a string of \"project:target[:configuration]\" for the target object.\n */\n\n\nfunction _handleAsyncIterator() {\n  _handleAsyncIterator = _asyncToGenerator(function* (subscriber, iterator) {\n    var _a;\n\n    const teardown = new Promise(resolve => subscriber.add(() => resolve()));\n\n    try {\n      while (!subscriber.closed) {\n        const result = yield Promise.race([teardown, iterator.next()]);\n\n        if (!result || result.done) {\n          break;\n        }\n\n        subscriber.next(result.value);\n      }\n    } finally {\n      yield (_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator);\n    }\n  });\n  return _handleAsyncIterator.apply(this, arguments);\n}\n\nfunction targetStringFromTarget({\n  project,\n  target,\n  configuration\n}) {\n  return `${project}:${target}${configuration !== undefined ? ':' + configuration : ''}`;\n}\n\nexports.targetStringFromTarget = targetStringFromTarget;\n/**\n * Return a Target tuple from a string.\n */\n\nfunction targetFromTargetString(str) {\n  const tuple = str.split(/:/, 3);\n\n  if (tuple.length < 2) {\n    throw new Error('Invalid target string: ' + JSON.stringify(str));\n  }\n\n  return {\n    project: tuple[0],\n    target: tuple[1],\n    ...(tuple[2] !== undefined && {\n      configuration: tuple[2]\n    })\n  };\n}\n\nexports.targetFromTargetString = targetFromTargetString;\n/**\n * Schedule a target, and forget about its run. This will return an observable of outputs, that\n * as a a teardown will stop the target from running. This means that the Run object this returns\n * should not be shared.\n *\n * The reason this is not part of the Context interface is to keep the Context as normal form as\n * possible. This is really an utility that people would implement in their project.\n *\n * @param context The context of your current execution.\n * @param target The target to schedule.\n * @param overrides Overrides that are used in the target.\n * @param scheduleOptions Additional scheduling options.\n */\n\nfunction scheduleTargetAndForget(context, target, overrides, scheduleOptions) {\n  let resolve = null;\n  const promise = new Promise(r => resolve = r);\n  context.addTeardown(() => promise);\n  return (0, rxjs_1.from)(context.scheduleTarget(target, overrides, scheduleOptions)).pipe((0, operators_1.switchMap)(run => new rxjs_1.Observable(observer => {\n    const subscription = run.output.subscribe(observer);\n    return () => {\n      subscription.unsubscribe(); // We can properly ignore the floating promise as it's a \"reverse\" promise; the teardown\n      // is waiting for the resolve.\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n      run.stop().then(resolve);\n    };\n  })));\n}\n\nexports.scheduleTargetAndForget = scheduleTargetAndForget;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/@angular-devkit/architect/src/api.js"],"names":["Object","defineProperty","exports","value","scheduleTargetAndForget","targetFromTargetString","targetStringFromTarget","fromAsyncIterable","isBuilderOutput","BuilderProgressState","rxjs_1","require","operators_1","progress_schema_1","enumerable","get","State","obj","then","subscribe","Symbol","asyncIterator","success","iterable","Observable","subscriber","handleAsyncIterator","complete","error","iterator","_a","teardown","Promise","resolve","add","closed","result","race","next","done","return","call","project","target","configuration","undefined","str","tuple","split","length","Error","JSON","stringify","context","overrides","scheduleOptions","promise","r","addTeardown","from","scheduleTarget","pipe","switchMap","run","observer","subscription","output","unsubscribe","stop"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scheduleTargetAndForget = exports.targetFromTargetString = exports.targetStringFromTarget = exports.fromAsyncIterable = exports.isBuilderOutput = exports.BuilderProgressState = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst progress_schema_1 = require(\"./progress-schema\");\nObject.defineProperty(exports, \"BuilderProgressState\", { enumerable: true, get: function () { return progress_schema_1.State; } });\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isBuilderOutput(obj) {\n    if (!obj || typeof obj.then === 'function' || typeof obj.subscribe === 'function') {\n        return false;\n    }\n    if (typeof obj[Symbol.asyncIterator] === 'function') {\n        return false;\n    }\n    return typeof obj.success === 'boolean';\n}\nexports.isBuilderOutput = isBuilderOutput;\nfunction fromAsyncIterable(iterable) {\n    return new rxjs_1.Observable((subscriber) => {\n        handleAsyncIterator(subscriber, iterable[Symbol.asyncIterator]()).then(() => subscriber.complete(), (error) => subscriber.error(error));\n    });\n}\nexports.fromAsyncIterable = fromAsyncIterable;\nasync function handleAsyncIterator(subscriber, iterator) {\n    var _a;\n    const teardown = new Promise((resolve) => subscriber.add(() => resolve()));\n    try {\n        while (!subscriber.closed) {\n            const result = await Promise.race([teardown, iterator.next()]);\n            if (!result || result.done) {\n                break;\n            }\n            subscriber.next(result.value);\n        }\n    }\n    finally {\n        await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator));\n    }\n}\n/**\n * Returns a string of \"project:target[:configuration]\" for the target object.\n */\nfunction targetStringFromTarget({ project, target, configuration }) {\n    return `${project}:${target}${configuration !== undefined ? ':' + configuration : ''}`;\n}\nexports.targetStringFromTarget = targetStringFromTarget;\n/**\n * Return a Target tuple from a string.\n */\nfunction targetFromTargetString(str) {\n    const tuple = str.split(/:/, 3);\n    if (tuple.length < 2) {\n        throw new Error('Invalid target string: ' + JSON.stringify(str));\n    }\n    return {\n        project: tuple[0],\n        target: tuple[1],\n        ...(tuple[2] !== undefined && { configuration: tuple[2] }),\n    };\n}\nexports.targetFromTargetString = targetFromTargetString;\n/**\n * Schedule a target, and forget about its run. This will return an observable of outputs, that\n * as a a teardown will stop the target from running. This means that the Run object this returns\n * should not be shared.\n *\n * The reason this is not part of the Context interface is to keep the Context as normal form as\n * possible. This is really an utility that people would implement in their project.\n *\n * @param context The context of your current execution.\n * @param target The target to schedule.\n * @param overrides Overrides that are used in the target.\n * @param scheduleOptions Additional scheduling options.\n */\nfunction scheduleTargetAndForget(context, target, overrides, scheduleOptions) {\n    let resolve = null;\n    const promise = new Promise((r) => (resolve = r));\n    context.addTeardown(() => promise);\n    return (0, rxjs_1.from)(context.scheduleTarget(target, overrides, scheduleOptions)).pipe((0, operators_1.switchMap)((run) => new rxjs_1.Observable((observer) => {\n        const subscription = run.output.subscribe(observer);\n        return () => {\n            subscription.unsubscribe();\n            // We can properly ignore the floating promise as it's a \"reverse\" promise; the teardown\n            // is waiting for the resolve.\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            run.stop().then(resolve);\n        };\n    })));\n}\nexports.scheduleTargetAndForget = scheduleTargetAndForget;\n"]},"metadata":{},"sourceType":"script"}