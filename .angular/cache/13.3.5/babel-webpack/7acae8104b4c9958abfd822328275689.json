{"ast":null,"code":"var _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nvar _asyncIterator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncIterator.js\").default;\n\nconst {\n  isReadableStream\n} = require('./utils');\n\nconst TextDecoder = require('./text-decoder');\n\nconst STACK_OBJECT = 1;\nconst STACK_ARRAY = 2;\nconst decoder = new TextDecoder();\n\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\nfunction adjustPosition(error, parser) {\n  if (error.name === 'SyntaxError' && parser.jsonParseOffset) {\n    error.message = error.message.replace(/at position (\\d+)/, (_, pos) => 'at position ' + (Number(pos) + parser.jsonParseOffset));\n  }\n\n  return error;\n}\n\nfunction append(array, elements) {\n  // Note: Avoid to use array.push(...elements) since it may lead to\n  // \"RangeError: Maximum call stack size exceeded\" for a long arrays\n  const initialLength = array.length;\n  array.length += elements.length;\n\n  for (let i = 0; i < elements.length; i++) {\n    array[initialLength + i] = elements[i];\n  }\n}\n\nmodule.exports = function (chunkEmitter) {\n  let parser = new ChunkParser();\n\n  if (isObject(chunkEmitter) && isReadableStream(chunkEmitter)) {\n    return new Promise((resolve, reject) => {\n      chunkEmitter.on('data', chunk => {\n        try {\n          parser.push(chunk);\n        } catch (e) {\n          reject(adjustPosition(e, parser));\n          parser = null;\n        }\n      }).on('error', e => {\n        parser = null;\n        reject(e);\n      }).on('end', () => {\n        try {\n          resolve(parser.finish());\n        } catch (e) {\n          reject(adjustPosition(e, parser));\n        } finally {\n          parser = null;\n        }\n      });\n    });\n  }\n\n  if (typeof chunkEmitter === 'function') {\n    const iterator = chunkEmitter();\n\n    if (isObject(iterator) && (Symbol.iterator in iterator || Symbol.asyncIterator in iterator)) {\n      return new Promise( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (resolve, reject) {\n          try {\n            var _iteratorAbruptCompletion = false;\n            var _didIteratorError = false;\n\n            var _iteratorError;\n\n            try {\n              for (var _iterator = _asyncIterator(iterator), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n                const chunk = _step.value;\n                parser.push(chunk);\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (_iteratorAbruptCompletion && _iterator.return != null) {\n                  yield _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            resolve(parser.finish());\n          } catch (e) {\n            reject(adjustPosition(e, parser));\n          } finally {\n            parser = null;\n          }\n        });\n\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n  }\n\n  throw new Error('Chunk emitter should be readable stream, generator, ' + 'async generator or function returning an iterable object');\n};\n\nclass ChunkParser {\n  constructor() {\n    this.value = undefined;\n    this.valueStack = null;\n    this.stack = new Array(100);\n    this.lastFlushDepth = 0;\n    this.flushDepth = 0;\n    this.stateString = false;\n    this.stateStringEscape = false;\n    this.pendingByteSeq = null;\n    this.pendingChunk = null;\n    this.chunkOffset = 0;\n    this.jsonParseOffset = 0;\n  }\n\n  parseAndAppend(fragment, wrap) {\n    // Append new entries or elements\n    if (this.stack[this.lastFlushDepth - 1] === STACK_OBJECT) {\n      if (wrap) {\n        this.jsonParseOffset--;\n        fragment = '{' + fragment + '}';\n      }\n\n      Object.assign(this.valueStack.value, JSON.parse(fragment));\n    } else {\n      if (wrap) {\n        this.jsonParseOffset--;\n        fragment = '[' + fragment + ']';\n      }\n\n      append(this.valueStack.value, JSON.parse(fragment));\n    }\n  }\n\n  prepareAddition(fragment) {\n    const {\n      value\n    } = this.valueStack;\n    const expectComma = Array.isArray(value) ? value.length !== 0 : Object.keys(value).length !== 0;\n\n    if (expectComma) {\n      // Skip a comma at the beginning of fragment, otherwise it would\n      // fail to parse\n      if (fragment[0] === ',') {\n        this.jsonParseOffset++;\n        return fragment.slice(1);\n      } // When value (an object or array) is not empty and a fragment\n      // doesn't start with a comma, a single valid fragment starting\n      // is a closing bracket. If it's not, a prefix is adding to fail\n      // parsing. Otherwise, the sequence of chunks can be successfully\n      // parsed, although it should not, e.g. [\"[{}\", \"{}]\"]\n\n\n      if (fragment[0] !== '}' && fragment[0] !== ']') {\n        this.jsonParseOffset -= 3;\n        return '[[]' + fragment;\n      }\n    }\n\n    return fragment;\n  }\n\n  flush(chunk, start, end) {\n    let fragment = chunk.slice(start, end); // Save position correction an error in JSON.parse() if any\n\n    this.jsonParseOffset = this.chunkOffset + start; // Prepend pending chunk if any\n\n    if (this.pendingChunk !== null) {\n      fragment = this.pendingChunk + fragment;\n      this.jsonParseOffset -= this.pendingChunk.length;\n      this.pendingChunk = null;\n    }\n\n    if (this.flushDepth === this.lastFlushDepth) {\n      // Depth didn't changed, so it's a root value or entry/element set\n      if (this.flushDepth > 0) {\n        this.parseAndAppend(this.prepareAddition(fragment), true);\n      } else {\n        // That's an entire value on a top level\n        this.value = JSON.parse(fragment);\n        this.valueStack = {\n          value: this.value,\n          prev: null\n        };\n      }\n    } else if (this.flushDepth > this.lastFlushDepth) {\n      // Add missed closing brackets/parentheses\n      for (let i = this.flushDepth - 1; i >= this.lastFlushDepth; i--) {\n        fragment += this.stack[i] === STACK_OBJECT ? '}' : ']';\n      }\n\n      if (this.lastFlushDepth === 0) {\n        // That's a root value\n        this.value = JSON.parse(fragment);\n        this.valueStack = {\n          value: this.value,\n          prev: null\n        };\n      } else {\n        this.parseAndAppend(this.prepareAddition(fragment), true);\n      } // Move down to the depths to the last object/array, which is current now\n\n\n      for (let i = this.lastFlushDepth || 1; i < this.flushDepth; i++) {\n        let value = this.valueStack.value;\n\n        if (this.stack[i - 1] === STACK_OBJECT) {\n          // find last entry\n          let key; // eslint-disable-next-line curly\n\n          for (key in value);\n\n          value = value[key];\n        } else {\n          // last element\n          value = value[value.length - 1];\n        }\n\n        this.valueStack = {\n          value,\n          prev: this.valueStack\n        };\n      }\n    } else\n      /* this.flushDepth < this.lastFlushDepth */\n      {\n        fragment = this.prepareAddition(fragment); // Add missed opening brackets/parentheses\n\n        for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n          this.jsonParseOffset--;\n          fragment = (this.stack[i] === STACK_OBJECT ? '{' : '[') + fragment;\n        }\n\n        this.parseAndAppend(fragment, false);\n\n        for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n          this.valueStack = this.valueStack.prev;\n        }\n      }\n\n    this.lastFlushDepth = this.flushDepth;\n  }\n\n  push(chunk) {\n    if (typeof chunk !== 'string') {\n      // Suppose chunk is Buffer or Uint8Array\n      // Prepend uncompleted byte sequence if any\n      if (this.pendingByteSeq !== null) {\n        const origRawChunk = chunk;\n        chunk = new Uint8Array(this.pendingByteSeq.length + origRawChunk.length);\n        chunk.set(this.pendingByteSeq);\n        chunk.set(origRawChunk, this.pendingByteSeq.length);\n        this.pendingByteSeq = null;\n      } // In case Buffer/Uint8Array, an input is encoded in UTF8\n      // Seek for parts of uncompleted UTF8 symbol on the ending\n      // This makes sense only if we expect more chunks and last char is not multi-bytes\n\n\n      if (chunk[chunk.length - 1] > 127) {\n        for (let seqLength = 0; seqLength < chunk.length; seqLength++) {\n          const byte = chunk[chunk.length - 1 - seqLength]; // 10xxxxxx - 2nd, 3rd or 4th byte\n          // 110xxxxx â€“ first byte of 2-byte sequence\n          // 1110xxxx - first byte of 3-byte sequence\n          // 11110xxx - first byte of 4-byte sequence\n\n          if (byte >> 6 === 3) {\n            seqLength++; // If the sequence is really incomplete, then preserve it\n            // for the future chunk and cut off it from the current chunk\n\n            if (seqLength !== 4 && byte >> 3 === 0b11110 || seqLength !== 3 && byte >> 4 === 0b1110 || seqLength !== 2 && byte >> 5 === 0b110) {\n              this.pendingByteSeq = chunk.slice(chunk.length - seqLength);\n              chunk = chunk.slice(0, -seqLength);\n            }\n\n            break;\n          }\n        }\n      } // Convert chunk to a string, since single decode per chunk\n      // is much effective than decode multiple small substrings\n\n\n      chunk = decoder.decode(chunk);\n    }\n\n    const chunkLength = chunk.length;\n    let lastFlushPoint = 0;\n    let flushPoint = 0; // Main scan loop\n\n    scan: for (let i = 0; i < chunkLength; i++) {\n      if (this.stateString) {\n        for (; i < chunkLength; i++) {\n          if (this.stateStringEscape) {\n            this.stateStringEscape = false;\n          } else {\n            switch (chunk.charCodeAt(i)) {\n              case 0x22:\n                /* \" */\n                this.stateString = false;\n                continue scan;\n\n              case 0x5C:\n                /* \\ */\n                this.stateStringEscape = true;\n            }\n          }\n        }\n\n        break;\n      }\n\n      switch (chunk.charCodeAt(i)) {\n        case 0x22:\n          /* \" */\n          this.stateString = true;\n          this.stateStringEscape = false;\n          break;\n\n        case 0x2C:\n          /* , */\n          flushPoint = i;\n          break;\n\n        case 0x7B:\n          /* { */\n          // Open an object\n          flushPoint = i + 1;\n          this.stack[this.flushDepth++] = STACK_OBJECT;\n          break;\n\n        case 0x5B:\n          /* [ */\n          // Open an array\n          flushPoint = i + 1;\n          this.stack[this.flushDepth++] = STACK_ARRAY;\n          break;\n\n        case 0x5D:\n        /* ] */\n\n        case 0x7D:\n          /* } */\n          // Close an object or array\n          flushPoint = i + 1;\n          this.flushDepth--;\n\n          if (this.flushDepth < this.lastFlushDepth) {\n            this.flush(chunk, lastFlushPoint, flushPoint);\n            lastFlushPoint = flushPoint;\n          }\n\n          break;\n\n        case 0x09:\n        /* \\t */\n\n        case 0x0A:\n        /* \\n */\n\n        case 0x0D:\n        /* \\r */\n\n        case 0x20:\n          /* space */\n          // Move points forward when they points on current position and it's a whitespace\n          if (lastFlushPoint === i) {\n            lastFlushPoint++;\n          }\n\n          if (flushPoint === i) {\n            flushPoint++;\n          }\n\n          break;\n      }\n    }\n\n    if (flushPoint > lastFlushPoint) {\n      this.flush(chunk, lastFlushPoint, flushPoint);\n    } // Produce pendingChunk if something left\n\n\n    if (flushPoint < chunkLength) {\n      if (this.pendingChunk !== null) {\n        // When there is already a pending chunk then no flush happened,\n        // appending entire chunk to pending one\n        this.pendingChunk += chunk;\n      } else {\n        // Create a pending chunk, it will start with non-whitespace since\n        // flushPoint was moved forward away from whitespaces on scan\n        this.pendingChunk = chunk.slice(flushPoint, chunkLength);\n      }\n    }\n\n    this.chunkOffset += chunkLength;\n  }\n\n  finish() {\n    if (this.pendingChunk !== null) {\n      this.flush('', 0, 0);\n      this.pendingChunk = null;\n    }\n\n    return this.value;\n  }\n\n}\n\n;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/@discoveryjs/json-ext/src/parse-chunked.js"],"names":["isReadableStream","require","TextDecoder","STACK_OBJECT","STACK_ARRAY","decoder","isObject","value","adjustPosition","error","parser","name","jsonParseOffset","message","replace","_","pos","Number","append","array","elements","initialLength","length","i","module","exports","chunkEmitter","ChunkParser","Promise","resolve","reject","on","chunk","push","e","finish","iterator","Symbol","asyncIterator","Error","constructor","undefined","valueStack","stack","Array","lastFlushDepth","flushDepth","stateString","stateStringEscape","pendingByteSeq","pendingChunk","chunkOffset","parseAndAppend","fragment","wrap","Object","assign","JSON","parse","prepareAddition","expectComma","isArray","keys","slice","flush","start","end","prev","key","origRawChunk","Uint8Array","set","seqLength","byte","decode","chunkLength","lastFlushPoint","flushPoint","scan","charCodeAt"],"mappings":"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","sourcesContent":["const { isReadableStream } = require('./utils');\nconst TextDecoder = require('./text-decoder');\n\nconst STACK_OBJECT = 1;\nconst STACK_ARRAY = 2;\nconst decoder = new TextDecoder();\n\nfunction isObject(value) {\n    return value !== null && typeof value === 'object';\n}\n\nfunction adjustPosition(error, parser) {\n    if (error.name === 'SyntaxError' && parser.jsonParseOffset) {\n        error.message = error.message.replace(/at position (\\d+)/, (_, pos) =>\n            'at position ' + (Number(pos) + parser.jsonParseOffset)\n        );\n    }\n\n    return error;\n}\n\nfunction append(array, elements) {\n    // Note: Avoid to use array.push(...elements) since it may lead to\n    // \"RangeError: Maximum call stack size exceeded\" for a long arrays\n    const initialLength = array.length;\n    array.length += elements.length;\n\n    for (let i = 0; i < elements.length; i++) {\n        array[initialLength + i] = elements[i];\n    }\n}\n\nmodule.exports = function(chunkEmitter) {\n    let parser = new ChunkParser();\n\n    if (isObject(chunkEmitter) && isReadableStream(chunkEmitter)) {\n        return new Promise((resolve, reject) => {\n            chunkEmitter\n                .on('data', chunk => {\n                    try {\n                        parser.push(chunk);\n                    } catch (e) {\n                        reject(adjustPosition(e, parser));\n                        parser = null;\n                    }\n                })\n                .on('error', (e) => {\n                    parser = null;\n                    reject(e);\n                })\n                .on('end', () => {\n                    try {\n                        resolve(parser.finish());\n                    } catch (e) {\n                        reject(adjustPosition(e, parser));\n                    } finally {\n                        parser = null;\n                    }\n                });\n        });\n    }\n\n    if (typeof chunkEmitter === 'function') {\n        const iterator = chunkEmitter();\n\n        if (isObject(iterator) && (Symbol.iterator in iterator || Symbol.asyncIterator in iterator)) {\n            return new Promise(async (resolve, reject) => {\n                try {\n                    for await (const chunk of iterator) {\n                        parser.push(chunk);\n                    }\n\n                    resolve(parser.finish());\n                } catch (e) {\n                    reject(adjustPosition(e, parser));\n                } finally {\n                    parser = null;\n                }\n            });\n        }\n    }\n\n    throw new Error(\n        'Chunk emitter should be readable stream, generator, ' +\n        'async generator or function returning an iterable object'\n    );\n};\n\nclass ChunkParser {\n    constructor() {\n        this.value = undefined;\n        this.valueStack = null;\n\n        this.stack = new Array(100);\n        this.lastFlushDepth = 0;\n        this.flushDepth = 0;\n        this.stateString = false;\n        this.stateStringEscape = false;\n        this.pendingByteSeq = null;\n        this.pendingChunk = null;\n        this.chunkOffset = 0;\n        this.jsonParseOffset = 0;\n    }\n\n    parseAndAppend(fragment, wrap) {\n        // Append new entries or elements\n        if (this.stack[this.lastFlushDepth - 1] === STACK_OBJECT) {\n            if (wrap) {\n                this.jsonParseOffset--;\n                fragment = '{' + fragment + '}';\n            }\n\n            Object.assign(this.valueStack.value, JSON.parse(fragment));\n        } else {\n            if (wrap) {\n                this.jsonParseOffset--;\n                fragment = '[' + fragment + ']';\n            }\n\n            append(this.valueStack.value, JSON.parse(fragment));\n        }\n    }\n\n    prepareAddition(fragment) {\n        const { value } = this.valueStack;\n        const expectComma = Array.isArray(value)\n            ? value.length !== 0\n            : Object.keys(value).length !== 0;\n\n        if (expectComma) {\n            // Skip a comma at the beginning of fragment, otherwise it would\n            // fail to parse\n            if (fragment[0] === ',') {\n                this.jsonParseOffset++;\n                return fragment.slice(1);\n            }\n\n            // When value (an object or array) is not empty and a fragment\n            // doesn't start with a comma, a single valid fragment starting\n            // is a closing bracket. If it's not, a prefix is adding to fail\n            // parsing. Otherwise, the sequence of chunks can be successfully\n            // parsed, although it should not, e.g. [\"[{}\", \"{}]\"]\n            if (fragment[0] !== '}' && fragment[0] !== ']') {\n                this.jsonParseOffset -= 3;\n                return '[[]' + fragment;\n            }\n        }\n\n        return fragment;\n    }\n\n    flush(chunk, start, end) {\n        let fragment = chunk.slice(start, end);\n\n        // Save position correction an error in JSON.parse() if any\n        this.jsonParseOffset = this.chunkOffset + start;\n\n        // Prepend pending chunk if any\n        if (this.pendingChunk !== null) {\n            fragment = this.pendingChunk + fragment;\n            this.jsonParseOffset -= this.pendingChunk.length;\n            this.pendingChunk = null;\n        }\n\n        if (this.flushDepth === this.lastFlushDepth) {\n            // Depth didn't changed, so it's a root value or entry/element set\n            if (this.flushDepth > 0) {\n                this.parseAndAppend(this.prepareAddition(fragment), true);\n            } else {\n                // That's an entire value on a top level\n                this.value = JSON.parse(fragment);\n                this.valueStack = {\n                    value: this.value,\n                    prev: null\n                };\n            }\n        } else if (this.flushDepth > this.lastFlushDepth) {\n            // Add missed closing brackets/parentheses\n            for (let i = this.flushDepth - 1; i >= this.lastFlushDepth; i--) {\n                fragment += this.stack[i] === STACK_OBJECT ? '}' : ']';\n            }\n\n            if (this.lastFlushDepth === 0) {\n                // That's a root value\n                this.value = JSON.parse(fragment);\n                this.valueStack = {\n                    value: this.value,\n                    prev: null\n                };\n            } else {\n                this.parseAndAppend(this.prepareAddition(fragment), true);\n            }\n\n            // Move down to the depths to the last object/array, which is current now\n            for (let i = this.lastFlushDepth || 1; i < this.flushDepth; i++) {\n                let value = this.valueStack.value;\n\n                if (this.stack[i - 1] === STACK_OBJECT) {\n                    // find last entry\n                    let key;\n                    // eslint-disable-next-line curly\n                    for (key in value);\n                    value = value[key];\n                } else {\n                    // last element\n                    value = value[value.length - 1];\n                }\n\n                this.valueStack = {\n                    value,\n                    prev: this.valueStack\n                };\n            }\n        } else /* this.flushDepth < this.lastFlushDepth */ {\n            fragment = this.prepareAddition(fragment);\n\n            // Add missed opening brackets/parentheses\n            for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n                this.jsonParseOffset--;\n                fragment = (this.stack[i] === STACK_OBJECT ? '{' : '[') + fragment;\n            }\n\n            this.parseAndAppend(fragment, false);\n\n            for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n                this.valueStack = this.valueStack.prev;\n            }\n        }\n\n        this.lastFlushDepth = this.flushDepth;\n    }\n\n    push(chunk) {\n        if (typeof chunk !== 'string') {\n            // Suppose chunk is Buffer or Uint8Array\n\n            // Prepend uncompleted byte sequence if any\n            if (this.pendingByteSeq !== null) {\n                const origRawChunk = chunk;\n                chunk = new Uint8Array(this.pendingByteSeq.length + origRawChunk.length);\n                chunk.set(this.pendingByteSeq);\n                chunk.set(origRawChunk, this.pendingByteSeq.length);\n                this.pendingByteSeq = null;\n            }\n\n            // In case Buffer/Uint8Array, an input is encoded in UTF8\n            // Seek for parts of uncompleted UTF8 symbol on the ending\n            // This makes sense only if we expect more chunks and last char is not multi-bytes\n            if (chunk[chunk.length - 1] > 127) {\n                for (let seqLength = 0; seqLength < chunk.length; seqLength++) {\n                    const byte = chunk[chunk.length - 1 - seqLength];\n\n                    // 10xxxxxx - 2nd, 3rd or 4th byte\n                    // 110xxxxx â€“ first byte of 2-byte sequence\n                    // 1110xxxx - first byte of 3-byte sequence\n                    // 11110xxx - first byte of 4-byte sequence\n                    if (byte >> 6 === 3) {\n                        seqLength++;\n\n                        // If the sequence is really incomplete, then preserve it\n                        // for the future chunk and cut off it from the current chunk\n                        if ((seqLength !== 4 && byte >> 3 === 0b11110) ||\n                            (seqLength !== 3 && byte >> 4 === 0b1110) ||\n                            (seqLength !== 2 && byte >> 5 === 0b110)) {\n                            this.pendingByteSeq = chunk.slice(chunk.length - seqLength);\n                            chunk = chunk.slice(0, -seqLength);\n                        }\n\n                        break;\n                    }\n                }\n            }\n\n            // Convert chunk to a string, since single decode per chunk\n            // is much effective than decode multiple small substrings\n            chunk = decoder.decode(chunk);\n        }\n\n        const chunkLength = chunk.length;\n        let lastFlushPoint = 0;\n        let flushPoint = 0;\n\n        // Main scan loop\n        scan: for (let i = 0; i < chunkLength; i++) {\n            if (this.stateString) {\n                for (; i < chunkLength; i++) {\n                    if (this.stateStringEscape) {\n                        this.stateStringEscape = false;\n                    } else {\n                        switch (chunk.charCodeAt(i)) {\n                            case 0x22: /* \" */\n                                this.stateString = false;\n                                continue scan;\n\n                            case 0x5C: /* \\ */\n                                this.stateStringEscape = true;\n                        }\n                    }\n                }\n\n                break;\n            }\n\n            switch (chunk.charCodeAt(i)) {\n                case 0x22: /* \" */\n                    this.stateString = true;\n                    this.stateStringEscape = false;\n                    break;\n\n                case 0x2C: /* , */\n                    flushPoint = i;\n                    break;\n\n                case 0x7B: /* { */\n                    // Open an object\n                    flushPoint = i + 1;\n                    this.stack[this.flushDepth++] = STACK_OBJECT;\n                    break;\n\n                case 0x5B: /* [ */\n                    // Open an array\n                    flushPoint = i + 1;\n                    this.stack[this.flushDepth++] = STACK_ARRAY;\n                    break;\n\n                case 0x5D: /* ] */\n                case 0x7D: /* } */\n                    // Close an object or array\n                    flushPoint = i + 1;\n                    this.flushDepth--;\n\n                    if (this.flushDepth < this.lastFlushDepth) {\n                        this.flush(chunk, lastFlushPoint, flushPoint);\n                        lastFlushPoint = flushPoint;\n                    }\n\n                    break;\n\n                case 0x09: /* \\t */\n                case 0x0A: /* \\n */\n                case 0x0D: /* \\r */\n                case 0x20: /* space */\n                    // Move points forward when they points on current position and it's a whitespace\n                    if (lastFlushPoint === i) {\n                        lastFlushPoint++;\n                    }\n\n                    if (flushPoint === i) {\n                        flushPoint++;\n                    }\n\n                    break;\n            }\n        }\n\n        if (flushPoint > lastFlushPoint) {\n            this.flush(chunk, lastFlushPoint, flushPoint);\n        }\n\n        // Produce pendingChunk if something left\n        if (flushPoint < chunkLength) {\n            if (this.pendingChunk !== null) {\n                // When there is already a pending chunk then no flush happened,\n                // appending entire chunk to pending one\n                this.pendingChunk += chunk;\n            } else {\n                // Create a pending chunk, it will start with non-whitespace since\n                // flushPoint was moved forward away from whitespaces on scan\n                this.pendingChunk = chunk.slice(flushPoint, chunkLength);\n            }\n        }\n\n        this.chunkOffset += chunkLength;\n    }\n\n    finish() {\n        if (this.pendingChunk !== null) {\n            this.flush('', 0, 0);\n            this.pendingChunk = null;\n        }\n\n        return this.value;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}