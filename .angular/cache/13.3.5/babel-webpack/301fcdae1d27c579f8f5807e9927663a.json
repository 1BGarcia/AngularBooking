{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nconst path = require(\"path\");\n\nconst mime = require(\"mime-types\");\n\nconst parseRange = require(\"range-parser\");\n\nconst getFilenameFromUrl = require(\"./utils/getFilenameFromUrl\");\n\nconst {\n  getHeaderNames,\n  getHeaderFromRequest,\n  getHeaderFromResponse,\n  setHeaderForResponse,\n  setStatusCode,\n  send\n} = require(\"./utils/compatibleAPI\");\n\nconst ready = require(\"./utils/ready\");\n/** @typedef {import(\"./index.js\").NextFunction} NextFunction */\n\n/** @typedef {import(\"./index.js\").IncomingMessage} IncomingMessage */\n\n/** @typedef {import(\"./index.js\").ServerResponse} ServerResponse */\n\n/**\n * @param {string} type\n * @param {number} size\n * @param {import(\"range-parser\").Range} [range]\n * @returns {string}\n */\n\n\nfunction getValueContentRangeHeader(type, size, range) {\n  return `${type} ${range ? `${range.start}-${range.end}` : \"*\"}/${size}`;\n}\n/**\n * @param {string | number} title\n * @param {string} body\n * @returns {string}\n */\n\n\nfunction createHtmlDocument(title, body) {\n  return `${\"<!DOCTYPE html>\\n\" + '<html lang=\"en\">\\n' + \"<head>\\n\" + '<meta charset=\"utf-8\">\\n' + \"<title>\"}${title}</title>\\n` + `</head>\\n` + `<body>\\n` + `<pre>${body}</pre>\\n` + `</body>\\n` + `</html>\\n`;\n}\n\nconst BYTES_RANGE_REGEXP = /^ *bytes/i;\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"./index.js\").Context<Request, Response>} context\n * @return {import(\"./index.js\").Middleware<Request, Response>}\n */\n\nfunction wrapper(context) {\n  return /*#__PURE__*/function () {\n    var _middleware = _asyncToGenerator(function* (req, res, next) {\n      const acceptedMethods = context.options.methods || [\"GET\", \"HEAD\"]; // fixes #282. credit @cexoso. in certain edge situations res.locals is undefined.\n      // eslint-disable-next-line no-param-reassign\n\n      res.locals = res.locals || {};\n\n      if (req.method && !acceptedMethods.includes(req.method)) {\n        yield goNext();\n        return;\n      }\n\n      ready(context, processRequest, req);\n\n      function goNext() {\n        return _goNext.apply(this, arguments);\n      }\n\n      function _goNext() {\n        _goNext = _asyncToGenerator(function* () {\n          if (!context.options.serverSideRender) {\n            return next();\n          }\n\n          return new Promise(resolve => {\n            ready(context, () => {\n              /** @type {any} */\n              // eslint-disable-next-line no-param-reassign\n              res.locals.webpack = {\n                devMiddleware: context\n              };\n              resolve(next());\n            }, req);\n          });\n        });\n        return _goNext.apply(this, arguments);\n      }\n\n      function processRequest() {\n        return _processRequest.apply(this, arguments);\n      }\n\n      function _processRequest() {\n        _processRequest = _asyncToGenerator(function* () {\n          const filename = getFilenameFromUrl(context,\n          /** @type {string} */\n          req.url);\n\n          if (!filename) {\n            yield goNext();\n            return;\n          }\n\n          let {\n            headers\n          } = context.options;\n\n          if (typeof headers === \"function\") {\n            // @ts-ignore\n            headers = headers(req, res, context);\n          }\n          /**\n           * @type {{key: string, value: string | number}[]}\n           */\n\n\n          const allHeaders = [];\n\n          if (typeof headers !== \"undefined\") {\n            if (!Array.isArray(headers)) {\n              // eslint-disable-next-line guard-for-in\n              for (const name in headers) {\n                // @ts-ignore\n                allHeaders.push({\n                  key: name,\n                  value: headers[name]\n                });\n              }\n\n              headers = allHeaders;\n            }\n\n            headers.forEach(\n            /**\n             * @param {{key: string, value: any}} header\n             */\n            header => {\n              setHeaderForResponse(res, header.key, header.value);\n            });\n          }\n\n          if (!getHeaderFromResponse(res, \"Content-Type\")) {\n            // content-type name(like application/javascript; charset=utf-8) or false\n            const contentType = mime.contentType(path.extname(filename)); // Only set content-type header if media type is known\n            // https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n\n            if (contentType) {\n              setHeaderForResponse(res, \"Content-Type\", contentType);\n            }\n          }\n\n          if (!getHeaderFromResponse(res, \"Accept-Ranges\")) {\n            setHeaderForResponse(res, \"Accept-Ranges\", \"bytes\");\n          }\n\n          const rangeHeader = getHeaderFromRequest(req, \"range\");\n          let start;\n          let end;\n\n          if (rangeHeader && BYTES_RANGE_REGEXP.test(rangeHeader)) {\n            const size = yield new Promise(resolve => {\n              /** @type {import(\"fs\").lstat} */\n              context.outputFileSystem.lstat(filename, (error, stats) => {\n                if (error) {\n                  context.logger.error(error);\n                  return;\n                }\n\n                resolve(stats.size);\n              });\n            });\n            const parsedRanges = parseRange(size, rangeHeader, {\n              combine: true\n            });\n\n            if (parsedRanges === -1) {\n              const message = \"Unsatisfiable range for 'Range' header.\";\n              context.logger.error(message);\n              const existingHeaders = getHeaderNames(res);\n\n              for (let i = 0; i < existingHeaders.length; i++) {\n                res.removeHeader(existingHeaders[i]);\n              }\n\n              setStatusCode(res, 416);\n              setHeaderForResponse(res, \"Content-Range\", getValueContentRangeHeader(\"bytes\", size));\n              setHeaderForResponse(res, \"Content-Type\", \"text/html; charset=utf-8\");\n              const document = createHtmlDocument(416, `Error: ${message}`);\n              const byteLength = Buffer.byteLength(document);\n              setHeaderForResponse(res, \"Content-Length\", Buffer.byteLength(document));\n              send(req, res, document, byteLength);\n              return;\n            } else if (parsedRanges === -2) {\n              context.logger.error(\"A malformed 'Range' header was provided. A regular response will be sent for this request.\");\n            } else if (parsedRanges.length > 1) {\n              context.logger.error(\"A 'Range' header with multiple ranges was provided. Multiple ranges are not supported, so a regular response will be sent for this request.\");\n            }\n\n            if (parsedRanges !== -2 && parsedRanges.length === 1) {\n              // Content-Range\n              setStatusCode(res, 206);\n              setHeaderForResponse(res, \"Content-Range\", getValueContentRangeHeader(\"bytes\", size,\n              /** @type {import(\"range-parser\").Ranges} */\n              parsedRanges[0]));\n              [{\n                start,\n                end\n              }] = parsedRanges;\n            }\n          }\n\n          const isFsSupportsStream = typeof context.outputFileSystem.createReadStream === \"function\";\n          let bufferOtStream;\n          let byteLength;\n\n          try {\n            if (typeof start !== \"undefined\" && typeof end !== \"undefined\" && isFsSupportsStream) {\n              bufferOtStream =\n              /** @type {import(\"fs\").createReadStream} */\n              context.outputFileSystem.createReadStream(filename, {\n                start,\n                end\n              });\n              byteLength = end - start + 1;\n            } else {\n              bufferOtStream =\n              /** @type {import(\"fs\").readFileSync} */\n              context.outputFileSystem.readFileSync(filename);\n              ({\n                byteLength\n              } = bufferOtStream);\n            }\n          } catch (_ignoreError) {\n            yield goNext();\n            return;\n          }\n\n          send(req, res, bufferOtStream, byteLength);\n        });\n        return _processRequest.apply(this, arguments);\n      }\n    });\n\n    function middleware(_x, _x2, _x3) {\n      return _middleware.apply(this, arguments);\n    }\n\n    return middleware;\n  }();\n}\n\nmodule.exports = wrapper;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/webpack-dev-middleware/dist/middleware.js"],"names":["path","require","mime","parseRange","getFilenameFromUrl","getHeaderNames","getHeaderFromRequest","getHeaderFromResponse","setHeaderForResponse","setStatusCode","send","ready","getValueContentRangeHeader","type","size","range","start","end","createHtmlDocument","title","body","BYTES_RANGE_REGEXP","wrapper","context","req","res","next","acceptedMethods","options","methods","locals","method","includes","goNext","processRequest","serverSideRender","Promise","resolve","webpack","devMiddleware","filename","url","headers","allHeaders","Array","isArray","name","push","key","value","forEach","header","contentType","extname","rangeHeader","test","outputFileSystem","lstat","error","stats","logger","parsedRanges","combine","message","existingHeaders","i","length","removeHeader","document","byteLength","Buffer","isFsSupportsStream","createReadStream","bufferOtStream","readFileSync","_ignoreError","middleware","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst path = require(\"path\");\n\nconst mime = require(\"mime-types\");\n\nconst parseRange = require(\"range-parser\");\n\nconst getFilenameFromUrl = require(\"./utils/getFilenameFromUrl\");\n\nconst {\n  getHeaderNames,\n  getHeaderFromRequest,\n  getHeaderFromResponse,\n  setHeaderForResponse,\n  setStatusCode,\n  send\n} = require(\"./utils/compatibleAPI\");\n\nconst ready = require(\"./utils/ready\");\n/** @typedef {import(\"./index.js\").NextFunction} NextFunction */\n\n/** @typedef {import(\"./index.js\").IncomingMessage} IncomingMessage */\n\n/** @typedef {import(\"./index.js\").ServerResponse} ServerResponse */\n\n/**\n * @param {string} type\n * @param {number} size\n * @param {import(\"range-parser\").Range} [range]\n * @returns {string}\n */\n\n\nfunction getValueContentRangeHeader(type, size, range) {\n  return `${type} ${range ? `${range.start}-${range.end}` : \"*\"}/${size}`;\n}\n/**\n * @param {string | number} title\n * @param {string} body\n * @returns {string}\n */\n\n\nfunction createHtmlDocument(title, body) {\n  return `${\"<!DOCTYPE html>\\n\" + '<html lang=\"en\">\\n' + \"<head>\\n\" + '<meta charset=\"utf-8\">\\n' + \"<title>\"}${title}</title>\\n` + `</head>\\n` + `<body>\\n` + `<pre>${body}</pre>\\n` + `</body>\\n` + `</html>\\n`;\n}\n\nconst BYTES_RANGE_REGEXP = /^ *bytes/i;\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"./index.js\").Context<Request, Response>} context\n * @return {import(\"./index.js\").Middleware<Request, Response>}\n */\n\nfunction wrapper(context) {\n  return async function middleware(req, res, next) {\n    const acceptedMethods = context.options.methods || [\"GET\", \"HEAD\"]; // fixes #282. credit @cexoso. in certain edge situations res.locals is undefined.\n    // eslint-disable-next-line no-param-reassign\n\n    res.locals = res.locals || {};\n\n    if (req.method && !acceptedMethods.includes(req.method)) {\n      await goNext();\n      return;\n    }\n\n    ready(context, processRequest, req);\n\n    async function goNext() {\n      if (!context.options.serverSideRender) {\n        return next();\n      }\n\n      return new Promise(resolve => {\n        ready(context, () => {\n          /** @type {any} */\n          // eslint-disable-next-line no-param-reassign\n          res.locals.webpack = {\n            devMiddleware: context\n          };\n          resolve(next());\n        }, req);\n      });\n    }\n\n    async function processRequest() {\n      const filename = getFilenameFromUrl(context,\n      /** @type {string} */\n      req.url);\n\n      if (!filename) {\n        await goNext();\n        return;\n      }\n\n      let {\n        headers\n      } = context.options;\n\n      if (typeof headers === \"function\") {\n        // @ts-ignore\n        headers = headers(req, res, context);\n      }\n      /**\n       * @type {{key: string, value: string | number}[]}\n       */\n\n\n      const allHeaders = [];\n\n      if (typeof headers !== \"undefined\") {\n        if (!Array.isArray(headers)) {\n          // eslint-disable-next-line guard-for-in\n          for (const name in headers) {\n            // @ts-ignore\n            allHeaders.push({\n              key: name,\n              value: headers[name]\n            });\n          }\n\n          headers = allHeaders;\n        }\n\n        headers.forEach(\n        /**\n         * @param {{key: string, value: any}} header\n         */\n        header => {\n          setHeaderForResponse(res, header.key, header.value);\n        });\n      }\n\n      if (!getHeaderFromResponse(res, \"Content-Type\")) {\n        // content-type name(like application/javascript; charset=utf-8) or false\n        const contentType = mime.contentType(path.extname(filename)); // Only set content-type header if media type is known\n        // https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n\n        if (contentType) {\n          setHeaderForResponse(res, \"Content-Type\", contentType);\n        }\n      }\n\n      if (!getHeaderFromResponse(res, \"Accept-Ranges\")) {\n        setHeaderForResponse(res, \"Accept-Ranges\", \"bytes\");\n      }\n\n      const rangeHeader = getHeaderFromRequest(req, \"range\");\n      let start;\n      let end;\n\n      if (rangeHeader && BYTES_RANGE_REGEXP.test(rangeHeader)) {\n        const size = await new Promise(resolve => {\n          /** @type {import(\"fs\").lstat} */\n          context.outputFileSystem.lstat(filename, (error, stats) => {\n            if (error) {\n              context.logger.error(error);\n              return;\n            }\n\n            resolve(stats.size);\n          });\n        });\n        const parsedRanges = parseRange(size, rangeHeader, {\n          combine: true\n        });\n\n        if (parsedRanges === -1) {\n          const message = \"Unsatisfiable range for 'Range' header.\";\n          context.logger.error(message);\n          const existingHeaders = getHeaderNames(res);\n\n          for (let i = 0; i < existingHeaders.length; i++) {\n            res.removeHeader(existingHeaders[i]);\n          }\n\n          setStatusCode(res, 416);\n          setHeaderForResponse(res, \"Content-Range\", getValueContentRangeHeader(\"bytes\", size));\n          setHeaderForResponse(res, \"Content-Type\", \"text/html; charset=utf-8\");\n          const document = createHtmlDocument(416, `Error: ${message}`);\n          const byteLength = Buffer.byteLength(document);\n          setHeaderForResponse(res, \"Content-Length\", Buffer.byteLength(document));\n          send(req, res, document, byteLength);\n          return;\n        } else if (parsedRanges === -2) {\n          context.logger.error(\"A malformed 'Range' header was provided. A regular response will be sent for this request.\");\n        } else if (parsedRanges.length > 1) {\n          context.logger.error(\"A 'Range' header with multiple ranges was provided. Multiple ranges are not supported, so a regular response will be sent for this request.\");\n        }\n\n        if (parsedRanges !== -2 && parsedRanges.length === 1) {\n          // Content-Range\n          setStatusCode(res, 206);\n          setHeaderForResponse(res, \"Content-Range\", getValueContentRangeHeader(\"bytes\", size,\n          /** @type {import(\"range-parser\").Ranges} */\n          parsedRanges[0]));\n          [{\n            start,\n            end\n          }] = parsedRanges;\n        }\n      }\n\n      const isFsSupportsStream = typeof context.outputFileSystem.createReadStream === \"function\";\n      let bufferOtStream;\n      let byteLength;\n\n      try {\n        if (typeof start !== \"undefined\" && typeof end !== \"undefined\" && isFsSupportsStream) {\n          bufferOtStream =\n          /** @type {import(\"fs\").createReadStream} */\n          context.outputFileSystem.createReadStream(filename, {\n            start,\n            end\n          });\n          byteLength = end - start + 1;\n        } else {\n          bufferOtStream =\n          /** @type {import(\"fs\").readFileSync} */\n          context.outputFileSystem.readFileSync(filename);\n          ({\n            byteLength\n          } = bufferOtStream);\n        }\n      } catch (_ignoreError) {\n        await goNext();\n        return;\n      }\n\n      send(req, res, bufferOtStream, byteLength);\n    }\n  };\n}\n\nmodule.exports = wrapper;"]},"metadata":{},"sourceType":"script"}