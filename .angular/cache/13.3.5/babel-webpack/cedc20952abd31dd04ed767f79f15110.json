{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = loader;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _options = _interopRequireDefault(require(\"./options.json\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n\n\nfunction loader(_x, _x2) {\n  return _loader.apply(this, arguments);\n}\n\nfunction _loader() {\n  _loader = _asyncToGenerator(function* (input, inputMap) {\n    var _this = this;\n\n    const options = this.getOptions(_options.default);\n    const {\n      sourceMappingURL,\n      replacementString\n    } = (0, _utils.getSourceMappingURL)(input);\n    const callback = this.async();\n\n    if (!sourceMappingURL) {\n      callback(null, input, inputMap);\n      return;\n    }\n\n    let behaviourSourceMappingUrl;\n\n    try {\n      behaviourSourceMappingUrl = typeof options.filterSourceMappingUrl !== \"undefined\" ? options.filterSourceMappingUrl(sourceMappingURL, this.resourcePath) : \"consume\";\n    } catch (error) {\n      callback(error);\n      return;\n    } // eslint-disable-next-line default-case\n\n\n    switch (behaviourSourceMappingUrl) {\n      case \"skip\":\n        callback(null, input, inputMap);\n        return;\n\n      case false:\n      case \"remove\":\n        callback(null, input.replace(replacementString, \"\"), inputMap);\n        return;\n    }\n\n    let sourceURL;\n    let sourceContent;\n\n    try {\n      ({\n        sourceURL,\n        sourceContent\n      } = yield (0, _utils.fetchFromURL)(this, this.context, sourceMappingURL));\n    } catch (error) {\n      this.emitWarning(error);\n      callback(null, input, inputMap);\n      return;\n    }\n\n    if (sourceURL) {\n      this.addDependency(sourceURL);\n    }\n\n    let map;\n\n    try {\n      map = JSON.parse(sourceContent.replace(/^\\)\\]\\}'/, \"\"));\n    } catch (parseError) {\n      this.emitWarning(new Error(`Failed to parse source map from '${sourceMappingURL}': ${parseError}`));\n      callback(null, input, inputMap);\n      return;\n    }\n\n    const context = sourceURL ? _path.default.dirname(sourceURL) : this.context;\n\n    if (map.sections) {\n      // eslint-disable-next-line no-param-reassign\n      map = yield (0, _utils.flattenSourceMap)(map);\n    }\n\n    const resolvedSources = yield Promise.all(map.sources.map( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (source, i) {\n        // eslint-disable-next-line no-shadow\n        let sourceURL; // eslint-disable-next-line no-shadow\n\n        let sourceContent;\n        const originalSourceContent = map.sourcesContent && typeof map.sourcesContent[i] !== \"undefined\" && map.sourcesContent[i] !== null ? map.sourcesContent[i] : // eslint-disable-next-line no-undefined\n        undefined;\n        const skipReading = typeof originalSourceContent !== \"undefined\";\n        let errored = false; // We do not skipReading here, because we need absolute paths in sources.\n        // This is necessary so that for sourceMaps with the same file structure in sources, name collisions do not occur.\n        // https://github.com/webpack-contrib/source-map-loader/issues/51\n\n        try {\n          ({\n            sourceURL,\n            sourceContent\n          } = yield (0, _utils.fetchFromURL)(_this, context, source, map.sourceRoot, skipReading));\n        } catch (error) {\n          errored = true;\n\n          _this.emitWarning(error);\n        }\n\n        if (skipReading) {\n          sourceContent = originalSourceContent;\n        } else if (!errored && sourceURL) {\n          _this.addDependency(sourceURL);\n        } // Return original value of `source` when error happens\n\n\n        return {\n          sourceURL: errored ? source : sourceURL,\n          sourceContent\n        };\n      });\n\n      return function (_x3, _x4) {\n        return _ref.apply(this, arguments);\n      };\n    }()));\n    const newMap = { ...map\n    };\n    newMap.sources = [];\n    newMap.sourcesContent = [];\n    delete newMap.sourceRoot;\n    resolvedSources.forEach(source => {\n      // eslint-disable-next-line no-shadow\n      const {\n        sourceURL,\n        sourceContent\n      } = source;\n      newMap.sources.push(sourceURL || \"\");\n      newMap.sourcesContent.push(sourceContent || \"\");\n    });\n    const sourcesContentIsEmpty = newMap.sourcesContent.filter(entry => Boolean(entry)).length === 0;\n\n    if (sourcesContentIsEmpty) {\n      delete newMap.sourcesContent;\n    }\n\n    callback(null, input.replace(replacementString, \"\"), newMap);\n  });\n  return _loader.apply(this, arguments);\n}","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/source-map-loader/dist/index.js"],"names":["Object","defineProperty","exports","value","default","loader","_path","_interopRequireDefault","require","_options","_utils","obj","__esModule","input","inputMap","options","getOptions","sourceMappingURL","replacementString","getSourceMappingURL","callback","async","behaviourSourceMappingUrl","filterSourceMappingUrl","resourcePath","error","replace","sourceURL","sourceContent","fetchFromURL","context","emitWarning","addDependency","map","JSON","parse","parseError","Error","dirname","sections","flattenSourceMap","resolvedSources","Promise","all","sources","source","i","originalSourceContent","sourcesContent","undefined","skipReading","errored","sourceRoot","newMap","forEach","push","sourcesContentIsEmpty","filter","entry","Boolean","length"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = loader;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _options = _interopRequireDefault(require(\"./options.json\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nasync function loader(input, inputMap) {\n  const options = this.getOptions(_options.default);\n  const {\n    sourceMappingURL,\n    replacementString\n  } = (0, _utils.getSourceMappingURL)(input);\n  const callback = this.async();\n\n  if (!sourceMappingURL) {\n    callback(null, input, inputMap);\n    return;\n  }\n\n  let behaviourSourceMappingUrl;\n\n  try {\n    behaviourSourceMappingUrl = typeof options.filterSourceMappingUrl !== \"undefined\" ? options.filterSourceMappingUrl(sourceMappingURL, this.resourcePath) : \"consume\";\n  } catch (error) {\n    callback(error);\n    return;\n  } // eslint-disable-next-line default-case\n\n\n  switch (behaviourSourceMappingUrl) {\n    case \"skip\":\n      callback(null, input, inputMap);\n      return;\n\n    case false:\n    case \"remove\":\n      callback(null, input.replace(replacementString, \"\"), inputMap);\n      return;\n  }\n\n  let sourceURL;\n  let sourceContent;\n\n  try {\n    ({\n      sourceURL,\n      sourceContent\n    } = await (0, _utils.fetchFromURL)(this, this.context, sourceMappingURL));\n  } catch (error) {\n    this.emitWarning(error);\n    callback(null, input, inputMap);\n    return;\n  }\n\n  if (sourceURL) {\n    this.addDependency(sourceURL);\n  }\n\n  let map;\n\n  try {\n    map = JSON.parse(sourceContent.replace(/^\\)\\]\\}'/, \"\"));\n  } catch (parseError) {\n    this.emitWarning(new Error(`Failed to parse source map from '${sourceMappingURL}': ${parseError}`));\n    callback(null, input, inputMap);\n    return;\n  }\n\n  const context = sourceURL ? _path.default.dirname(sourceURL) : this.context;\n\n  if (map.sections) {\n    // eslint-disable-next-line no-param-reassign\n    map = await (0, _utils.flattenSourceMap)(map);\n  }\n\n  const resolvedSources = await Promise.all(map.sources.map(async (source, i) => {\n    // eslint-disable-next-line no-shadow\n    let sourceURL; // eslint-disable-next-line no-shadow\n\n    let sourceContent;\n    const originalSourceContent = map.sourcesContent && typeof map.sourcesContent[i] !== \"undefined\" && map.sourcesContent[i] !== null ? map.sourcesContent[i] : // eslint-disable-next-line no-undefined\n    undefined;\n    const skipReading = typeof originalSourceContent !== \"undefined\";\n    let errored = false; // We do not skipReading here, because we need absolute paths in sources.\n    // This is necessary so that for sourceMaps with the same file structure in sources, name collisions do not occur.\n    // https://github.com/webpack-contrib/source-map-loader/issues/51\n\n    try {\n      ({\n        sourceURL,\n        sourceContent\n      } = await (0, _utils.fetchFromURL)(this, context, source, map.sourceRoot, skipReading));\n    } catch (error) {\n      errored = true;\n      this.emitWarning(error);\n    }\n\n    if (skipReading) {\n      sourceContent = originalSourceContent;\n    } else if (!errored && sourceURL) {\n      this.addDependency(sourceURL);\n    } // Return original value of `source` when error happens\n\n\n    return {\n      sourceURL: errored ? source : sourceURL,\n      sourceContent\n    };\n  }));\n  const newMap = { ...map\n  };\n  newMap.sources = [];\n  newMap.sourcesContent = [];\n  delete newMap.sourceRoot;\n  resolvedSources.forEach(source => {\n    // eslint-disable-next-line no-shadow\n    const {\n      sourceURL,\n      sourceContent\n    } = source;\n    newMap.sources.push(sourceURL || \"\");\n    newMap.sourcesContent.push(sourceContent || \"\");\n  });\n  const sourcesContentIsEmpty = newMap.sourcesContent.filter(entry => Boolean(entry)).length === 0;\n\n  if (sourcesContentIsEmpty) {\n    delete newMap.sourcesContent;\n  }\n\n  callback(null, input.replace(replacementString, \"\"), newMap);\n}"]},"metadata":{},"sourceType":"script"}