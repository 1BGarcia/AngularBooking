{"ast":null,"code":"import _asyncToGenerator from \"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport fs from 'fs';\nimport path from 'path';\nimport { parse as parse$1 } from 'postcss';\n\nfunction parse(string, splitByAnd) {\n  const array = [];\n  let buffer = '';\n  let split = false;\n  let func = 0;\n  let i = -1;\n\n  while (++i < string.length) {\n    const char = string[i];\n\n    if (char === '(') {\n      func += 1;\n    } else if (char === ')') {\n      if (func > 0) {\n        func -= 1;\n      }\n    } else if (func === 0) {\n      if (splitByAnd && andRegExp.test(buffer + char)) {\n        split = true;\n      } else if (!splitByAnd && char === ',') {\n        split = true;\n      }\n    }\n\n    if (split) {\n      array.push(splitByAnd ? new MediaExpression(buffer + char) : new MediaQuery(buffer));\n      buffer = '';\n      split = false;\n    } else {\n      buffer += char;\n    }\n  }\n\n  if (buffer !== '') {\n    array.push(splitByAnd ? new MediaExpression(buffer) : new MediaQuery(buffer));\n  }\n\n  return array;\n}\n\nclass MediaQueryList {\n  constructor(string) {\n    this.nodes = parse(string);\n  }\n\n  invert() {\n    this.nodes.forEach(node => {\n      node.invert();\n    });\n    return this;\n  }\n\n  clone() {\n    return new MediaQueryList(String(this));\n  }\n\n  toString() {\n    return this.nodes.join(',');\n  }\n\n}\n\nclass MediaQuery {\n  constructor(string) {\n    const [, before, media, after] = string.match(spaceWrapRegExp);\n    const [, modifier = '', afterModifier = ' ', type = '', beforeAnd = '', and = '', beforeExpression = '', expression1 = '', expression2 = ''] = media.match(mediaRegExp) || [];\n    const raws = {\n      before,\n      after,\n      afterModifier,\n      originalModifier: modifier || '',\n      beforeAnd,\n      and,\n      beforeExpression\n    };\n    const nodes = parse(expression1 || expression2, true);\n    Object.assign(this, {\n      modifier,\n      type,\n      raws,\n      nodes\n    });\n  }\n\n  clone(overrides) {\n    const instance = new MediaQuery(String(this));\n    Object.assign(instance, overrides);\n    return instance;\n  }\n\n  invert() {\n    this.modifier = this.modifier ? '' : this.raws.originalModifier;\n    return this;\n  }\n\n  toString() {\n    const {\n      raws\n    } = this;\n    return `${raws.before}${this.modifier}${this.modifier ? `${raws.afterModifier}` : ''}${this.type}${raws.beforeAnd}${raws.and}${raws.beforeExpression}${this.nodes.join('')}${this.raws.after}`;\n  }\n\n}\n\nclass MediaExpression {\n  constructor(string) {\n    const [, value, after = '', and = '', afterAnd = ''] = string.match(andRegExp) || [null, string];\n    const raws = {\n      after,\n      and,\n      afterAnd\n    };\n    Object.assign(this, {\n      value,\n      raws\n    });\n  }\n\n  clone(overrides) {\n    const instance = new MediaExpression(String(this));\n    Object.assign(instance, overrides);\n    return instance;\n  }\n\n  toString() {\n    const {\n      raws\n    } = this;\n    return `${this.value}${raws.after}${raws.and}${raws.afterAnd}`;\n  }\n\n}\n\nconst modifierRE = '(not|only)';\nconst typeRE = '(all|print|screen|speech)';\nconst noExpressionRE = '([\\\\W\\\\w]*)';\nconst expressionRE = '([\\\\W\\\\w]+)';\nconst noSpaceRE = '(\\\\s*)';\nconst spaceRE = '(\\\\s+)';\nconst andRE = '(?:(\\\\s+)(and))';\nconst andRegExp = new RegExp(`^${expressionRE}(?:${andRE}${spaceRE})$`, 'i');\nconst spaceWrapRegExp = new RegExp(`^${noSpaceRE}${noExpressionRE}${noSpaceRE}$`);\nconst mediaRegExp = new RegExp(`^(?:${modifierRE}${spaceRE})?(?:${typeRE}(?:${andRE}${spaceRE}${expressionRE})?|${expressionRE})$`, 'i');\n\nvar mediaASTFromString = string => new MediaQueryList(string);\n\nvar getCustomMediaFromRoot = (root, opts) => {\n  // initialize custom selectors\n  const customMedias = {}; // for each custom selector atrule that is a child of the css root\n\n  root.nodes.slice().forEach(node => {\n    if (isCustomMedia(node)) {\n      // extract the name and selectors from the params of the custom selector\n      const [, name, selectors] = node.params.match(customMediaParamsRegExp); // write the parsed selectors to the custom selector\n\n      customMedias[name] = mediaASTFromString(selectors); // conditionally remove the custom selector atrule\n\n      if (!Object(opts).preserve) {\n        node.remove();\n      }\n    }\n  });\n  return customMedias;\n}; // match the custom selector name\n\n\nconst customMediaNameRegExp = /^custom-media$/i; // match the custom selector params\n\nconst customMediaParamsRegExp = /^(--[A-z][\\w-]*)\\s+([\\W\\w]+)\\s*$/; // whether the atrule is a custom selector\n\nconst isCustomMedia = node => node.type === 'atrule' && customMediaNameRegExp.test(node.name) && customMediaParamsRegExp.test(node.params);\n/* Get Custom Media from CSS File\n/* ========================================================================== */\n\n\nfunction getCustomMediaFromCSSFile(_x) {\n  return _getCustomMediaFromCSSFile.apply(this, arguments);\n}\n/* Get Custom Media from Object\n/* ========================================================================== */\n\n\nfunction _getCustomMediaFromCSSFile() {\n  _getCustomMediaFromCSSFile = _asyncToGenerator(function* (from) {\n    const css = yield readFile(from);\n    const root = parse$1(css, {\n      from\n    });\n    return getCustomMediaFromRoot(root, {\n      preserve: true\n    });\n  });\n  return _getCustomMediaFromCSSFile.apply(this, arguments);\n}\n\nfunction getCustomMediaFromObject(object) {\n  const customMedia = Object.assign({}, Object(object).customMedia, Object(object)['custom-media']);\n\n  for (const key in customMedia) {\n    customMedia[key] = mediaASTFromString(customMedia[key]);\n  }\n\n  return customMedia;\n}\n/* Get Custom Media from JSON file\n/* ========================================================================== */\n\n\nfunction getCustomMediaFromJSONFile(_x2) {\n  return _getCustomMediaFromJSONFile.apply(this, arguments);\n}\n/* Get Custom Media from JS file\n/* ========================================================================== */\n\n\nfunction _getCustomMediaFromJSONFile() {\n  _getCustomMediaFromJSONFile = _asyncToGenerator(function* (from) {\n    const object = yield readJSON(from);\n    return getCustomMediaFromObject(object);\n  });\n  return _getCustomMediaFromJSONFile.apply(this, arguments);\n}\n\nfunction getCustomMediaFromJSFile(_x3) {\n  return _getCustomMediaFromJSFile.apply(this, arguments);\n}\n/* Get Custom Media from Sources\n/* ========================================================================== */\n\n\nfunction _getCustomMediaFromJSFile() {\n  _getCustomMediaFromJSFile = _asyncToGenerator(function* (from) {\n    const object = yield import(from);\n    return getCustomMediaFromObject(object);\n  });\n  return _getCustomMediaFromJSFile.apply(this, arguments);\n}\n\nfunction getCustomMediaFromSources(sources) {\n  return sources.map(source => {\n    if (source instanceof Promise) {\n      return source;\n    } else if (source instanceof Function) {\n      return source();\n    } // read the source as an object\n\n\n    const opts = source === Object(source) ? source : {\n      from: String(source)\n    }; // skip objects with custom media\n\n    if (Object(opts).customMedia || Object(opts)['custom-media']) {\n      return opts;\n    } // source pathname\n\n\n    const from = path.resolve(String(opts.from || '')); // type of file being read from\n\n    const type = (opts.type || path.extname(from).slice(1)).toLowerCase();\n    return {\n      type,\n      from\n    };\n  }).reduce( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (customMedia, source) {\n      const {\n        type,\n        from\n      } = yield source;\n\n      if (type === 'css' || type === 'pcss') {\n        return Object.assign(yield customMedia, yield getCustomMediaFromCSSFile(from));\n      }\n\n      if (type === 'js') {\n        return Object.assign(yield customMedia, yield getCustomMediaFromJSFile(from));\n      }\n\n      if (type === 'json') {\n        return Object.assign(yield customMedia, yield getCustomMediaFromJSONFile(from));\n      }\n\n      return Object.assign(yield customMedia, getCustomMediaFromObject(yield source));\n    });\n\n    return function (_x4, _x5) {\n      return _ref.apply(this, arguments);\n    };\n  }(), {});\n}\n/* Helper utilities\n/* ========================================================================== */\n\n\nconst readFile = from => new Promise((resolve, reject) => {\n  fs.readFile(from, 'utf8', (error, result) => {\n    if (error) {\n      reject(error);\n    } else {\n      resolve(result);\n    }\n  });\n});\n\nconst readJSON = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (from) {\n    return JSON.parse(yield readFile(from));\n  });\n\n  return function readJSON(_x6) {\n    return _ref2.apply(this, arguments);\n  };\n}(); // return transformed medias, replacing custom pseudo medias with custom medias\n\n\nfunction transformMediaList(mediaList, customMedias) {\n  let index = mediaList.nodes.length - 1;\n\n  while (index >= 0) {\n    const transformedMedias = transformMedia(mediaList.nodes[index], customMedias);\n\n    if (transformedMedias.length) {\n      mediaList.nodes.splice(index, 1, ...transformedMedias);\n    }\n\n    --index;\n  }\n\n  return mediaList;\n} // return custom pseudo medias replaced with custom medias\n\n\nfunction transformMedia(media, customMedias) {\n  const transpiledMedias = [];\n\n  for (const index in media.nodes) {\n    const {\n      value,\n      nodes\n    } = media.nodes[index];\n    const key = value.replace(customPseudoRegExp, '$1');\n\n    if (key in customMedias) {\n      for (const replacementMedia of customMedias[key].nodes) {\n        // use the first available modifier unless they cancel each other out\n        const modifier = media.modifier !== replacementMedia.modifier ? media.modifier || replacementMedia.modifier : '';\n        const mediaClone = media.clone({\n          modifier,\n          // conditionally use the raws from the first available modifier\n          raws: !modifier || media.modifier ? { ...media.raws\n          } : { ...replacementMedia.raws\n          },\n          type: media.type || replacementMedia.type\n        }); // conditionally include more replacement raws when the type is present\n\n        if (mediaClone.type === replacementMedia.type) {\n          Object.assign(mediaClone.raws, {\n            and: replacementMedia.raws.and,\n            beforeAnd: replacementMedia.raws.beforeAnd,\n            beforeExpression: replacementMedia.raws.beforeExpression\n          });\n        }\n\n        mediaClone.nodes.splice(index, 1, ...replacementMedia.clone().nodes.map(node => {\n          // use raws and spacing from the current usage\n          if (media.nodes[index].raws.and) {\n            node.raws = { ...media.nodes[index].raws\n            };\n          }\n\n          node.spaces = { ...media.nodes[index].spaces\n          };\n          return node;\n        })); // remove the currently transformed key to prevent recursion\n\n        const nextCustomMedia = getCustomMediasWithoutKey(customMedias, key);\n        const retranspiledMedias = transformMedia(mediaClone, nextCustomMedia);\n\n        if (retranspiledMedias.length) {\n          transpiledMedias.push(...retranspiledMedias);\n        } else {\n          transpiledMedias.push(mediaClone);\n        }\n      }\n\n      return transpiledMedias;\n    } else if (nodes && nodes.length) {\n      transformMediaList(media.nodes[index], customMedias);\n    }\n  }\n\n  return transpiledMedias;\n}\n\nconst customPseudoRegExp = /\\((--[A-z][\\w-]*)\\)/;\n\nconst getCustomMediasWithoutKey = (customMedias, key) => {\n  const nextCustomMedias = Object.assign({}, customMedias);\n  delete nextCustomMedias[key];\n  return nextCustomMedias;\n};\n\nvar transformAtrules = (root, customMedia, opts) => {\n  root.walkAtRules(mediaAtRuleRegExp, atrule => {\n    if (customPseudoRegExp$1.test(atrule.params)) {\n      const mediaAST = mediaASTFromString(atrule.params);\n      const params = String(transformMediaList(mediaAST, customMedia));\n\n      if (opts.preserve) {\n        atrule.cloneBefore({\n          params\n        });\n      } else {\n        atrule.params = params;\n      }\n    }\n  });\n};\n\nconst mediaAtRuleRegExp = /^media$/i;\nconst customPseudoRegExp$1 = /\\(--[A-z][\\w-]*\\)/;\n/* Write Custom Media from CSS File\n/* ========================================================================== */\n\nfunction writeCustomMediaToCssFile(_x7, _x8) {\n  return _writeCustomMediaToCssFile.apply(this, arguments);\n}\n/* Write Custom Media from JSON file\n/* ========================================================================== */\n\n\nfunction _writeCustomMediaToCssFile() {\n  _writeCustomMediaToCssFile = _asyncToGenerator(function* (to, customMedia) {\n    const cssContent = Object.keys(customMedia).reduce((cssLines, name) => {\n      cssLines.push(`@custom-media ${name} ${customMedia[name]};`);\n      return cssLines;\n    }, []).join('\\n');\n    const css = `${cssContent}\\n`;\n    yield writeFile(to, css);\n  });\n  return _writeCustomMediaToCssFile.apply(this, arguments);\n}\n\nfunction writeCustomMediaToJsonFile(_x9, _x10) {\n  return _writeCustomMediaToJsonFile.apply(this, arguments);\n}\n/* Write Custom Media from Common JS file\n/* ========================================================================== */\n\n\nfunction _writeCustomMediaToJsonFile() {\n  _writeCustomMediaToJsonFile = _asyncToGenerator(function* (to, customMedia) {\n    const jsonContent = JSON.stringify({\n      'custom-media': customMedia\n    }, null, '  ');\n    const json = `${jsonContent}\\n`;\n    yield writeFile(to, json);\n  });\n  return _writeCustomMediaToJsonFile.apply(this, arguments);\n}\n\nfunction writeCustomMediaToCjsFile(_x11, _x12) {\n  return _writeCustomMediaToCjsFile.apply(this, arguments);\n}\n/* Write Custom Media from Module JS file\n/* ========================================================================== */\n\n\nfunction _writeCustomMediaToCjsFile() {\n  _writeCustomMediaToCjsFile = _asyncToGenerator(function* (to, customMedia) {\n    const jsContents = Object.keys(customMedia).reduce((jsLines, name) => {\n      jsLines.push(`\\t\\t'${escapeForJS(name)}': '${escapeForJS(customMedia[name])}'`);\n      return jsLines;\n    }, []).join(',\\n');\n    const js = `module.exports = {\\n\\tcustomMedia: {\\n${jsContents}\\n\\t}\\n};\\n`;\n    yield writeFile(to, js);\n  });\n  return _writeCustomMediaToCjsFile.apply(this, arguments);\n}\n\nfunction writeCustomMediaToMjsFile(_x13, _x14) {\n  return _writeCustomMediaToMjsFile.apply(this, arguments);\n}\n/* Write Custom Media to Exports\n/* ========================================================================== */\n\n\nfunction _writeCustomMediaToMjsFile() {\n  _writeCustomMediaToMjsFile = _asyncToGenerator(function* (to, customMedia) {\n    const mjsContents = Object.keys(customMedia).reduce((mjsLines, name) => {\n      mjsLines.push(`\\t'${escapeForJS(name)}': '${escapeForJS(customMedia[name])}'`);\n      return mjsLines;\n    }, []).join(',\\n');\n    const mjs = `export const customMedia = {\\n${mjsContents}\\n};\\n`;\n    yield writeFile(to, mjs);\n  });\n  return _writeCustomMediaToMjsFile.apply(this, arguments);\n}\n\nfunction writeCustomMediaToExports(customMedia, destinations) {\n  return Promise.all(destinations.map( /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator(function* (destination) {\n      if (destination instanceof Function) {\n        yield destination(defaultCustomMediaToJSON(customMedia));\n      } else {\n        // read the destination as an object\n        const opts = destination === Object(destination) ? destination : {\n          to: String(destination)\n        }; // transformer for custom media into a JSON-compatible object\n\n        const toJSON = opts.toJSON || defaultCustomMediaToJSON;\n\n        if ('customMedia' in opts) {\n          // write directly to an object as customMedia\n          opts.customMedia = toJSON(customMedia);\n        } else if ('custom-media' in opts) {\n          // write directly to an object as custom-media\n          opts['custom-media'] = toJSON(customMedia);\n        } else {\n          // destination pathname\n          const to = String(opts.to || ''); // type of file being written to\n\n          const type = (opts.type || path.extname(to).slice(1)).toLowerCase(); // transformed custom media\n\n          const customMediaJSON = toJSON(customMedia);\n\n          if (type === 'css') {\n            yield writeCustomMediaToCssFile(to, customMediaJSON);\n          }\n\n          if (type === 'js') {\n            yield writeCustomMediaToCjsFile(to, customMediaJSON);\n          }\n\n          if (type === 'json') {\n            yield writeCustomMediaToJsonFile(to, customMediaJSON);\n          }\n\n          if (type === 'mjs') {\n            yield writeCustomMediaToMjsFile(to, customMediaJSON);\n          }\n        }\n      }\n    });\n\n    return function (_x15) {\n      return _ref3.apply(this, arguments);\n    };\n  }()));\n}\n/* Helper utilities\n/* ========================================================================== */\n\n\nconst defaultCustomMediaToJSON = customMedia => {\n  return Object.keys(customMedia).reduce((customMediaJSON, key) => {\n    customMediaJSON[key] = String(customMedia[key]);\n    return customMediaJSON;\n  }, {});\n};\n\nconst writeFile = (to, text) => new Promise((resolve, reject) => {\n  fs.writeFile(to, text, error => {\n    if (error) {\n      reject(error);\n    } else {\n      resolve();\n    }\n  });\n});\n\nconst escapeForJS = string => string.replace(/\\\\([\\s\\S])|(')/g, '\\\\$1$2').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n\nconst creator = opts => {\n  // whether to preserve custom media and at-rules using them\n  const preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : false; // sources to import custom media from\n\n  const importFrom = [].concat(Object(opts).importFrom || []); // destinations to export custom media to\n\n  const exportTo = [].concat(Object(opts).exportTo || []); // promise any custom media are imported\n\n  const customMediaPromise = getCustomMediaFromSources(importFrom);\n  return {\n    postcssPlugin: 'postcss-custom-media',\n    Once: function () {\n      var _ref4 = _asyncToGenerator(function* (root) {\n        const customMedia = Object.assign(yield customMediaPromise, getCustomMediaFromRoot(root, {\n          preserve\n        }));\n        yield writeCustomMediaToExports(customMedia, exportTo);\n        transformAtrules(root, customMedia, {\n          preserve\n        });\n      });\n\n      return function Once(_x16) {\n        return _ref4.apply(this, arguments);\n      };\n    }()\n  };\n};\n\ncreator.postcss = true;\nexport default creator;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/postcss-custom-media/index.es.mjs"],"names":["fs","path","parse","parse$1","string","splitByAnd","array","buffer","split","func","i","length","char","andRegExp","test","push","MediaExpression","MediaQuery","MediaQueryList","constructor","nodes","invert","forEach","node","clone","String","toString","join","before","media","after","match","spaceWrapRegExp","modifier","afterModifier","type","beforeAnd","and","beforeExpression","expression1","expression2","mediaRegExp","raws","originalModifier","Object","assign","overrides","instance","value","afterAnd","modifierRE","typeRE","noExpressionRE","expressionRE","noSpaceRE","spaceRE","andRE","RegExp","mediaASTFromString","getCustomMediaFromRoot","root","opts","customMedias","slice","isCustomMedia","name","selectors","params","customMediaParamsRegExp","preserve","remove","customMediaNameRegExp","getCustomMediaFromCSSFile","from","css","readFile","getCustomMediaFromObject","object","customMedia","key","getCustomMediaFromJSONFile","readJSON","getCustomMediaFromJSFile","getCustomMediaFromSources","sources","map","source","Promise","Function","resolve","extname","toLowerCase","reduce","reject","error","result","JSON","transformMediaList","mediaList","index","transformedMedias","transformMedia","splice","transpiledMedias","replace","customPseudoRegExp","replacementMedia","mediaClone","spaces","nextCustomMedia","getCustomMediasWithoutKey","retranspiledMedias","nextCustomMedias","transformAtrules","walkAtRules","mediaAtRuleRegExp","atrule","customPseudoRegExp$1","mediaAST","cloneBefore","writeCustomMediaToCssFile","to","cssContent","keys","cssLines","writeFile","writeCustomMediaToJsonFile","jsonContent","stringify","json","writeCustomMediaToCjsFile","jsContents","jsLines","escapeForJS","js","writeCustomMediaToMjsFile","mjsContents","mjsLines","mjs","writeCustomMediaToExports","destinations","all","destination","defaultCustomMediaToJSON","toJSON","customMediaJSON","text","creator","Boolean","importFrom","concat","exportTo","customMediaPromise","postcssPlugin","Once","postcss"],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport { parse as parse$1 } from 'postcss';\n\nfunction parse(string, splitByAnd) {\n  const array = [];\n  let buffer = '';\n  let split = false;\n  let func = 0;\n  let i = -1;\n\n  while (++i < string.length) {\n    const char = string[i];\n\n    if (char === '(') {\n      func += 1;\n    } else if (char === ')') {\n      if (func > 0) {\n        func -= 1;\n      }\n    } else if (func === 0) {\n      if (splitByAnd && andRegExp.test(buffer + char)) {\n        split = true;\n      } else if (!splitByAnd && char === ',') {\n        split = true;\n      }\n    }\n\n    if (split) {\n      array.push(splitByAnd ? new MediaExpression(buffer + char) : new MediaQuery(buffer));\n      buffer = '';\n      split = false;\n    } else {\n      buffer += char;\n    }\n  }\n\n  if (buffer !== '') {\n    array.push(splitByAnd ? new MediaExpression(buffer) : new MediaQuery(buffer));\n  }\n\n  return array;\n}\n\nclass MediaQueryList {\n  constructor(string) {\n    this.nodes = parse(string);\n  }\n\n  invert() {\n    this.nodes.forEach(node => {\n      node.invert();\n    });\n    return this;\n  }\n\n  clone() {\n    return new MediaQueryList(String(this));\n  }\n\n  toString() {\n    return this.nodes.join(',');\n  }\n\n}\n\nclass MediaQuery {\n  constructor(string) {\n    const [, before, media, after] = string.match(spaceWrapRegExp);\n    const [, modifier = '', afterModifier = ' ', type = '', beforeAnd = '', and = '', beforeExpression = '', expression1 = '', expression2 = ''] = media.match(mediaRegExp) || [];\n    const raws = {\n      before,\n      after,\n      afterModifier,\n      originalModifier: modifier || '',\n      beforeAnd,\n      and,\n      beforeExpression\n    };\n    const nodes = parse(expression1 || expression2, true);\n    Object.assign(this, {\n      modifier,\n      type,\n      raws,\n      nodes\n    });\n  }\n\n  clone(overrides) {\n    const instance = new MediaQuery(String(this));\n    Object.assign(instance, overrides);\n    return instance;\n  }\n\n  invert() {\n    this.modifier = this.modifier ? '' : this.raws.originalModifier;\n    return this;\n  }\n\n  toString() {\n    const {\n      raws\n    } = this;\n    return `${raws.before}${this.modifier}${this.modifier ? `${raws.afterModifier}` : ''}${this.type}${raws.beforeAnd}${raws.and}${raws.beforeExpression}${this.nodes.join('')}${this.raws.after}`;\n  }\n\n}\n\nclass MediaExpression {\n  constructor(string) {\n    const [, value, after = '', and = '', afterAnd = ''] = string.match(andRegExp) || [null, string];\n    const raws = {\n      after,\n      and,\n      afterAnd\n    };\n    Object.assign(this, {\n      value,\n      raws\n    });\n  }\n\n  clone(overrides) {\n    const instance = new MediaExpression(String(this));\n    Object.assign(instance, overrides);\n    return instance;\n  }\n\n  toString() {\n    const {\n      raws\n    } = this;\n    return `${this.value}${raws.after}${raws.and}${raws.afterAnd}`;\n  }\n\n}\n\nconst modifierRE = '(not|only)';\nconst typeRE = '(all|print|screen|speech)';\nconst noExpressionRE = '([\\\\W\\\\w]*)';\nconst expressionRE = '([\\\\W\\\\w]+)';\nconst noSpaceRE = '(\\\\s*)';\nconst spaceRE = '(\\\\s+)';\nconst andRE = '(?:(\\\\s+)(and))';\nconst andRegExp = new RegExp(`^${expressionRE}(?:${andRE}${spaceRE})$`, 'i');\nconst spaceWrapRegExp = new RegExp(`^${noSpaceRE}${noExpressionRE}${noSpaceRE}$`);\nconst mediaRegExp = new RegExp(`^(?:${modifierRE}${spaceRE})?(?:${typeRE}(?:${andRE}${spaceRE}${expressionRE})?|${expressionRE})$`, 'i');\nvar mediaASTFromString = (string => new MediaQueryList(string));\n\nvar getCustomMediaFromRoot = ((root, opts) => {\n  // initialize custom selectors\n  const customMedias = {}; // for each custom selector atrule that is a child of the css root\n\n  root.nodes.slice().forEach(node => {\n    if (isCustomMedia(node)) {\n      // extract the name and selectors from the params of the custom selector\n      const [, name, selectors] = node.params.match(customMediaParamsRegExp); // write the parsed selectors to the custom selector\n\n      customMedias[name] = mediaASTFromString(selectors); // conditionally remove the custom selector atrule\n\n      if (!Object(opts).preserve) {\n        node.remove();\n      }\n    }\n  });\n  return customMedias;\n}); // match the custom selector name\n\nconst customMediaNameRegExp = /^custom-media$/i; // match the custom selector params\n\nconst customMediaParamsRegExp = /^(--[A-z][\\w-]*)\\s+([\\W\\w]+)\\s*$/; // whether the atrule is a custom selector\n\nconst isCustomMedia = node => node.type === 'atrule' && customMediaNameRegExp.test(node.name) && customMediaParamsRegExp.test(node.params);\n\n/* Get Custom Media from CSS File\n/* ========================================================================== */\n\nasync function getCustomMediaFromCSSFile(from) {\n  const css = await readFile(from);\n  const root = parse$1(css, {\n    from\n  });\n  return getCustomMediaFromRoot(root, {\n    preserve: true\n  });\n}\n/* Get Custom Media from Object\n/* ========================================================================== */\n\n\nfunction getCustomMediaFromObject(object) {\n  const customMedia = Object.assign({}, Object(object).customMedia, Object(object)['custom-media']);\n\n  for (const key in customMedia) {\n    customMedia[key] = mediaASTFromString(customMedia[key]);\n  }\n\n  return customMedia;\n}\n/* Get Custom Media from JSON file\n/* ========================================================================== */\n\n\nasync function getCustomMediaFromJSONFile(from) {\n  const object = await readJSON(from);\n  return getCustomMediaFromObject(object);\n}\n/* Get Custom Media from JS file\n/* ========================================================================== */\n\n\nasync function getCustomMediaFromJSFile(from) {\n  const object = await import(from);\n  return getCustomMediaFromObject(object);\n}\n/* Get Custom Media from Sources\n/* ========================================================================== */\n\n\nfunction getCustomMediaFromSources(sources) {\n  return sources.map(source => {\n    if (source instanceof Promise) {\n      return source;\n    } else if (source instanceof Function) {\n      return source();\n    } // read the source as an object\n\n\n    const opts = source === Object(source) ? source : {\n      from: String(source)\n    }; // skip objects with custom media\n\n    if (Object(opts).customMedia || Object(opts)['custom-media']) {\n      return opts;\n    } // source pathname\n\n\n    const from = path.resolve(String(opts.from || '')); // type of file being read from\n\n    const type = (opts.type || path.extname(from).slice(1)).toLowerCase();\n    return {\n      type,\n      from\n    };\n  }).reduce(async (customMedia, source) => {\n    const {\n      type,\n      from\n    } = await source;\n\n    if (type === 'css' || type === 'pcss') {\n      return Object.assign(await customMedia, await getCustomMediaFromCSSFile(from));\n    }\n\n    if (type === 'js') {\n      return Object.assign(await customMedia, await getCustomMediaFromJSFile(from));\n    }\n\n    if (type === 'json') {\n      return Object.assign(await customMedia, await getCustomMediaFromJSONFile(from));\n    }\n\n    return Object.assign(await customMedia, getCustomMediaFromObject(await source));\n  }, {});\n}\n/* Helper utilities\n/* ========================================================================== */\n\nconst readFile = from => new Promise((resolve, reject) => {\n  fs.readFile(from, 'utf8', (error, result) => {\n    if (error) {\n      reject(error);\n    } else {\n      resolve(result);\n    }\n  });\n});\n\nconst readJSON = async from => JSON.parse(await readFile(from));\n\n// return transformed medias, replacing custom pseudo medias with custom medias\nfunction transformMediaList(mediaList, customMedias) {\n  let index = mediaList.nodes.length - 1;\n\n  while (index >= 0) {\n    const transformedMedias = transformMedia(mediaList.nodes[index], customMedias);\n\n    if (transformedMedias.length) {\n      mediaList.nodes.splice(index, 1, ...transformedMedias);\n    }\n\n    --index;\n  }\n\n  return mediaList;\n} // return custom pseudo medias replaced with custom medias\n\nfunction transformMedia(media, customMedias) {\n  const transpiledMedias = [];\n\n  for (const index in media.nodes) {\n    const {\n      value,\n      nodes\n    } = media.nodes[index];\n    const key = value.replace(customPseudoRegExp, '$1');\n\n    if (key in customMedias) {\n      for (const replacementMedia of customMedias[key].nodes) {\n        // use the first available modifier unless they cancel each other out\n        const modifier = media.modifier !== replacementMedia.modifier ? media.modifier || replacementMedia.modifier : '';\n        const mediaClone = media.clone({\n          modifier,\n          // conditionally use the raws from the first available modifier\n          raws: !modifier || media.modifier ? { ...media.raws\n          } : { ...replacementMedia.raws\n          },\n          type: media.type || replacementMedia.type\n        }); // conditionally include more replacement raws when the type is present\n\n        if (mediaClone.type === replacementMedia.type) {\n          Object.assign(mediaClone.raws, {\n            and: replacementMedia.raws.and,\n            beforeAnd: replacementMedia.raws.beforeAnd,\n            beforeExpression: replacementMedia.raws.beforeExpression\n          });\n        }\n\n        mediaClone.nodes.splice(index, 1, ...replacementMedia.clone().nodes.map(node => {\n          // use raws and spacing from the current usage\n          if (media.nodes[index].raws.and) {\n            node.raws = { ...media.nodes[index].raws\n            };\n          }\n\n          node.spaces = { ...media.nodes[index].spaces\n          };\n          return node;\n        })); // remove the currently transformed key to prevent recursion\n\n        const nextCustomMedia = getCustomMediasWithoutKey(customMedias, key);\n        const retranspiledMedias = transformMedia(mediaClone, nextCustomMedia);\n\n        if (retranspiledMedias.length) {\n          transpiledMedias.push(...retranspiledMedias);\n        } else {\n          transpiledMedias.push(mediaClone);\n        }\n      }\n\n      return transpiledMedias;\n    } else if (nodes && nodes.length) {\n      transformMediaList(media.nodes[index], customMedias);\n    }\n  }\n\n  return transpiledMedias;\n}\n\nconst customPseudoRegExp = /\\((--[A-z][\\w-]*)\\)/;\n\nconst getCustomMediasWithoutKey = (customMedias, key) => {\n  const nextCustomMedias = Object.assign({}, customMedias);\n  delete nextCustomMedias[key];\n  return nextCustomMedias;\n};\n\nvar transformAtrules = ((root, customMedia, opts) => {\n  root.walkAtRules(mediaAtRuleRegExp, atrule => {\n    if (customPseudoRegExp$1.test(atrule.params)) {\n      const mediaAST = mediaASTFromString(atrule.params);\n      const params = String(transformMediaList(mediaAST, customMedia));\n\n      if (opts.preserve) {\n        atrule.cloneBefore({\n          params\n        });\n      } else {\n        atrule.params = params;\n      }\n    }\n  });\n});\nconst mediaAtRuleRegExp = /^media$/i;\nconst customPseudoRegExp$1 = /\\(--[A-z][\\w-]*\\)/;\n\n/* Write Custom Media from CSS File\n/* ========================================================================== */\n\nasync function writeCustomMediaToCssFile(to, customMedia) {\n  const cssContent = Object.keys(customMedia).reduce((cssLines, name) => {\n    cssLines.push(`@custom-media ${name} ${customMedia[name]};`);\n    return cssLines;\n  }, []).join('\\n');\n  const css = `${cssContent}\\n`;\n  await writeFile(to, css);\n}\n/* Write Custom Media from JSON file\n/* ========================================================================== */\n\n\nasync function writeCustomMediaToJsonFile(to, customMedia) {\n  const jsonContent = JSON.stringify({\n    'custom-media': customMedia\n  }, null, '  ');\n  const json = `${jsonContent}\\n`;\n  await writeFile(to, json);\n}\n/* Write Custom Media from Common JS file\n/* ========================================================================== */\n\n\nasync function writeCustomMediaToCjsFile(to, customMedia) {\n  const jsContents = Object.keys(customMedia).reduce((jsLines, name) => {\n    jsLines.push(`\\t\\t'${escapeForJS(name)}': '${escapeForJS(customMedia[name])}'`);\n    return jsLines;\n  }, []).join(',\\n');\n  const js = `module.exports = {\\n\\tcustomMedia: {\\n${jsContents}\\n\\t}\\n};\\n`;\n  await writeFile(to, js);\n}\n/* Write Custom Media from Module JS file\n/* ========================================================================== */\n\n\nasync function writeCustomMediaToMjsFile(to, customMedia) {\n  const mjsContents = Object.keys(customMedia).reduce((mjsLines, name) => {\n    mjsLines.push(`\\t'${escapeForJS(name)}': '${escapeForJS(customMedia[name])}'`);\n    return mjsLines;\n  }, []).join(',\\n');\n  const mjs = `export const customMedia = {\\n${mjsContents}\\n};\\n`;\n  await writeFile(to, mjs);\n}\n/* Write Custom Media to Exports\n/* ========================================================================== */\n\n\nfunction writeCustomMediaToExports(customMedia, destinations) {\n  return Promise.all(destinations.map(async destination => {\n    if (destination instanceof Function) {\n      await destination(defaultCustomMediaToJSON(customMedia));\n    } else {\n      // read the destination as an object\n      const opts = destination === Object(destination) ? destination : {\n        to: String(destination)\n      }; // transformer for custom media into a JSON-compatible object\n\n      const toJSON = opts.toJSON || defaultCustomMediaToJSON;\n\n      if ('customMedia' in opts) {\n        // write directly to an object as customMedia\n        opts.customMedia = toJSON(customMedia);\n      } else if ('custom-media' in opts) {\n        // write directly to an object as custom-media\n        opts['custom-media'] = toJSON(customMedia);\n      } else {\n        // destination pathname\n        const to = String(opts.to || ''); // type of file being written to\n\n        const type = (opts.type || path.extname(to).slice(1)).toLowerCase(); // transformed custom media\n\n        const customMediaJSON = toJSON(customMedia);\n\n        if (type === 'css') {\n          await writeCustomMediaToCssFile(to, customMediaJSON);\n        }\n\n        if (type === 'js') {\n          await writeCustomMediaToCjsFile(to, customMediaJSON);\n        }\n\n        if (type === 'json') {\n          await writeCustomMediaToJsonFile(to, customMediaJSON);\n        }\n\n        if (type === 'mjs') {\n          await writeCustomMediaToMjsFile(to, customMediaJSON);\n        }\n      }\n    }\n  }));\n}\n/* Helper utilities\n/* ========================================================================== */\n\nconst defaultCustomMediaToJSON = customMedia => {\n  return Object.keys(customMedia).reduce((customMediaJSON, key) => {\n    customMediaJSON[key] = String(customMedia[key]);\n    return customMediaJSON;\n  }, {});\n};\n\nconst writeFile = (to, text) => new Promise((resolve, reject) => {\n  fs.writeFile(to, text, error => {\n    if (error) {\n      reject(error);\n    } else {\n      resolve();\n    }\n  });\n});\n\nconst escapeForJS = string => string.replace(/\\\\([\\s\\S])|(')/g, '\\\\$1$2').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n\nconst creator = opts => {\n  // whether to preserve custom media and at-rules using them\n  const preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : false; // sources to import custom media from\n\n  const importFrom = [].concat(Object(opts).importFrom || []); // destinations to export custom media to\n\n  const exportTo = [].concat(Object(opts).exportTo || []); // promise any custom media are imported\n\n  const customMediaPromise = getCustomMediaFromSources(importFrom);\n  return {\n    postcssPlugin: 'postcss-custom-media',\n    Once: async root => {\n      const customMedia = Object.assign(await customMediaPromise, getCustomMediaFromRoot(root, {\n        preserve\n      }));\n      await writeCustomMediaToExports(customMedia, exportTo);\n      transformAtrules(root, customMedia, {\n        preserve\n      });\n    }\n  };\n};\n\ncreator.postcss = true;\n\nexport default creator;\n"]},"metadata":{},"sourceType":"module"}