{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SassWorkerImplementation = void 0;\n\nconst worker_threads_1 = require(\"worker_threads\");\n\nconst environment_options_1 = require(\"../utils/environment-options\");\n/**\n * The maximum number of Workers that will be created to execute render requests.\n */\n\n\nconst MAX_RENDER_WORKERS = environment_options_1.maxWorkers;\n/**\n * A Sass renderer implementation that provides an interface that can be used by Webpack's\n * `sass-loader`. The implementation uses a Worker thread to perform the Sass rendering\n * with the `dart-sass` package.  The `dart-sass` synchronous render function is used within\n * the worker which can be up to two times faster than the asynchronous variant.\n */\n\nclass SassWorkerImplementation {\n  constructor() {\n    this.workers = [];\n    this.availableWorkers = [];\n    this.requests = new Map();\n    this.idCounter = 1;\n    this.nextWorkerIndex = 0;\n  }\n  /**\n   * Provides information about the Sass implementation.\n   * This mimics enough of the `dart-sass` value to be used with the `sass-loader`.\n   */\n\n\n  get info() {\n    return 'dart-sass\\tworker';\n  }\n  /**\n   * The synchronous render function is not used by the `sass-loader`.\n   */\n\n\n  renderSync() {\n    throw new Error('Sass renderSync is not supported.');\n  }\n  /**\n   * Asynchronously request a Sass stylesheet to be renderered.\n   *\n   * @param options The `dart-sass` options to use when rendering the stylesheet.\n   * @param callback The function to execute when the rendering is complete.\n   */\n\n\n  render(options, callback) {\n    // The `functions`, `logger` and `importer` options are JavaScript functions that cannot be transferred.\n    // If any additional function options are added in the future, they must be excluded as well.\n    const {\n      functions,\n      importer,\n      logger,\n      ...serializableOptions\n    } = options; // The CLI's configuration does not use or expose the ability to defined custom Sass functions\n\n    if (functions && Object.keys(functions).length > 0) {\n      throw new Error('Sass custom functions are not supported.');\n    }\n\n    let workerIndex = this.availableWorkers.pop();\n\n    if (workerIndex === undefined) {\n      if (this.workers.length < MAX_RENDER_WORKERS) {\n        workerIndex = this.workers.length;\n        this.workers.push(this.createWorker());\n      } else {\n        workerIndex = this.nextWorkerIndex++;\n\n        if (this.nextWorkerIndex >= this.workers.length) {\n          this.nextWorkerIndex = 0;\n        }\n      }\n    }\n\n    const request = this.createRequest(workerIndex, callback, importer);\n    this.requests.set(request.id, request);\n    this.workers[workerIndex].postMessage({\n      id: request.id,\n      hasImporter: !!importer,\n      options: serializableOptions\n    });\n  }\n  /**\n   * Shutdown the Sass render worker.\n   * Executing this method will stop any pending render requests.\n   */\n\n\n  close() {\n    for (const worker of this.workers) {\n      try {\n        void worker.terminate();\n      } catch {}\n    }\n\n    this.requests.clear();\n  }\n\n  createWorker() {\n    const {\n      port1: mainImporterPort,\n      port2: workerImporterPort\n    } = new worker_threads_1.MessageChannel();\n    const importerSignal = new Int32Array(new SharedArrayBuffer(4));\n\n    const workerPath = require.resolve('./worker');\n\n    const worker = new worker_threads_1.Worker(workerPath, {\n      workerData: {\n        workerImporterPort,\n        importerSignal\n      },\n      transferList: [workerImporterPort]\n    });\n    worker.on('message', response => {\n      const request = this.requests.get(response.id);\n\n      if (!request) {\n        return;\n      }\n\n      this.requests.delete(response.id);\n      this.availableWorkers.push(request.workerIndex);\n\n      if (response.result) {\n        // The results are expected to be Node.js `Buffer` objects but will each be transferred as\n        // a Uint8Array that does not have the expected `toString` behavior of a `Buffer`.\n        const {\n          css,\n          map,\n          stats\n        } = response.result;\n        const result = {\n          // This `Buffer.from` override will use the memory directly and avoid making a copy\n          css: Buffer.from(css.buffer, css.byteOffset, css.byteLength),\n          stats\n        };\n\n        if (map) {\n          // This `Buffer.from` override will use the memory directly and avoid making a copy\n          result.map = Buffer.from(map.buffer, map.byteOffset, map.byteLength);\n        }\n\n        request.callback(undefined, result);\n      } else {\n        request.callback(response.error);\n      }\n    });\n    mainImporterPort.on('message', ({\n      id,\n      url,\n      prev,\n      fromImport\n    }) => {\n      const request = this.requests.get(id);\n\n      if (!(request === null || request === void 0 ? void 0 : request.importers)) {\n        mainImporterPort.postMessage(null);\n        Atomics.store(importerSignal, 0, 1);\n        Atomics.notify(importerSignal, 0);\n        return;\n      }\n\n      this.processImporters(request.importers, url, prev, fromImport).then(result => {\n        mainImporterPort.postMessage(result);\n      }).catch(error => {\n        mainImporterPort.postMessage(error);\n      }).finally(() => {\n        Atomics.store(importerSignal, 0, 1);\n        Atomics.notify(importerSignal, 0);\n      });\n    });\n    mainImporterPort.unref();\n    return worker;\n  }\n\n  processImporters(importers, url, prev, fromImport) {\n    return _asyncToGenerator(function* () {\n      let result = null;\n\n      for (const importer of importers) {\n        result = yield new Promise(resolve => {\n          // Importers can be both sync and async\n          const innerResult = importer.call({\n            fromImport\n          }, url, prev, resolve);\n\n          if (innerResult !== undefined) {\n            resolve(innerResult);\n          }\n        });\n\n        if (result) {\n          break;\n        }\n      }\n\n      return result;\n    })();\n  }\n\n  createRequest(workerIndex, callback, importer) {\n    return {\n      id: this.idCounter++,\n      workerIndex,\n      callback,\n      importers: !importer || Array.isArray(importer) ? importer : [importer]\n    };\n  }\n\n}\n\nexports.SassWorkerImplementation = SassWorkerImplementation;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/@angular-devkit/build-angular/src/sass/sass-service.js"],"names":["Object","defineProperty","exports","value","SassWorkerImplementation","worker_threads_1","require","environment_options_1","MAX_RENDER_WORKERS","maxWorkers","constructor","workers","availableWorkers","requests","Map","idCounter","nextWorkerIndex","info","renderSync","Error","render","options","callback","functions","importer","logger","serializableOptions","keys","length","workerIndex","pop","undefined","push","createWorker","request","createRequest","set","id","postMessage","hasImporter","close","worker","terminate","clear","port1","mainImporterPort","port2","workerImporterPort","MessageChannel","importerSignal","Int32Array","SharedArrayBuffer","workerPath","resolve","Worker","workerData","transferList","on","response","get","delete","result","css","map","stats","Buffer","from","buffer","byteOffset","byteLength","error","url","prev","fromImport","importers","Atomics","store","notify","processImporters","then","catch","finally","unref","Promise","innerResult","call","Array","isArray"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SassWorkerImplementation = void 0;\nconst worker_threads_1 = require(\"worker_threads\");\nconst environment_options_1 = require(\"../utils/environment-options\");\n/**\n * The maximum number of Workers that will be created to execute render requests.\n */\nconst MAX_RENDER_WORKERS = environment_options_1.maxWorkers;\n/**\n * A Sass renderer implementation that provides an interface that can be used by Webpack's\n * `sass-loader`. The implementation uses a Worker thread to perform the Sass rendering\n * with the `dart-sass` package.  The `dart-sass` synchronous render function is used within\n * the worker which can be up to two times faster than the asynchronous variant.\n */\nclass SassWorkerImplementation {\n    constructor() {\n        this.workers = [];\n        this.availableWorkers = [];\n        this.requests = new Map();\n        this.idCounter = 1;\n        this.nextWorkerIndex = 0;\n    }\n    /**\n     * Provides information about the Sass implementation.\n     * This mimics enough of the `dart-sass` value to be used with the `sass-loader`.\n     */\n    get info() {\n        return 'dart-sass\\tworker';\n    }\n    /**\n     * The synchronous render function is not used by the `sass-loader`.\n     */\n    renderSync() {\n        throw new Error('Sass renderSync is not supported.');\n    }\n    /**\n     * Asynchronously request a Sass stylesheet to be renderered.\n     *\n     * @param options The `dart-sass` options to use when rendering the stylesheet.\n     * @param callback The function to execute when the rendering is complete.\n     */\n    render(options, callback) {\n        // The `functions`, `logger` and `importer` options are JavaScript functions that cannot be transferred.\n        // If any additional function options are added in the future, they must be excluded as well.\n        const { functions, importer, logger, ...serializableOptions } = options;\n        // The CLI's configuration does not use or expose the ability to defined custom Sass functions\n        if (functions && Object.keys(functions).length > 0) {\n            throw new Error('Sass custom functions are not supported.');\n        }\n        let workerIndex = this.availableWorkers.pop();\n        if (workerIndex === undefined) {\n            if (this.workers.length < MAX_RENDER_WORKERS) {\n                workerIndex = this.workers.length;\n                this.workers.push(this.createWorker());\n            }\n            else {\n                workerIndex = this.nextWorkerIndex++;\n                if (this.nextWorkerIndex >= this.workers.length) {\n                    this.nextWorkerIndex = 0;\n                }\n            }\n        }\n        const request = this.createRequest(workerIndex, callback, importer);\n        this.requests.set(request.id, request);\n        this.workers[workerIndex].postMessage({\n            id: request.id,\n            hasImporter: !!importer,\n            options: serializableOptions,\n        });\n    }\n    /**\n     * Shutdown the Sass render worker.\n     * Executing this method will stop any pending render requests.\n     */\n    close() {\n        for (const worker of this.workers) {\n            try {\n                void worker.terminate();\n            }\n            catch { }\n        }\n        this.requests.clear();\n    }\n    createWorker() {\n        const { port1: mainImporterPort, port2: workerImporterPort } = new worker_threads_1.MessageChannel();\n        const importerSignal = new Int32Array(new SharedArrayBuffer(4));\n        const workerPath = require.resolve('./worker');\n        const worker = new worker_threads_1.Worker(workerPath, {\n            workerData: { workerImporterPort, importerSignal },\n            transferList: [workerImporterPort],\n        });\n        worker.on('message', (response) => {\n            const request = this.requests.get(response.id);\n            if (!request) {\n                return;\n            }\n            this.requests.delete(response.id);\n            this.availableWorkers.push(request.workerIndex);\n            if (response.result) {\n                // The results are expected to be Node.js `Buffer` objects but will each be transferred as\n                // a Uint8Array that does not have the expected `toString` behavior of a `Buffer`.\n                const { css, map, stats } = response.result;\n                const result = {\n                    // This `Buffer.from` override will use the memory directly and avoid making a copy\n                    css: Buffer.from(css.buffer, css.byteOffset, css.byteLength),\n                    stats,\n                };\n                if (map) {\n                    // This `Buffer.from` override will use the memory directly and avoid making a copy\n                    result.map = Buffer.from(map.buffer, map.byteOffset, map.byteLength);\n                }\n                request.callback(undefined, result);\n            }\n            else {\n                request.callback(response.error);\n            }\n        });\n        mainImporterPort.on('message', ({ id, url, prev, fromImport, }) => {\n            const request = this.requests.get(id);\n            if (!(request === null || request === void 0 ? void 0 : request.importers)) {\n                mainImporterPort.postMessage(null);\n                Atomics.store(importerSignal, 0, 1);\n                Atomics.notify(importerSignal, 0);\n                return;\n            }\n            this.processImporters(request.importers, url, prev, fromImport)\n                .then((result) => {\n                mainImporterPort.postMessage(result);\n            })\n                .catch((error) => {\n                mainImporterPort.postMessage(error);\n            })\n                .finally(() => {\n                Atomics.store(importerSignal, 0, 1);\n                Atomics.notify(importerSignal, 0);\n            });\n        });\n        mainImporterPort.unref();\n        return worker;\n    }\n    async processImporters(importers, url, prev, fromImport) {\n        let result = null;\n        for (const importer of importers) {\n            result = await new Promise((resolve) => {\n                // Importers can be both sync and async\n                const innerResult = importer.call({ fromImport }, url, prev, resolve);\n                if (innerResult !== undefined) {\n                    resolve(innerResult);\n                }\n            });\n            if (result) {\n                break;\n            }\n        }\n        return result;\n    }\n    createRequest(workerIndex, callback, importer) {\n        return {\n            id: this.idCounter++,\n            workerIndex,\n            callback,\n            importers: !importer || Array.isArray(importer) ? importer : [importer],\n        };\n    }\n}\nexports.SassWorkerImplementation = SassWorkerImplementation;\n"]},"metadata":{},"sourceType":"script"}