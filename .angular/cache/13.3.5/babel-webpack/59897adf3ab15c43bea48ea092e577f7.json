{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _hoist = require(\"./hoist\");\n\nvar _emit = require(\"./emit\");\n\nvar _replaceShorthandObjectMethod = _interopRequireDefault(require(\"./replaceShorthandObjectMethod\"));\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nexports.getVisitor = function (_ref) {\n  var t = _ref.types;\n  return {\n    Method: function Method(path, state) {\n      var node = path.node;\n      if (!shouldRegenerate(node, state)) return;\n      var container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);\n      path.get(\"body\").set(\"body\", [t.returnStatement(t.callExpression(container, []))]); // Regardless of whether or not the wrapped function is a an async method\n      // or generator the outer function should not be\n\n      node.async = false;\n      node.generator = false; // Unwrap the wrapper IIFE's environment so super and this and such still work.\n\n      path.get(\"body.body.0.argument.callee\").unwrapFunctionEnvironment();\n    },\n    Function: {\n      exit: util.wrapWithTypes(t, function (path, state) {\n        var node = path.node;\n        if (!shouldRegenerate(node, state)) return; // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n\n        path = (0, _replaceShorthandObjectMethod[\"default\"])(path);\n        node = path.node;\n        var contextId = path.scope.generateUidIdentifier(\"context\");\n        var argsId = path.scope.generateUidIdentifier(\"args\");\n        path.ensureBlock();\n        var bodyBlockPath = path.get(\"body\");\n\n        if (node.async) {\n          bodyBlockPath.traverse(awaitVisitor);\n        }\n\n        bodyBlockPath.traverse(functionSentVisitor, {\n          context: contextId\n        });\n        var outerBody = [];\n        var innerBody = [];\n        bodyBlockPath.get(\"body\").forEach(function (childPath) {\n          var node = childPath.node;\n\n          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {\n            // Babylon represents directives like \"use strict\" as elements\n            // of a bodyBlockPath.node.directives array, but they could just\n            // as easily be represented (by other parsers) as traditional\n            // string-literal-valued expression statements, so we need to\n            // handle that here. (#248)\n            outerBody.push(node);\n          } else if (node && node._blockHoist != null) {\n            outerBody.push(node);\n          } else {\n            innerBody.push(node);\n          }\n        });\n\n        if (outerBody.length > 0) {\n          // Only replace the inner body if we actually hoisted any statements\n          // to the outer body.\n          bodyBlockPath.node.body = innerBody;\n        }\n\n        var outerFnExpr = getOuterFnExpr(path); // Note that getOuterFnExpr has the side-effect of ensuring that the\n        // function has a name (so node.id will always be an Identifier), even\n        // if a temporary name has to be synthesized.\n\n        t.assertIdentifier(node.id);\n        var innerFnId = t.identifier(node.id.name + \"$\"); // Turn all declarations into vars, and replace the original\n        // declarations with equivalent assignment expressions.\n\n        var vars = (0, _hoist.hoist)(path);\n        var context = {\n          usesThis: false,\n          usesArguments: false,\n          getArgsId: function getArgsId() {\n            return t.clone(argsId);\n          }\n        };\n        path.traverse(argumentsThisVisitor, context);\n\n        if (context.usesArguments) {\n          vars = vars || t.variableDeclaration(\"var\", []);\n          vars.declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier(\"arguments\")));\n        }\n\n        var emitter = new _emit.Emitter(contextId);\n        emitter.explode(path.get(\"body\"));\n\n        if (vars && vars.declarations.length > 0) {\n          outerBody.push(vars);\n        }\n\n        var wrapArgs = [emitter.getContextFunction(innerFnId)];\n        var tryLocsList = emitter.getTryLocsList();\n\n        if (node.generator) {\n          wrapArgs.push(outerFnExpr);\n        } else if (context.usesThis || tryLocsList || node.async) {\n          // Async functions that are not generators don't care about the\n          // outer function because they don't need it to be marked and don't\n          // inherit from its .prototype.\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (context.usesThis) {\n          wrapArgs.push(t.thisExpression());\n        } else if (tryLocsList || node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (tryLocsList) {\n          wrapArgs.push(tryLocsList);\n        } else if (node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (node.async) {\n          // Rename any locally declared \"Promise\" variable,\n          // to use the global one.\n          var currentScope = path.scope;\n\n          do {\n            if (currentScope.hasOwnBinding(\"Promise\")) currentScope.rename(\"Promise\");\n          } while (currentScope = currentScope.parent);\n\n          wrapArgs.push(t.identifier(\"Promise\"));\n        }\n\n        var wrapCall = t.callExpression(util.runtimeProperty(node.async ? \"async\" : \"wrap\"), wrapArgs);\n        outerBody.push(t.returnStatement(wrapCall));\n        node.body = t.blockStatement(outerBody); // We injected a few new variable declarations (for every hoisted var),\n        // so we need to add them to the scope.\n\n        path.get(\"body.body\").forEach(function (p) {\n          return p.scope.registerDeclaration(p);\n        });\n        var oldDirectives = bodyBlockPath.node.directives;\n\n        if (oldDirectives) {\n          // Babylon represents directives like \"use strict\" as elements of\n          // a bodyBlockPath.node.directives array. (#248)\n          node.body.directives = oldDirectives;\n        }\n\n        var wasGeneratorFunction = node.generator;\n\n        if (wasGeneratorFunction) {\n          node.generator = false;\n        }\n\n        if (node.async) {\n          node.async = false;\n        }\n\n        if (wasGeneratorFunction && t.isExpression(node)) {\n          util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]));\n          path.addComment(\"leading\", \"#__PURE__\");\n        }\n\n        var insertedLocs = emitter.getInsertedLocs();\n        path.traverse({\n          NumericLiteral: function NumericLiteral(path) {\n            if (!insertedLocs.has(path.node)) {\n              return;\n            }\n\n            path.replaceWith(t.numericLiteral(path.node.value));\n          }\n        }); // Generators are processed in 'exit' handlers so that regenerator only has to run on\n        // an ES5 AST, but that means traversal will not pick up newly inserted references\n        // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n\n        path.requeue();\n      })\n    }\n  };\n}; // Check if a node should be transformed by regenerator\n\n\nfunction shouldRegenerate(node, state) {\n  if (node.generator) {\n    if (node.async) {\n      // Async generator\n      return state.opts.asyncGenerators !== false;\n    } else {\n      // Plain generator\n      return state.opts.generators !== false;\n    }\n  } else if (node.async) {\n    // Async function\n    return state.opts.async !== false;\n  } else {\n    // Not a generator or async function.\n    return false;\n  }\n} // Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\n\n\nfunction getOuterFnExpr(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n  t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n\n  return t.clone(node.id);\n}\n\nvar markInfo = new WeakMap();\n\nfunction getMarkInfo(node) {\n  if (!markInfo.has(node)) {\n    markInfo.set(node, {});\n  }\n\n  return markInfo.get(node);\n}\n\nfunction getMarkedFunctionId(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertIdentifier(node.id);\n  var blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n\n  if (!blockPath) {\n    return node.id;\n  }\n\n  var block = blockPath.node;\n\n  _assert[\"default\"].ok(Array.isArray(block.body));\n\n  var info = getMarkInfo(block);\n\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n\n  _assert[\"default\"].strictEqual(info.declPath.node, info.decl); // Get a new unique identifier for our marked variable.\n\n\n  var markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  var markCallExp = t.callExpression(util.runtimeProperty(\"mark\"), [t.clone(node.id)]);\n  var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;\n  var markCallExpPath = info.declPath.get(\"declarations.\" + index + \".init\");\n\n  _assert[\"default\"].strictEqual(markCallExpPath.node, markCallExp);\n\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n  return t.clone(markedId);\n}\n\nvar argumentsThisVisitor = {\n  \"FunctionExpression|FunctionDeclaration|Method\": function FunctionExpressionFunctionDeclarationMethod(path) {\n    path.skip();\n  },\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getArgsId());\n      state.usesArguments = true;\n    }\n  },\n  ThisExpression: function ThisExpression(path, state) {\n    state.usesThis = true;\n  }\n};\nvar functionSentVisitor = {\n  MetaProperty: function MetaProperty(path) {\n    var node = path.node;\n\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      var t = util.getTypes();\n      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier(\"_sent\")));\n    }\n  }\n};\nvar awaitVisitor = {\n  Function: function Function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n  AwaitExpression: function AwaitExpression(path) {\n    var t = util.getTypes(); // Convert await expressions to yield expressions.\n\n    var argument = path.node.argument; // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n\n    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty(\"awrap\"), [argument]), false));\n  }\n};","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/regenerator-transform/lib/visit.js"],"names":["_interopRequireDefault","require","_assert","_hoist","_emit","_replaceShorthandObjectMethod","util","_interopRequireWildcard","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","exports","getVisitor","_ref","t","types","Method","path","state","node","shouldRegenerate","container","functionExpression","cloneNode","body","generator","async","returnStatement","callExpression","unwrapFunctionEnvironment","Function","exit","wrapWithTypes","contextId","scope","generateUidIdentifier","argsId","ensureBlock","bodyBlockPath","traverse","awaitVisitor","functionSentVisitor","context","outerBody","innerBody","forEach","childPath","isExpressionStatement","isStringLiteral","expression","push","_blockHoist","length","outerFnExpr","getOuterFnExpr","assertIdentifier","id","innerFnId","identifier","name","vars","hoist","usesThis","usesArguments","getArgsId","clone","argumentsThisVisitor","variableDeclaration","declarations","variableDeclarator","emitter","Emitter","explode","wrapArgs","getContextFunction","tryLocsList","getTryLocsList","nullLiteral","thisExpression","currentScope","hasOwnBinding","rename","parent","wrapCall","runtimeProperty","blockStatement","p","registerDeclaration","oldDirectives","directives","wasGeneratorFunction","isExpression","replaceWithOrRemove","addComment","insertedLocs","getInsertedLocs","NumericLiteral","replaceWith","numericLiteral","value","requeue","opts","asyncGenerators","generators","funPath","getTypes","assertFunction","isFunctionDeclaration","getMarkedFunctionId","markInfo","getMarkInfo","blockPath","findParent","isProgram","isBlockStatement","block","ok","Array","isArray","info","decl","unshiftContainer","declPath","strictEqual","markedId","markCallExp","index","markCallExpPath","FunctionExpressionFunctionDeclarationMethod","skip","Identifier","isReference","ThisExpression","MetaProperty","meta","property","memberExpression","AwaitExpression","argument","yieldExpression"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _hoist = require(\"./hoist\");\n\nvar _emit = require(\"./emit\");\n\nvar _replaceShorthandObjectMethod = _interopRequireDefault(require(\"./replaceShorthandObjectMethod\"));\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nexports.getVisitor = function (_ref) {\n  var t = _ref.types;\n  return {\n    Method: function Method(path, state) {\n      var node = path.node;\n      if (!shouldRegenerate(node, state)) return;\n      var container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);\n      path.get(\"body\").set(\"body\", [t.returnStatement(t.callExpression(container, []))]); // Regardless of whether or not the wrapped function is a an async method\n      // or generator the outer function should not be\n\n      node.async = false;\n      node.generator = false; // Unwrap the wrapper IIFE's environment so super and this and such still work.\n\n      path.get(\"body.body.0.argument.callee\").unwrapFunctionEnvironment();\n    },\n    Function: {\n      exit: util.wrapWithTypes(t, function (path, state) {\n        var node = path.node;\n        if (!shouldRegenerate(node, state)) return; // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n\n        path = (0, _replaceShorthandObjectMethod[\"default\"])(path);\n        node = path.node;\n        var contextId = path.scope.generateUidIdentifier(\"context\");\n        var argsId = path.scope.generateUidIdentifier(\"args\");\n        path.ensureBlock();\n        var bodyBlockPath = path.get(\"body\");\n\n        if (node.async) {\n          bodyBlockPath.traverse(awaitVisitor);\n        }\n\n        bodyBlockPath.traverse(functionSentVisitor, {\n          context: contextId\n        });\n        var outerBody = [];\n        var innerBody = [];\n        bodyBlockPath.get(\"body\").forEach(function (childPath) {\n          var node = childPath.node;\n\n          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {\n            // Babylon represents directives like \"use strict\" as elements\n            // of a bodyBlockPath.node.directives array, but they could just\n            // as easily be represented (by other parsers) as traditional\n            // string-literal-valued expression statements, so we need to\n            // handle that here. (#248)\n            outerBody.push(node);\n          } else if (node && node._blockHoist != null) {\n            outerBody.push(node);\n          } else {\n            innerBody.push(node);\n          }\n        });\n\n        if (outerBody.length > 0) {\n          // Only replace the inner body if we actually hoisted any statements\n          // to the outer body.\n          bodyBlockPath.node.body = innerBody;\n        }\n\n        var outerFnExpr = getOuterFnExpr(path); // Note that getOuterFnExpr has the side-effect of ensuring that the\n        // function has a name (so node.id will always be an Identifier), even\n        // if a temporary name has to be synthesized.\n\n        t.assertIdentifier(node.id);\n        var innerFnId = t.identifier(node.id.name + \"$\"); // Turn all declarations into vars, and replace the original\n        // declarations with equivalent assignment expressions.\n\n        var vars = (0, _hoist.hoist)(path);\n        var context = {\n          usesThis: false,\n          usesArguments: false,\n          getArgsId: function getArgsId() {\n            return t.clone(argsId);\n          }\n        };\n        path.traverse(argumentsThisVisitor, context);\n\n        if (context.usesArguments) {\n          vars = vars || t.variableDeclaration(\"var\", []);\n          vars.declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier(\"arguments\")));\n        }\n\n        var emitter = new _emit.Emitter(contextId);\n        emitter.explode(path.get(\"body\"));\n\n        if (vars && vars.declarations.length > 0) {\n          outerBody.push(vars);\n        }\n\n        var wrapArgs = [emitter.getContextFunction(innerFnId)];\n        var tryLocsList = emitter.getTryLocsList();\n\n        if (node.generator) {\n          wrapArgs.push(outerFnExpr);\n        } else if (context.usesThis || tryLocsList || node.async) {\n          // Async functions that are not generators don't care about the\n          // outer function because they don't need it to be marked and don't\n          // inherit from its .prototype.\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (context.usesThis) {\n          wrapArgs.push(t.thisExpression());\n        } else if (tryLocsList || node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (tryLocsList) {\n          wrapArgs.push(tryLocsList);\n        } else if (node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (node.async) {\n          // Rename any locally declared \"Promise\" variable,\n          // to use the global one.\n          var currentScope = path.scope;\n\n          do {\n            if (currentScope.hasOwnBinding(\"Promise\")) currentScope.rename(\"Promise\");\n          } while (currentScope = currentScope.parent);\n\n          wrapArgs.push(t.identifier(\"Promise\"));\n        }\n\n        var wrapCall = t.callExpression(util.runtimeProperty(node.async ? \"async\" : \"wrap\"), wrapArgs);\n        outerBody.push(t.returnStatement(wrapCall));\n        node.body = t.blockStatement(outerBody); // We injected a few new variable declarations (for every hoisted var),\n        // so we need to add them to the scope.\n\n        path.get(\"body.body\").forEach(function (p) {\n          return p.scope.registerDeclaration(p);\n        });\n        var oldDirectives = bodyBlockPath.node.directives;\n\n        if (oldDirectives) {\n          // Babylon represents directives like \"use strict\" as elements of\n          // a bodyBlockPath.node.directives array. (#248)\n          node.body.directives = oldDirectives;\n        }\n\n        var wasGeneratorFunction = node.generator;\n\n        if (wasGeneratorFunction) {\n          node.generator = false;\n        }\n\n        if (node.async) {\n          node.async = false;\n        }\n\n        if (wasGeneratorFunction && t.isExpression(node)) {\n          util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]));\n          path.addComment(\"leading\", \"#__PURE__\");\n        }\n\n        var insertedLocs = emitter.getInsertedLocs();\n        path.traverse({\n          NumericLiteral: function NumericLiteral(path) {\n            if (!insertedLocs.has(path.node)) {\n              return;\n            }\n\n            path.replaceWith(t.numericLiteral(path.node.value));\n          }\n        }); // Generators are processed in 'exit' handlers so that regenerator only has to run on\n        // an ES5 AST, but that means traversal will not pick up newly inserted references\n        // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n\n        path.requeue();\n      })\n    }\n  };\n}; // Check if a node should be transformed by regenerator\n\n\nfunction shouldRegenerate(node, state) {\n  if (node.generator) {\n    if (node.async) {\n      // Async generator\n      return state.opts.asyncGenerators !== false;\n    } else {\n      // Plain generator\n      return state.opts.generators !== false;\n    }\n  } else if (node.async) {\n    // Async function\n    return state.opts.async !== false;\n  } else {\n    // Not a generator or async function.\n    return false;\n  }\n} // Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\n\n\nfunction getOuterFnExpr(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n  t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n\n  return t.clone(node.id);\n}\n\nvar markInfo = new WeakMap();\n\nfunction getMarkInfo(node) {\n  if (!markInfo.has(node)) {\n    markInfo.set(node, {});\n  }\n\n  return markInfo.get(node);\n}\n\nfunction getMarkedFunctionId(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertIdentifier(node.id);\n  var blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n\n  if (!blockPath) {\n    return node.id;\n  }\n\n  var block = blockPath.node;\n\n  _assert[\"default\"].ok(Array.isArray(block.body));\n\n  var info = getMarkInfo(block);\n\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n\n  _assert[\"default\"].strictEqual(info.declPath.node, info.decl); // Get a new unique identifier for our marked variable.\n\n\n  var markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  var markCallExp = t.callExpression(util.runtimeProperty(\"mark\"), [t.clone(node.id)]);\n  var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;\n  var markCallExpPath = info.declPath.get(\"declarations.\" + index + \".init\");\n\n  _assert[\"default\"].strictEqual(markCallExpPath.node, markCallExp);\n\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n  return t.clone(markedId);\n}\n\nvar argumentsThisVisitor = {\n  \"FunctionExpression|FunctionDeclaration|Method\": function FunctionExpressionFunctionDeclarationMethod(path) {\n    path.skip();\n  },\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getArgsId());\n      state.usesArguments = true;\n    }\n  },\n  ThisExpression: function ThisExpression(path, state) {\n    state.usesThis = true;\n  }\n};\nvar functionSentVisitor = {\n  MetaProperty: function MetaProperty(path) {\n    var node = path.node;\n\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      var t = util.getTypes();\n      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier(\"_sent\")));\n    }\n  }\n};\nvar awaitVisitor = {\n  Function: function Function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n  AwaitExpression: function AwaitExpression(path) {\n    var t = util.getTypes(); // Convert await expressions to yield expressions.\n\n    var argument = path.node.argument; // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n\n    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty(\"awrap\"), [argument]), false));\n  }\n};"]},"metadata":{},"sourceType":"script"}