{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nconst {\n  promisify\n} = require('util');\n\nconst mm = require('minimatch');\n\nconst Glob = require('glob').Glob;\n\nconst fs = require('graceful-fs');\n\nconst statAsync = promisify(fs.stat.bind(fs));\n\nconst pathLib = require('path');\n\nconst _ = require('lodash');\n\nconst File = require('./file');\n\nconst Url = require('./url');\n\nconst helper = require('./helper');\n\nconst log = require('./logger').create('filelist');\n\nconst createPatternObject = require('./config').createPatternObject;\n\nclass FileList {\n  constructor(patterns, excludes, emitter, preprocess, autoWatchBatchDelay) {\n    this._patterns = patterns || [];\n    this._excludes = excludes || [];\n    this._emitter = emitter;\n    this._preprocess = preprocess;\n    this.buckets = new Map(); // A promise that is pending if and only if we are active in this.refresh_()\n\n    this._refreshing = null;\n\n    const emit = () => {\n      this._emitter.emit('file_list_modified', this.files);\n    };\n\n    const debouncedEmit = _.debounce(emit, autoWatchBatchDelay);\n\n    this._emitModified = immediate => {\n      immediate ? emit() : debouncedEmit();\n    };\n  }\n\n  _findExcluded(path) {\n    return this._excludes.find(pattern => mm(path, pattern));\n  }\n\n  _findIncluded(path) {\n    return this._patterns.find(pattern => mm(path, pattern.pattern));\n  }\n\n  _findFile(path, pattern) {\n    if (!path || !pattern) return;\n    return this._getFilesByPattern(pattern.pattern).find(file => file.originalPath === path);\n  }\n\n  _exists(path) {\n    return !!this._patterns.find(pattern => mm(path, pattern.pattern) && this._findFile(path, pattern));\n  }\n\n  _getFilesByPattern(pattern) {\n    return this.buckets.get(pattern) || [];\n  }\n\n  _refresh() {\n    var _this = this;\n\n    const matchedFiles = new Set();\n    let lastCompletedRefresh = this._refreshing;\n    lastCompletedRefresh = Promise.all(this._patterns.map( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* ({\n        pattern,\n        type,\n        nocache,\n        isBinary\n      }) {\n        if (helper.isUrlAbsolute(pattern)) {\n          _this.buckets.set(pattern, [new Url(pattern, type)]);\n\n          return;\n        }\n\n        const mg = new Glob(pathLib.normalize(pattern), {\n          cwd: '/',\n          follow: true,\n          nodir: true,\n          sync: true\n        });\n        const files = mg.found.filter(path => {\n          if (_this._findExcluded(path)) {\n            log.debug(`Excluded file \"${path}\"`);\n            return false;\n          } else if (matchedFiles.has(path)) {\n            return false;\n          } else {\n            matchedFiles.add(path);\n            return true;\n          }\n        }).map(path => new File(path, mg.statCache[path].mtime, nocache, type, isBinary));\n\n        if (nocache) {\n          log.debug(`Not preprocessing \"${pattern}\" due to nocache`);\n        } else {\n          yield Promise.all(files.map(file => _this._preprocess(file)));\n        }\n\n        _this.buckets.set(pattern, files);\n\n        if (_.isEmpty(mg.found)) {\n          log.warn(`Pattern \"${pattern}\" does not match any file.`);\n        } else if (_.isEmpty(files)) {\n          log.warn(`All files matched by \"${pattern}\" were excluded or matched by prior matchers.`);\n        }\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }())).then(() => {\n      // When we return from this function the file processing chain will be\n      // complete. In the case of two fast refresh() calls, the second call\n      // will overwrite this._refreshing, and we want the status to reflect\n      // the second call and skip the modification event from the first call.\n      if (this._refreshing !== lastCompletedRefresh) {\n        return this._refreshing;\n      }\n\n      this._emitModified(true);\n\n      return this.files;\n    });\n    return lastCompletedRefresh;\n  }\n\n  get files() {\n    const served = [];\n    const included = {};\n    const lookup = {};\n\n    this._patterns.forEach(p => {\n      // This needs to be here sadly, as plugins are modifiying\n      // the _patterns directly resulting in elements not being\n      // instantiated properly\n      if (p.constructor.name !== 'Pattern') {\n        p = createPatternObject(p);\n      }\n\n      const files = this._getFilesByPattern(p.pattern);\n\n      files.sort((a, b) => {\n        if (a.path > b.path) return 1;\n        if (a.path < b.path) return -1;\n        return 0;\n      });\n\n      if (p.served) {\n        served.push(...files);\n      }\n\n      files.forEach(file => {\n        if (lookup[file.path] && lookup[file.path].compare(p) < 0) return;\n        lookup[file.path] = p;\n\n        if (p.included) {\n          included[file.path] = file;\n        } else {\n          delete included[file.path];\n        }\n      });\n    });\n\n    return {\n      served: _.uniq(served, 'path'),\n      included: _.values(included)\n    };\n  }\n\n  refresh() {\n    this._refreshing = this._refresh();\n    return this._refreshing;\n  }\n\n  reload(patterns, excludes) {\n    this._patterns = patterns || [];\n    this._excludes = excludes || [];\n    return this.refresh();\n  }\n\n  addFile(path) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const excluded = _this2._findExcluded(path);\n\n      if (excluded) {\n        log.debug(`Add file \"${path}\" ignored. Excluded by \"${excluded}\".`);\n        return _this2.files;\n      }\n\n      const pattern = _this2._findIncluded(path);\n\n      if (!pattern) {\n        log.debug(`Add file \"${path}\" ignored. Does not match any pattern.`);\n        return _this2.files;\n      }\n\n      if (_this2._exists(path)) {\n        log.debug(`Add file \"${path}\" ignored. Already in the list.`);\n        return _this2.files;\n      }\n\n      const file = new File(path);\n\n      _this2._getFilesByPattern(pattern.pattern).push(file);\n\n      const [stat] = yield Promise.all([statAsync(path), _this2._refreshing]);\n      file.mtime = stat.mtime;\n      yield _this2._preprocess(file);\n      log.info(`Added file \"${path}\".`);\n\n      _this2._emitModified();\n\n      return _this2.files;\n    })();\n  }\n\n  changeFile(path, force) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const pattern = _this3._findIncluded(path);\n\n      const file = _this3._findFile(path, pattern);\n\n      if (!file) {\n        log.debug(`Changed file \"${path}\" ignored. Does not match any file in the list.`);\n        return _this3.files;\n      }\n\n      const [stat] = yield Promise.all([statAsync(path), _this3._refreshing]);\n\n      if (force || stat.mtime > file.mtime) {\n        file.mtime = stat.mtime;\n        yield _this3._preprocess(file);\n        log.info(`Changed file \"${path}\".`);\n\n        _this3._emitModified(force);\n      }\n\n      return _this3.files;\n    })();\n  }\n\n  removeFile(path) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const pattern = _this4._findIncluded(path);\n\n      const file = _this4._findFile(path, pattern);\n\n      if (file) {\n        helper.arrayRemove(_this4._getFilesByPattern(pattern.pattern), file);\n        log.info(`Removed file \"${path}\".`);\n\n        _this4._emitModified();\n      } else {\n        log.debug(`Removed file \"${path}\" ignored. Does not match any file in the list.`);\n      }\n\n      return _this4.files;\n    })();\n  }\n\n}\n\nFileList.factory = function (config, emitter, preprocess) {\n  return new FileList(config.files, config.exclude, emitter, preprocess, config.autoWatchBatchDelay);\n};\n\nFileList.factory.$inject = ['config', 'emitter', 'preprocess'];\nmodule.exports = FileList;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/karma/lib/file-list.js"],"names":["promisify","require","mm","Glob","fs","statAsync","stat","bind","pathLib","_","File","Url","helper","log","create","createPatternObject","FileList","constructor","patterns","excludes","emitter","preprocess","autoWatchBatchDelay","_patterns","_excludes","_emitter","_preprocess","buckets","Map","_refreshing","emit","files","debouncedEmit","debounce","_emitModified","immediate","_findExcluded","path","find","pattern","_findIncluded","_findFile","_getFilesByPattern","file","originalPath","_exists","get","_refresh","matchedFiles","Set","lastCompletedRefresh","Promise","all","map","type","nocache","isBinary","isUrlAbsolute","set","mg","normalize","cwd","follow","nodir","sync","found","filter","debug","has","add","statCache","mtime","isEmpty","warn","then","served","included","lookup","forEach","p","name","sort","a","b","push","compare","uniq","values","refresh","reload","addFile","excluded","info","changeFile","force","removeFile","arrayRemove","factory","config","exclude","$inject","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { promisify } = require('util')\nconst mm = require('minimatch')\nconst Glob = require('glob').Glob\nconst fs = require('graceful-fs')\nconst statAsync = promisify(fs.stat.bind(fs))\nconst pathLib = require('path')\nconst _ = require('lodash')\n\nconst File = require('./file')\nconst Url = require('./url')\nconst helper = require('./helper')\nconst log = require('./logger').create('filelist')\nconst createPatternObject = require('./config').createPatternObject\n\nclass FileList {\n  constructor (patterns, excludes, emitter, preprocess, autoWatchBatchDelay) {\n    this._patterns = patterns || []\n    this._excludes = excludes || []\n    this._emitter = emitter\n    this._preprocess = preprocess\n\n    this.buckets = new Map()\n\n    // A promise that is pending if and only if we are active in this.refresh_()\n    this._refreshing = null\n\n    const emit = () => {\n      this._emitter.emit('file_list_modified', this.files)\n    }\n\n    const debouncedEmit = _.debounce(emit, autoWatchBatchDelay)\n    this._emitModified = (immediate) => {\n      immediate ? emit() : debouncedEmit()\n    }\n  }\n\n  _findExcluded (path) {\n    return this._excludes.find((pattern) => mm(path, pattern))\n  }\n\n  _findIncluded (path) {\n    return this._patterns.find((pattern) => mm(path, pattern.pattern))\n  }\n\n  _findFile (path, pattern) {\n    if (!path || !pattern) return\n    return this._getFilesByPattern(pattern.pattern).find((file) => file.originalPath === path)\n  }\n\n  _exists (path) {\n    return !!this._patterns.find((pattern) => mm(path, pattern.pattern) && this._findFile(path, pattern))\n  }\n\n  _getFilesByPattern (pattern) {\n    return this.buckets.get(pattern) || []\n  }\n\n  _refresh () {\n    const matchedFiles = new Set()\n\n    let lastCompletedRefresh = this._refreshing\n    lastCompletedRefresh = Promise.all(\n      this._patterns.map(async ({ pattern, type, nocache, isBinary }) => {\n        if (helper.isUrlAbsolute(pattern)) {\n          this.buckets.set(pattern, [new Url(pattern, type)])\n          return\n        }\n\n        const mg = new Glob(pathLib.normalize(pattern), { cwd: '/', follow: true, nodir: true, sync: true })\n\n        const files = mg.found\n          .filter((path) => {\n            if (this._findExcluded(path)) {\n              log.debug(`Excluded file \"${path}\"`)\n              return false\n            } else if (matchedFiles.has(path)) {\n              return false\n            } else {\n              matchedFiles.add(path)\n              return true\n            }\n          })\n          .map((path) => new File(path, mg.statCache[path].mtime, nocache, type, isBinary))\n\n        if (nocache) {\n          log.debug(`Not preprocessing \"${pattern}\" due to nocache`)\n        } else {\n          await Promise.all(files.map((file) => this._preprocess(file)))\n        }\n\n        this.buckets.set(pattern, files)\n\n        if (_.isEmpty(mg.found)) {\n          log.warn(`Pattern \"${pattern}\" does not match any file.`)\n        } else if (_.isEmpty(files)) {\n          log.warn(`All files matched by \"${pattern}\" were excluded or matched by prior matchers.`)\n        }\n      })\n    )\n      .then(() => {\n        // When we return from this function the file processing chain will be\n        // complete. In the case of two fast refresh() calls, the second call\n        // will overwrite this._refreshing, and we want the status to reflect\n        // the second call and skip the modification event from the first call.\n        if (this._refreshing !== lastCompletedRefresh) {\n          return this._refreshing\n        }\n        this._emitModified(true)\n        return this.files\n      })\n\n    return lastCompletedRefresh\n  }\n\n  get files () {\n    const served = []\n    const included = {}\n    const lookup = {}\n    this._patterns.forEach((p) => {\n      // This needs to be here sadly, as plugins are modifiying\n      // the _patterns directly resulting in elements not being\n      // instantiated properly\n      if (p.constructor.name !== 'Pattern') {\n        p = createPatternObject(p)\n      }\n\n      const files = this._getFilesByPattern(p.pattern)\n      files.sort((a, b) => {\n        if (a.path > b.path) return 1\n        if (a.path < b.path) return -1\n\n        return 0\n      })\n\n      if (p.served) {\n        served.push(...files)\n      }\n\n      files.forEach((file) => {\n        if (lookup[file.path] && lookup[file.path].compare(p) < 0) return\n\n        lookup[file.path] = p\n        if (p.included) {\n          included[file.path] = file\n        } else {\n          delete included[file.path]\n        }\n      })\n    })\n\n    return {\n      served: _.uniq(served, 'path'),\n      included: _.values(included)\n    }\n  }\n\n  refresh () {\n    this._refreshing = this._refresh()\n    return this._refreshing\n  }\n\n  reload (patterns, excludes) {\n    this._patterns = patterns || []\n    this._excludes = excludes || []\n\n    return this.refresh()\n  }\n\n  async addFile (path) {\n    const excluded = this._findExcluded(path)\n    if (excluded) {\n      log.debug(`Add file \"${path}\" ignored. Excluded by \"${excluded}\".`)\n      return this.files\n    }\n\n    const pattern = this._findIncluded(path)\n    if (!pattern) {\n      log.debug(`Add file \"${path}\" ignored. Does not match any pattern.`)\n      return this.files\n    }\n\n    if (this._exists(path)) {\n      log.debug(`Add file \"${path}\" ignored. Already in the list.`)\n      return this.files\n    }\n\n    const file = new File(path)\n    this._getFilesByPattern(pattern.pattern).push(file)\n\n    const [stat] = await Promise.all([statAsync(path), this._refreshing])\n    file.mtime = stat.mtime\n    await this._preprocess(file)\n\n    log.info(`Added file \"${path}\".`)\n    this._emitModified()\n    return this.files\n  }\n\n  async changeFile (path, force) {\n    const pattern = this._findIncluded(path)\n    const file = this._findFile(path, pattern)\n\n    if (!file) {\n      log.debug(`Changed file \"${path}\" ignored. Does not match any file in the list.`)\n      return this.files\n    }\n\n    const [stat] = await Promise.all([statAsync(path), this._refreshing])\n    if (force || stat.mtime > file.mtime) {\n      file.mtime = stat.mtime\n      await this._preprocess(file)\n      log.info(`Changed file \"${path}\".`)\n      this._emitModified(force)\n    }\n    return this.files\n  }\n\n  async removeFile (path) {\n    const pattern = this._findIncluded(path)\n    const file = this._findFile(path, pattern)\n\n    if (file) {\n      helper.arrayRemove(this._getFilesByPattern(pattern.pattern), file)\n      log.info(`Removed file \"${path}\".`)\n\n      this._emitModified()\n    } else {\n      log.debug(`Removed file \"${path}\" ignored. Does not match any file in the list.`)\n    }\n    return this.files\n  }\n}\n\nFileList.factory = function (config, emitter, preprocess) {\n  return new FileList(config.files, config.exclude, emitter, preprocess, config.autoWatchBatchDelay)\n}\n\nFileList.factory.$inject = ['config', 'emitter', 'preprocess']\n\nmodule.exports = FileList\n"]},"metadata":{},"sourceType":"script"}