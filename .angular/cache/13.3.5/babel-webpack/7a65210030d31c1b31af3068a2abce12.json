{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HttpProxyMiddleware = void 0;\n\nconst httpProxy = require(\"http-proxy\");\n\nconst config_factory_1 = require(\"./config-factory\");\n\nconst contextMatcher = require(\"./context-matcher\");\n\nconst handlers = require(\"./_handlers\");\n\nconst logger_1 = require(\"./logger\");\n\nconst PathRewriter = require(\"./path-rewriter\");\n\nconst Router = require(\"./router\");\n\nclass HttpProxyMiddleware {\n  constructor(context, opts) {\n    var _this = this;\n\n    this.logger = (0, logger_1.getInstance)();\n    this.wsInternalSubscribed = false;\n    this.serverOnCloseSubscribed = false; // https://github.com/Microsoft/TypeScript/wiki/'this'-in-TypeScript#red-flags-for-this\n\n    this.middleware = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (req, res, next) {\n        var _a, _b;\n\n        if (_this.shouldProxy(_this.config.context, req)) {\n          try {\n            const activeProxyOptions = yield _this.prepareProxyRequest(req);\n\n            _this.proxy.web(req, res, activeProxyOptions);\n          } catch (err) {\n            next(err);\n          }\n        } else {\n          next();\n        }\n        /**\n         * Get the server object to subscribe to server events;\n         * 'upgrade' for websocket and 'close' for graceful shutdown\n         *\n         * NOTE:\n         * req.socket: node >= 13\n         * req.connection: node < 13 (Remove this when node 12/13 support is dropped)\n         */\n\n\n        const server = (_b = (_a = req.socket) !== null && _a !== void 0 ? _a : req.connection) === null || _b === void 0 ? void 0 : _b.server;\n\n        if (server && !_this.serverOnCloseSubscribed) {\n          server.on('close', () => {\n            _this.logger.info('[HPM] server close signal received: closing proxy server');\n\n            _this.proxy.close();\n          });\n          _this.serverOnCloseSubscribed = true;\n        }\n\n        if (_this.proxyOptions.ws === true) {\n          // use initial request to access the server object to subscribe to http upgrade event\n          _this.catchUpgradeRequest(server);\n        }\n      });\n\n      return function (_x, _x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    this.catchUpgradeRequest = server => {\n      if (!this.wsInternalSubscribed) {\n        server.on('upgrade', this.handleUpgrade); // prevent duplicate upgrade handling;\n        // in case external upgrade is also configured\n\n        this.wsInternalSubscribed = true;\n      }\n    };\n\n    this.handleUpgrade = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (req, socket, head) {\n        if (_this.shouldProxy(_this.config.context, req)) {\n          const activeProxyOptions = yield _this.prepareProxyRequest(req);\n\n          _this.proxy.ws(req, socket, head, activeProxyOptions);\n\n          _this.logger.info('[HPM] Upgrading to WebSocket');\n        }\n      });\n\n      return function (_x4, _x5, _x6) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    /**\n     * Determine whether request should be proxied.\n     *\n     * @private\n     * @param  {String} context [description]\n     * @param  {Object} req     [description]\n     * @return {Boolean}\n     */\n\n\n    this.shouldProxy = (context, req) => {\n      const path = req.originalUrl || req.url;\n      return contextMatcher.match(context, path, req);\n    };\n    /**\n     * Apply option.router and option.pathRewrite\n     * Order matters:\n     *    Router uses original path for routing;\n     *    NOT the modified path, after it has been rewritten by pathRewrite\n     * @param {Object} req\n     * @return {Object} proxy options\n     */\n\n\n    this.prepareProxyRequest = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (req) {\n        // https://github.com/chimurai/http-proxy-middleware/issues/17\n        // https://github.com/chimurai/http-proxy-middleware/issues/94\n        req.url = req.originalUrl || req.url; // store uri before it gets rewritten for logging\n\n        const originalPath = req.url;\n        const newProxyOptions = Object.assign({}, _this.proxyOptions); // Apply in order:\n        // 1. option.router\n        // 2. option.pathRewrite\n\n        yield _this.applyRouter(req, newProxyOptions);\n        yield _this.applyPathRewrite(req, _this.pathRewriter); // debug logging for both http(s) and websockets\n\n        if (_this.proxyOptions.logLevel === 'debug') {\n          const arrow = (0, logger_1.getArrow)(originalPath, req.url, _this.proxyOptions.target, newProxyOptions.target);\n\n          _this.logger.debug('[HPM] %s %s %s %s', req.method, originalPath, arrow, newProxyOptions.target);\n        }\n\n        return newProxyOptions;\n      });\n\n      return function (_x7) {\n        return _ref3.apply(this, arguments);\n      };\n    }(); // Modify option.target when router present.\n\n\n    this.applyRouter = /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator(function* (req, options) {\n        let newTarget;\n\n        if (options.router) {\n          newTarget = yield Router.getTarget(req, options);\n\n          if (newTarget) {\n            _this.logger.debug('[HPM] Router new target: %s -> \"%s\"', options.target, newTarget);\n\n            options.target = newTarget;\n          }\n        }\n      });\n\n      return function (_x8, _x9) {\n        return _ref4.apply(this, arguments);\n      };\n    }(); // rewrite path\n\n\n    this.applyPathRewrite = /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator(function* (req, pathRewriter) {\n        if (pathRewriter) {\n          const path = yield pathRewriter(req.url, req);\n\n          if (typeof path === 'string') {\n            req.url = path;\n          } else {\n            _this.logger.info('[HPM] pathRewrite: No rewritten path found. (%s)', req.url);\n          }\n        }\n      });\n\n      return function (_x10, _x11) {\n        return _ref5.apply(this, arguments);\n      };\n    }();\n\n    this.logError = (err, req, res, target) => {\n      var _a;\n\n      const hostname = ((_a = req.headers) === null || _a === void 0 ? void 0 : _a.host) || req.hostname || req.host; // (websocket) || (node0.10 || node 4/5)\n\n      const requestHref = `${hostname}${req.url}`;\n      const targetHref = `${target === null || target === void 0 ? void 0 : target.href}`; // target is undefined when websocket errors\n\n      const errorMessage = '[HPM] Error occurred while proxying request %s to %s [%s] (%s)';\n      const errReference = 'https://nodejs.org/api/errors.html#errors_common_system_errors'; // link to Node Common Systems Errors page\n\n      this.logger.error(errorMessage, requestHref, targetHref, err.code || err, errReference);\n    };\n\n    this.config = (0, config_factory_1.createConfig)(context, opts);\n    this.proxyOptions = this.config.options; // create proxy\n\n    this.proxy = httpProxy.createProxyServer({});\n    this.logger.info(`[HPM] Proxy created: ${this.config.context}  -> ${this.proxyOptions.target}`);\n    this.pathRewriter = PathRewriter.createPathRewriter(this.proxyOptions.pathRewrite); // returns undefined when \"pathRewrite\" is not provided\n    // attach handler to http-proxy events\n\n    handlers.init(this.proxy, this.proxyOptions); // log errors for debug purpose\n\n    this.proxy.on('error', this.logError); // https://github.com/chimurai/http-proxy-middleware/issues/19\n    // expose function to upgrade externally\n\n    this.middleware.upgrade = (req, socket, head) => {\n      if (!this.wsInternalSubscribed) {\n        this.handleUpgrade(req, socket, head);\n      }\n    };\n  }\n\n}\n\nexports.HttpProxyMiddleware = HttpProxyMiddleware;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/http-proxy-middleware/dist/http-proxy-middleware.js"],"names":["Object","defineProperty","exports","value","HttpProxyMiddleware","httpProxy","require","config_factory_1","contextMatcher","handlers","logger_1","PathRewriter","Router","constructor","context","opts","logger","getInstance","wsInternalSubscribed","serverOnCloseSubscribed","middleware","req","res","next","_a","_b","shouldProxy","config","activeProxyOptions","prepareProxyRequest","proxy","web","err","server","socket","connection","on","info","close","proxyOptions","ws","catchUpgradeRequest","handleUpgrade","head","path","originalUrl","url","match","originalPath","newProxyOptions","assign","applyRouter","applyPathRewrite","pathRewriter","logLevel","arrow","getArrow","target","debug","method","options","newTarget","router","getTarget","logError","hostname","headers","host","requestHref","targetHref","href","errorMessage","errReference","error","code","createConfig","createProxyServer","createPathRewriter","pathRewrite","init","upgrade"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpProxyMiddleware = void 0;\nconst httpProxy = require(\"http-proxy\");\nconst config_factory_1 = require(\"./config-factory\");\nconst contextMatcher = require(\"./context-matcher\");\nconst handlers = require(\"./_handlers\");\nconst logger_1 = require(\"./logger\");\nconst PathRewriter = require(\"./path-rewriter\");\nconst Router = require(\"./router\");\nclass HttpProxyMiddleware {\n    constructor(context, opts) {\n        this.logger = (0, logger_1.getInstance)();\n        this.wsInternalSubscribed = false;\n        this.serverOnCloseSubscribed = false;\n        // https://github.com/Microsoft/TypeScript/wiki/'this'-in-TypeScript#red-flags-for-this\n        this.middleware = async (req, res, next) => {\n            var _a, _b;\n            if (this.shouldProxy(this.config.context, req)) {\n                try {\n                    const activeProxyOptions = await this.prepareProxyRequest(req);\n                    this.proxy.web(req, res, activeProxyOptions);\n                }\n                catch (err) {\n                    next(err);\n                }\n            }\n            else {\n                next();\n            }\n            /**\n             * Get the server object to subscribe to server events;\n             * 'upgrade' for websocket and 'close' for graceful shutdown\n             *\n             * NOTE:\n             * req.socket: node >= 13\n             * req.connection: node < 13 (Remove this when node 12/13 support is dropped)\n             */\n            const server = (_b = ((_a = req.socket) !== null && _a !== void 0 ? _a : req.connection)) === null || _b === void 0 ? void 0 : _b.server;\n            if (server && !this.serverOnCloseSubscribed) {\n                server.on('close', () => {\n                    this.logger.info('[HPM] server close signal received: closing proxy server');\n                    this.proxy.close();\n                });\n                this.serverOnCloseSubscribed = true;\n            }\n            if (this.proxyOptions.ws === true) {\n                // use initial request to access the server object to subscribe to http upgrade event\n                this.catchUpgradeRequest(server);\n            }\n        };\n        this.catchUpgradeRequest = (server) => {\n            if (!this.wsInternalSubscribed) {\n                server.on('upgrade', this.handleUpgrade);\n                // prevent duplicate upgrade handling;\n                // in case external upgrade is also configured\n                this.wsInternalSubscribed = true;\n            }\n        };\n        this.handleUpgrade = async (req, socket, head) => {\n            if (this.shouldProxy(this.config.context, req)) {\n                const activeProxyOptions = await this.prepareProxyRequest(req);\n                this.proxy.ws(req, socket, head, activeProxyOptions);\n                this.logger.info('[HPM] Upgrading to WebSocket');\n            }\n        };\n        /**\n         * Determine whether request should be proxied.\n         *\n         * @private\n         * @param  {String} context [description]\n         * @param  {Object} req     [description]\n         * @return {Boolean}\n         */\n        this.shouldProxy = (context, req) => {\n            const path = req.originalUrl || req.url;\n            return contextMatcher.match(context, path, req);\n        };\n        /**\n         * Apply option.router and option.pathRewrite\n         * Order matters:\n         *    Router uses original path for routing;\n         *    NOT the modified path, after it has been rewritten by pathRewrite\n         * @param {Object} req\n         * @return {Object} proxy options\n         */\n        this.prepareProxyRequest = async (req) => {\n            // https://github.com/chimurai/http-proxy-middleware/issues/17\n            // https://github.com/chimurai/http-proxy-middleware/issues/94\n            req.url = req.originalUrl || req.url;\n            // store uri before it gets rewritten for logging\n            const originalPath = req.url;\n            const newProxyOptions = Object.assign({}, this.proxyOptions);\n            // Apply in order:\n            // 1. option.router\n            // 2. option.pathRewrite\n            await this.applyRouter(req, newProxyOptions);\n            await this.applyPathRewrite(req, this.pathRewriter);\n            // debug logging for both http(s) and websockets\n            if (this.proxyOptions.logLevel === 'debug') {\n                const arrow = (0, logger_1.getArrow)(originalPath, req.url, this.proxyOptions.target, newProxyOptions.target);\n                this.logger.debug('[HPM] %s %s %s %s', req.method, originalPath, arrow, newProxyOptions.target);\n            }\n            return newProxyOptions;\n        };\n        // Modify option.target when router present.\n        this.applyRouter = async (req, options) => {\n            let newTarget;\n            if (options.router) {\n                newTarget = await Router.getTarget(req, options);\n                if (newTarget) {\n                    this.logger.debug('[HPM] Router new target: %s -> \"%s\"', options.target, newTarget);\n                    options.target = newTarget;\n                }\n            }\n        };\n        // rewrite path\n        this.applyPathRewrite = async (req, pathRewriter) => {\n            if (pathRewriter) {\n                const path = await pathRewriter(req.url, req);\n                if (typeof path === 'string') {\n                    req.url = path;\n                }\n                else {\n                    this.logger.info('[HPM] pathRewrite: No rewritten path found. (%s)', req.url);\n                }\n            }\n        };\n        this.logError = (err, req, res, target) => {\n            var _a;\n            const hostname = ((_a = req.headers) === null || _a === void 0 ? void 0 : _a.host) || req.hostname || req.host; // (websocket) || (node0.10 || node 4/5)\n            const requestHref = `${hostname}${req.url}`;\n            const targetHref = `${target === null || target === void 0 ? void 0 : target.href}`; // target is undefined when websocket errors\n            const errorMessage = '[HPM] Error occurred while proxying request %s to %s [%s] (%s)';\n            const errReference = 'https://nodejs.org/api/errors.html#errors_common_system_errors'; // link to Node Common Systems Errors page\n            this.logger.error(errorMessage, requestHref, targetHref, err.code || err, errReference);\n        };\n        this.config = (0, config_factory_1.createConfig)(context, opts);\n        this.proxyOptions = this.config.options;\n        // create proxy\n        this.proxy = httpProxy.createProxyServer({});\n        this.logger.info(`[HPM] Proxy created: ${this.config.context}  -> ${this.proxyOptions.target}`);\n        this.pathRewriter = PathRewriter.createPathRewriter(this.proxyOptions.pathRewrite); // returns undefined when \"pathRewrite\" is not provided\n        // attach handler to http-proxy events\n        handlers.init(this.proxy, this.proxyOptions);\n        // log errors for debug purpose\n        this.proxy.on('error', this.logError);\n        // https://github.com/chimurai/http-proxy-middleware/issues/19\n        // expose function to upgrade externally\n        this.middleware.upgrade = (req, socket, head) => {\n            if (!this.wsInternalSubscribed) {\n                this.handleUpgrade(req, socket, head);\n            }\n        };\n    }\n}\nexports.HttpProxyMiddleware = HttpProxyMiddleware;\n"]},"metadata":{},"sourceType":"script"}