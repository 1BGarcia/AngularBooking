{"ast":null,"code":"const {\n  normalizeReplacer,\n  normalizeSpace,\n  replaceValue,\n  getTypeNative,\n  getTypeAsync,\n  isLeadingSurrogate,\n  isTrailingSurrogate,\n  escapableCharCodeSubstitution,\n  type: {\n    PRIMITIVE,\n    OBJECT,\n    ARRAY,\n    PROMISE,\n    STRING_STREAM,\n    OBJECT_STREAM\n  }\n} = require('./utils');\n\nconst charLength2048 = Array.from({\n  length: 2048\n}).map((_, code) => {\n  if (escapableCharCodeSubstitution.hasOwnProperty(code)) {\n    return 2; // \\X\n  }\n\n  if (code < 0x20) {\n    return 6; // \\uXXXX\n  }\n\n  return code < 128 ? 1 : 2; // UTF8 bytes\n});\n\nfunction stringLength(str) {\n  let len = 0;\n  let prevLeadingSurrogate = false;\n\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n\n    if (code < 2048) {\n      len += charLength2048[code];\n    } else if (isLeadingSurrogate(code)) {\n      len += 6; // \\uXXXX since no pair with trailing surrogate yet\n\n      prevLeadingSurrogate = true;\n      continue;\n    } else if (isTrailingSurrogate(code)) {\n      len = prevLeadingSurrogate ? len - 2 // surrogate pair (4 bytes), since we calculate prev leading surrogate as 6 bytes, substruct 2 bytes\n      : len + 6; // \\uXXXX\n    } else {\n      len += 3; // code >= 2048 is 3 bytes length for UTF8\n    }\n\n    prevLeadingSurrogate = false;\n  }\n\n  return len + 2; // +2 for quotes\n}\n\nfunction primitiveLength(value) {\n  switch (typeof value) {\n    case 'string':\n      return stringLength(value);\n\n    case 'number':\n      return Number.isFinite(value) ? String(value).length : 4\n      /* null */\n      ;\n\n    case 'boolean':\n      return value ? 4\n      /* true */\n      : 5\n      /* false */\n      ;\n\n    case 'undefined':\n    case 'object':\n      return 4;\n\n    /* null */\n\n    default:\n      return 0;\n  }\n}\n\nfunction spaceLength(space) {\n  space = normalizeSpace(space);\n  return typeof space === 'string' ? space.length : 0;\n}\n\nmodule.exports = function jsonStringifyInfo(value, replacer, space, options) {\n  function walk(holder, key, value) {\n    if (stop) {\n      return;\n    }\n\n    value = replaceValue(holder, key, value, replacer);\n    let type = getType(value); // check for circular structure\n\n    if (type !== PRIMITIVE && stack.has(value)) {\n      circular.add(value);\n      length += 4; // treat as null\n\n      if (!options.continueOnCircular) {\n        stop = true;\n      }\n\n      return;\n    }\n\n    switch (type) {\n      case PRIMITIVE:\n        if (value !== undefined || Array.isArray(holder)) {\n          length += primitiveLength(value);\n        } else if (holder === root) {\n          length += 9; // FIXME: that's the length of undefined, should we normalize behaviour to convert it to null?\n        }\n\n        break;\n\n      case OBJECT:\n        {\n          if (visited.has(value)) {\n            duplicate.add(value);\n            length += visited.get(value);\n            break;\n          }\n\n          const valueLength = length;\n          let entries = 0;\n          length += 2; // {}\n\n          stack.add(value);\n\n          for (const key in value) {\n            if (hasOwnProperty.call(value, key) && (allowlist === null || allowlist.has(key))) {\n              const prevLength = length;\n              walk(value, key, value[key]);\n\n              if (prevLength !== length) {\n                // value is printed\n                length += stringLength(key) + 1; // \"key\":\n\n                entries++;\n              }\n            }\n          }\n\n          if (entries > 1) {\n            length += entries - 1; // commas\n          }\n\n          stack.delete(value);\n\n          if (space > 0 && entries > 0) {\n            length += (1 + (stack.size + 1) * space + 1) * entries; // for each key-value: \\n{space}\n\n            length += 1 + stack.size * space; // for }\n          }\n\n          visited.set(value, length - valueLength);\n          break;\n        }\n\n      case ARRAY:\n        {\n          if (visited.has(value)) {\n            duplicate.add(value);\n            length += visited.get(value);\n            break;\n          }\n\n          const valueLength = length;\n          length += 2; // []\n\n          stack.add(value);\n\n          for (let i = 0; i < value.length; i++) {\n            walk(value, i, value[i]);\n          }\n\n          if (value.length > 1) {\n            length += value.length - 1; // commas\n          }\n\n          stack.delete(value);\n\n          if (space > 0 && value.length > 0) {\n            length += (1 + (stack.size + 1) * space) * value.length; // for each element: \\n{space}\n\n            length += 1 + stack.size * space; // for ]\n          }\n\n          visited.set(value, length - valueLength);\n          break;\n        }\n\n      case PROMISE:\n      case STRING_STREAM:\n        async.add(value);\n        break;\n\n      case OBJECT_STREAM:\n        length += 2; // []\n\n        async.add(value);\n        break;\n    }\n  }\n\n  let allowlist = null;\n  replacer = normalizeReplacer(replacer);\n\n  if (Array.isArray(replacer)) {\n    allowlist = new Set(replacer);\n    replacer = null;\n  }\n\n  space = spaceLength(space);\n  options = options || {};\n  const visited = new Map();\n  const stack = new Set();\n  const duplicate = new Set();\n  const circular = new Set();\n  const async = new Set();\n  const getType = options.async ? getTypeAsync : getTypeNative;\n  const root = {\n    '': value\n  };\n  let stop = false;\n  let length = 0;\n  walk(root, '', value);\n  return {\n    minLength: isNaN(length) ? Infinity : length,\n    circular: [...circular],\n    duplicate: [...duplicate],\n    async: [...async]\n  };\n};","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/@discoveryjs/json-ext/src/stringify-info.js"],"names":["normalizeReplacer","normalizeSpace","replaceValue","getTypeNative","getTypeAsync","isLeadingSurrogate","isTrailingSurrogate","escapableCharCodeSubstitution","type","PRIMITIVE","OBJECT","ARRAY","PROMISE","STRING_STREAM","OBJECT_STREAM","require","charLength2048","Array","from","length","map","_","code","hasOwnProperty","stringLength","str","len","prevLeadingSurrogate","i","charCodeAt","primitiveLength","value","Number","isFinite","String","spaceLength","space","module","exports","jsonStringifyInfo","replacer","options","walk","holder","key","stop","getType","stack","has","circular","add","continueOnCircular","undefined","isArray","root","visited","duplicate","get","valueLength","entries","call","allowlist","prevLength","delete","size","set","async","Set","Map","minLength","isNaN","Infinity"],"mappings":"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","sourcesContent":["const {\n    normalizeReplacer,\n    normalizeSpace,\n    replaceValue,\n    getTypeNative,\n    getTypeAsync,\n    isLeadingSurrogate,\n    isTrailingSurrogate,\n    escapableCharCodeSubstitution,\n    type: {\n        PRIMITIVE,\n        OBJECT,\n        ARRAY,\n        PROMISE,\n        STRING_STREAM,\n        OBJECT_STREAM\n    }\n} = require('./utils');\nconst charLength2048 = Array.from({ length: 2048 }).map((_, code) => {\n    if (escapableCharCodeSubstitution.hasOwnProperty(code)) {\n        return 2; // \\X\n    }\n\n    if (code < 0x20) {\n        return 6; // \\uXXXX\n    }\n\n    return code < 128 ? 1 : 2; // UTF8 bytes\n});\n\nfunction stringLength(str) {\n    let len = 0;\n    let prevLeadingSurrogate = false;\n\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n\n        if (code < 2048) {\n            len += charLength2048[code];\n        } else if (isLeadingSurrogate(code)) {\n            len += 6; // \\uXXXX since no pair with trailing surrogate yet\n            prevLeadingSurrogate = true;\n            continue;\n        } else if (isTrailingSurrogate(code)) {\n            len = prevLeadingSurrogate\n                ? len - 2  // surrogate pair (4 bytes), since we calculate prev leading surrogate as 6 bytes, substruct 2 bytes\n                : len + 6; // \\uXXXX\n        } else {\n            len += 3; // code >= 2048 is 3 bytes length for UTF8\n        }\n\n        prevLeadingSurrogate = false;\n    }\n\n    return len + 2; // +2 for quotes\n}\n\nfunction primitiveLength(value) {\n    switch (typeof value) {\n        case 'string':\n            return stringLength(value);\n\n        case 'number':\n            return Number.isFinite(value) ? String(value).length : 4 /* null */;\n\n        case 'boolean':\n            return value ? 4 /* true */ : 5 /* false */;\n\n        case 'undefined':\n        case 'object':\n            return 4; /* null */\n\n        default:\n            return 0;\n    }\n}\n\nfunction spaceLength(space) {\n    space = normalizeSpace(space);\n    return typeof space === 'string' ? space.length : 0;\n}\n\nmodule.exports = function jsonStringifyInfo(value, replacer, space, options) {\n    function walk(holder, key, value) {\n        if (stop) {\n            return;\n        }\n\n        value = replaceValue(holder, key, value, replacer);\n\n        let type = getType(value);\n\n        // check for circular structure\n        if (type !== PRIMITIVE && stack.has(value)) {\n            circular.add(value);\n            length += 4; // treat as null\n\n            if (!options.continueOnCircular) {\n                stop = true;\n            }\n\n            return;\n        }\n\n        switch (type) {\n            case PRIMITIVE:\n                if (value !== undefined || Array.isArray(holder)) {\n                    length += primitiveLength(value);\n                } else if (holder === root) {\n                    length += 9; // FIXME: that's the length of undefined, should we normalize behaviour to convert it to null?\n                }\n                break;\n\n            case OBJECT: {\n                if (visited.has(value)) {\n                    duplicate.add(value);\n                    length += visited.get(value);\n                    break;\n                }\n\n                const valueLength = length;\n                let entries = 0;\n\n                length += 2; // {}\n\n                stack.add(value);\n\n                for (const key in value) {\n                    if (hasOwnProperty.call(value, key) && (allowlist === null || allowlist.has(key))) {\n                        const prevLength = length;\n                        walk(value, key, value[key]);\n\n                        if (prevLength !== length) {\n                            // value is printed\n                            length += stringLength(key) + 1; // \"key\":\n                            entries++;\n                        }\n                    }\n                }\n\n                if (entries > 1) {\n                    length += entries - 1; // commas\n                }\n\n                stack.delete(value);\n\n                if (space > 0 && entries > 0) {\n                    length += (1 + (stack.size + 1) * space + 1) * entries; // for each key-value: \\n{space}\n                    length += 1 + stack.size * space; // for }\n                }\n\n                visited.set(value, length - valueLength);\n\n                break;\n            }\n\n            case ARRAY: {\n                if (visited.has(value)) {\n                    duplicate.add(value);\n                    length += visited.get(value);\n                    break;\n                }\n\n                const valueLength = length;\n\n                length += 2; // []\n\n                stack.add(value);\n\n                for (let i = 0; i < value.length; i++) {\n                    walk(value, i, value[i]);\n                }\n\n                if (value.length > 1) {\n                    length += value.length - 1; // commas\n                }\n\n                stack.delete(value);\n\n                if (space > 0 && value.length > 0) {\n                    length += (1 + (stack.size + 1) * space) * value.length; // for each element: \\n{space}\n                    length += 1 + stack.size * space; // for ]\n                }\n\n                visited.set(value, length - valueLength);\n\n                break;\n            }\n\n            case PROMISE:\n            case STRING_STREAM:\n                async.add(value);\n                break;\n\n            case OBJECT_STREAM:\n                length += 2; // []\n                async.add(value);\n                break;\n        }\n    }\n\n    let allowlist = null;\n    replacer = normalizeReplacer(replacer);\n\n    if (Array.isArray(replacer)) {\n        allowlist = new Set(replacer);\n        replacer = null;\n    }\n\n    space = spaceLength(space);\n    options = options || {};\n\n    const visited = new Map();\n    const stack = new Set();\n    const duplicate = new Set();\n    const circular = new Set();\n    const async = new Set();\n    const getType = options.async ? getTypeAsync : getTypeNative;\n    const root = { '': value };\n    let stop = false;\n    let length = 0;\n\n    walk(root, '', value);\n\n    return {\n        minLength: isNaN(length) ? Infinity : length,\n        circular: [...circular],\n        duplicate: [...duplicate],\n        async: [...async]\n    };\n};\n"]},"metadata":{},"sourceType":"script"}