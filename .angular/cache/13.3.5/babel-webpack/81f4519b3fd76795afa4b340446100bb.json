{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scheduleByTarget = exports.scheduleByName = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst api_1 = require(\"./api\");\n\nconst progressSchema = require('./progress-schema.json');\n\nlet _uniqueId = 0;\n\nfunction scheduleByName(_x, _x2, _x3) {\n  return _scheduleByName.apply(this, arguments);\n}\n\nfunction _scheduleByName() {\n  _scheduleByName = _asyncToGenerator(function* (name, buildOptions, options) {\n    const childLoggerName = options.target ? `{${(0, api_1.targetStringFromTarget)(options.target)}}` : name;\n    const logger = options.logger.createChild(childLoggerName);\n    const job = options.scheduler.schedule(name, {});\n    let stateSubscription;\n    const workspaceRoot = yield options.workspaceRoot;\n    const currentDirectory = yield options.currentDirectory;\n    const description = yield job.description.toPromise();\n    const info = description.info;\n    const id = ++_uniqueId;\n    const message = {\n      id,\n      currentDirectory,\n      workspaceRoot,\n      info: info,\n      options: buildOptions,\n      ...(options.target ? {\n        target: options.target\n      } : {})\n    }; // Wait for the job to be ready.\n\n    if (job.state !== core_1.experimental.jobs.JobState.Started) {\n      stateSubscription = job.outboundBus.subscribe(event => {\n        if (event.kind === core_1.experimental.jobs.JobOutboundMessageKind.Start) {\n          job.input.next(message);\n        }\n      }, () => {});\n    } else {\n      job.input.next(message);\n    }\n\n    const logChannelSub = job.getChannel('log').subscribe(entry => {\n      logger.next(entry);\n    }, () => {});\n    const s = job.outboundBus.subscribe({\n      error() {},\n\n      complete() {\n        s.unsubscribe();\n        logChannelSub.unsubscribe();\n\n        if (stateSubscription) {\n          stateSubscription.unsubscribe();\n        }\n      }\n\n    });\n    const output = job.output.pipe((0, operators_1.map)(output => ({ ...output,\n      ...(options.target ? {\n        target: options.target\n      } : 0),\n      info\n    })), (0, operators_1.shareReplay)()); // If there's an analytics object, take the job channel and report it to the analytics.\n\n    if (options.analytics) {\n      const reporter = new core_1.analytics.AnalyticsReporter(options.analytics);\n      job.getChannel('analytics').subscribe(report => reporter.report(report));\n    } // Start the builder.\n\n\n    output.pipe((0, operators_1.first)()).subscribe({\n      error() {}\n\n    });\n    return {\n      id,\n      info,\n\n      // This is a getter so that it always returns the next output, and not the same one.\n      get result() {\n        return output.pipe((0, operators_1.first)()).toPromise();\n      },\n\n      output,\n      progress: job.getChannel('progress', progressSchema).pipe((0, operators_1.shareReplay)(1)),\n\n      stop() {\n        job.stop();\n        return job.outboundBus.pipe((0, operators_1.ignoreElements)(), (0, operators_1.catchError)(() => rxjs_1.EMPTY)).toPromise();\n      }\n\n    };\n  });\n  return _scheduleByName.apply(this, arguments);\n}\n\nexports.scheduleByName = scheduleByName;\n\nfunction scheduleByTarget(_x4, _x5, _x6) {\n  return _scheduleByTarget.apply(this, arguments);\n}\n\nfunction _scheduleByTarget() {\n  _scheduleByTarget = _asyncToGenerator(function* (target, overrides, options) {\n    return scheduleByName(`{${(0, api_1.targetStringFromTarget)(target)}}`, overrides, { ...options,\n      target,\n      logger: options.logger\n    });\n  });\n  return _scheduleByTarget.apply(this, arguments);\n}\n\nexports.scheduleByTarget = scheduleByTarget;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/@angular-devkit/architect/src/schedule-by-name.js"],"names":["Object","defineProperty","exports","value","scheduleByTarget","scheduleByName","core_1","require","rxjs_1","operators_1","api_1","progressSchema","_uniqueId","name","buildOptions","options","childLoggerName","target","targetStringFromTarget","logger","createChild","job","scheduler","schedule","stateSubscription","workspaceRoot","currentDirectory","description","toPromise","info","id","message","state","experimental","jobs","JobState","Started","outboundBus","subscribe","event","kind","JobOutboundMessageKind","Start","input","next","logChannelSub","getChannel","entry","s","error","complete","unsubscribe","output","pipe","map","shareReplay","analytics","reporter","AnalyticsReporter","report","first","result","progress","stop","ignoreElements","catchError","EMPTY","overrides"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scheduleByTarget = exports.scheduleByName = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst api_1 = require(\"./api\");\nconst progressSchema = require('./progress-schema.json');\nlet _uniqueId = 0;\nasync function scheduleByName(name, buildOptions, options) {\n    const childLoggerName = options.target ? `{${(0, api_1.targetStringFromTarget)(options.target)}}` : name;\n    const logger = options.logger.createChild(childLoggerName);\n    const job = options.scheduler.schedule(name, {});\n    let stateSubscription;\n    const workspaceRoot = await options.workspaceRoot;\n    const currentDirectory = await options.currentDirectory;\n    const description = await job.description.toPromise();\n    const info = description.info;\n    const id = ++_uniqueId;\n    const message = {\n        id,\n        currentDirectory,\n        workspaceRoot,\n        info: info,\n        options: buildOptions,\n        ...(options.target ? { target: options.target } : {}),\n    };\n    // Wait for the job to be ready.\n    if (job.state !== core_1.experimental.jobs.JobState.Started) {\n        stateSubscription = job.outboundBus.subscribe((event) => {\n            if (event.kind === core_1.experimental.jobs.JobOutboundMessageKind.Start) {\n                job.input.next(message);\n            }\n        }, () => { });\n    }\n    else {\n        job.input.next(message);\n    }\n    const logChannelSub = job.getChannel('log').subscribe((entry) => {\n        logger.next(entry);\n    }, () => { });\n    const s = job.outboundBus.subscribe({\n        error() { },\n        complete() {\n            s.unsubscribe();\n            logChannelSub.unsubscribe();\n            if (stateSubscription) {\n                stateSubscription.unsubscribe();\n            }\n        },\n    });\n    const output = job.output.pipe((0, operators_1.map)((output) => ({\n        ...output,\n        ...(options.target ? { target: options.target } : 0),\n        info,\n    })), (0, operators_1.shareReplay)());\n    // If there's an analytics object, take the job channel and report it to the analytics.\n    if (options.analytics) {\n        const reporter = new core_1.analytics.AnalyticsReporter(options.analytics);\n        job\n            .getChannel('analytics')\n            .subscribe((report) => reporter.report(report));\n    }\n    // Start the builder.\n    output.pipe((0, operators_1.first)()).subscribe({\n        error() { },\n    });\n    return {\n        id,\n        info,\n        // This is a getter so that it always returns the next output, and not the same one.\n        get result() {\n            return output.pipe((0, operators_1.first)()).toPromise();\n        },\n        output,\n        progress: job\n            .getChannel('progress', progressSchema)\n            .pipe((0, operators_1.shareReplay)(1)),\n        stop() {\n            job.stop();\n            return job.outboundBus\n                .pipe((0, operators_1.ignoreElements)(), (0, operators_1.catchError)(() => rxjs_1.EMPTY))\n                .toPromise();\n        },\n    };\n}\nexports.scheduleByName = scheduleByName;\nasync function scheduleByTarget(target, overrides, options) {\n    return scheduleByName(`{${(0, api_1.targetStringFromTarget)(target)}}`, overrides, {\n        ...options,\n        target,\n        logger: options.logger,\n    });\n}\nexports.scheduleByTarget = scheduleByTarget;\n"]},"metadata":{},"sourceType":"script"}