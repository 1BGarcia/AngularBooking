{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nconst path = require(\"path\");\n\nconst {\n  validate\n} = require(\"schema-utils\");\n\nconst serialize = require(\"serialize-javascript\");\n\nconst normalizePath = require(\"normalize-path\");\n\nconst globParent = require(\"glob-parent\");\n\nconst fastGlob = require(\"fast-glob\"); // @ts-ignore\n\n\nconst {\n  version\n} = require(\"../package.json\");\n\nconst schema = require(\"./options.json\");\n\nconst {\n  readFile,\n  stat,\n  throttleAll\n} = require(\"./utils\");\n\nconst template = /\\[\\\\*([\\w:]+)\\\\*\\]/i;\n/** @typedef {import(\"schema-utils/declarations/validate\").Schema} Schema */\n\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n\n/** @typedef {import(\"webpack\").Compilation} Compilation */\n\n/** @typedef {import(\"webpack\").WebpackError} WebpackError */\n\n/** @typedef {import(\"webpack\").Asset} Asset */\n\n/** @typedef {import(\"globby\").Options} GlobbyOptions */\n\n/** @typedef {import(\"globby\").GlobEntry} GlobEntry */\n\n/** @typedef {ReturnType<Compilation[\"getLogger\"]>} WebpackLogger */\n\n/** @typedef {ReturnType<Compilation[\"getCache\"]>} CacheFacade */\n\n/** @typedef {ReturnType<ReturnType<Compilation[\"getCache\"]>[\"getLazyHashedEtag\"]>} Etag */\n\n/** @typedef {ReturnType<Compilation[\"fileSystemInfo\"][\"mergeSnapshots\"]>} Snapshot */\n\n/**\n * @typedef {boolean} Force\n */\n\n/**\n * @typedef {Object} CopiedResult\n * @property {string} sourceFilename\n * @property {string} absoluteFilename\n * @property {string} filename\n * @property {Asset[\"source\"]} source\n * @property {Force | undefined} force\n * @property {{ [key: string]: string }} info\n */\n\n/**\n * @typedef {string} StringPattern\n */\n\n/**\n * @typedef {boolean} NoErrorOnMissing\n */\n\n/**\n * @typedef {string} Context\n */\n\n/**\n * @typedef {string} From\n */\n\n/**\n * @callback ToFunction\n * @param {{ context: string, absoluteFilename?: string }} pathData\n * @return {string}\n */\n\n/**\n * @typedef {string | ToFunction} To\n */\n\n/**\n * @typedef {\"dir\" | \"file\" | \"template\"} ToType\n */\n\n/**\n * @callback TransformerFunction\n * @param {Buffer} input\n * @param {string} absoluteFilename\n * @returns {string | Buffer}\n */\n\n/**\n * @typedef {{ keys: { [key: string]: any } } | { keys: ((defaultCacheKeys: { [key: string]: any }, absoluteFilename: string) => Promise<{ [key: string]: any }>) }} TransformerCacheObject\n */\n\n/**\n * @typedef {Object} TransformerObject\n * @property {TransformerFunction} transformer\n * @property {boolean | TransformerCacheObject} [cache]\n */\n\n/**\n * @typedef {TransformerFunction | TransformerObject} Transform\n */\n\n/**\n * @callback Filter\n * @param {string} filepath\n * @returns {boolean}\n */\n\n/**\n * @callback TransformAllFunction\n * @param {{ data: Buffer, sourceFilename: string, absoluteFilename: string }[]} data\n * @returns {string | Buffer}\n */\n\n/**\n * @typedef { { [key: string]: string } | ((item: { absoluteFilename: string, sourceFilename: string, filename: string, toType: ToType }) => { [key: string]: string }) } Info\n */\n\n/**\n * @typedef {Object} ObjectPattern\n * @property {From} from\n * @property {GlobbyOptions} [globOptions]\n * @property {Context} [context]\n * @property {To} [to]\n * @property {ToType} [toType]\n * @property {Info} [info]\n * @property {Filter} [filter]\n * @property {Transform} [transform]\n * @property {TransformAllFunction} [transformAll]\n * @property {Force} [force]\n * @property {number} [priority]\n * @property {NoErrorOnMissing} [noErrorOnMissing]\n */\n\n/**\n * @typedef {StringPattern | ObjectPattern} Pattern\n */\n\n/**\n * @typedef {Object} AdditionalOptions\n * @property {number} [concurrency]\n */\n\n/**\n * @typedef {Object} PluginOptions\n * @property {Pattern[]} patterns\n * @property {AdditionalOptions} [options]\n */\n\nclass CopyPlugin {\n  /**\n   * @param {PluginOptions} [options]\n   */\n  constructor(options = {\n    patterns: []\n  }) {\n    validate(\n    /** @type {Schema} */\n    schema, options, {\n      name: \"Copy Plugin\",\n      baseDataPath: \"options\"\n    });\n    /**\n     * @private\n     * @type {Pattern[]}\n     */\n\n    this.patterns = options.patterns;\n    /**\n     * @private\n     * @type {AdditionalOptions}\n     */\n\n    this.options = options.options || {};\n  }\n  /**\n   * @private\n   * @param {Compilation} compilation\n   * @param {number} startTime\n   * @param {string} dependency\n   * @returns {Promise<Snapshot | undefined>}\n   */\n\n\n  static createSnapshot(compilation, startTime, dependency) {\n    return _asyncToGenerator(function* () {\n      // eslint-disable-next-line consistent-return\n      return new Promise((resolve, reject) => {\n        compilation.fileSystemInfo.createSnapshot(startTime, [dependency], // @ts-ignore\n        // eslint-disable-next-line no-undefined\n        undefined, // eslint-disable-next-line no-undefined\n        undefined, null, (error, snapshot) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          resolve(snapshot);\n        });\n      });\n    })();\n  }\n  /**\n   * @private\n   * @param {Compilation} compilation\n   * @param {Snapshot} snapshot\n   * @returns {Promise<boolean | undefined>}\n   */\n\n\n  static checkSnapshotValid(compilation, snapshot) {\n    return _asyncToGenerator(function* () {\n      // eslint-disable-next-line consistent-return\n      return new Promise((resolve, reject) => {\n        compilation.fileSystemInfo.checkSnapshotValid(snapshot, (error, isValid) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          resolve(isValid);\n        });\n      });\n    })();\n  }\n  /**\n   * @private\n   * @param {Compiler} compiler\n   * @param {Compilation} compilation\n   * @param {Buffer} source\n   * @returns {string}\n   */\n\n\n  static getContentHash(compiler, compilation, source) {\n    const {\n      outputOptions\n    } = compilation;\n    const {\n      hashDigest,\n      hashDigestLength,\n      hashFunction,\n      hashSalt\n    } = outputOptions;\n    const hash = compiler.webpack.util.createHash(\n    /** @type {string} */\n    hashFunction);\n\n    if (hashSalt) {\n      hash.update(hashSalt);\n    }\n\n    hash.update(source);\n    const fullContentHash = hash.digest(hashDigest);\n    return fullContentHash.toString().slice(0, hashDigestLength);\n  }\n  /**\n   * @private\n   * @param {typeof import(\"globby\").globby} globby\n   * @param {Compiler} compiler\n   * @param {Compilation} compilation\n   * @param {WebpackLogger} logger\n   * @param {CacheFacade} cache\n   * @param {ObjectPattern & { context: string }} inputPattern\n   * @param {number} index\n   * @returns {Promise<Array<CopiedResult | undefined> | undefined>}\n   */\n\n\n  static runPattern(globby, compiler, compilation, logger, cache, inputPattern, index) {\n    return _asyncToGenerator(function* () {\n      const {\n        RawSource\n      } = compiler.webpack.sources;\n      const pattern = { ...inputPattern\n      };\n      const originalFrom = pattern.from;\n      const normalizedOriginalFrom = path.normalize(originalFrom);\n      logger.log(`starting to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context`);\n      let absoluteFrom;\n\n      if (path.isAbsolute(normalizedOriginalFrom)) {\n        absoluteFrom = normalizedOriginalFrom;\n      } else {\n        absoluteFrom = path.resolve(pattern.context, normalizedOriginalFrom);\n      }\n\n      logger.debug(`getting stats for '${absoluteFrom}'...`);\n      const {\n        inputFileSystem\n      } = compiler;\n      let stats;\n\n      try {\n        stats = yield stat(inputFileSystem, absoluteFrom);\n      } catch (error) {// Nothing\n      }\n      /**\n       * @type {\"file\" | \"dir\" | \"glob\"}\n       */\n\n\n      let fromType;\n\n      if (stats) {\n        if (stats.isDirectory()) {\n          fromType = \"dir\";\n          logger.debug(`determined '${absoluteFrom}' is a directory`);\n        } else if (stats.isFile()) {\n          fromType = \"file\";\n          logger.debug(`determined '${absoluteFrom}' is a file`);\n        } else {\n          // Fallback\n          fromType = \"glob\";\n          logger.debug(`determined '${absoluteFrom}' is unknown`);\n        }\n      } else {\n        fromType = \"glob\";\n        logger.debug(`determined '${absoluteFrom}' is a glob`);\n      }\n      /** @type {GlobbyOptions & { objectMode: true }} */\n\n\n      const globOptions = { ...{\n          followSymbolicLinks: true\n        },\n        ...(pattern.globOptions || {}),\n        ...{\n          cwd: pattern.context,\n          objectMode: true\n        }\n      }; // @ts-ignore\n\n      globOptions.fs = inputFileSystem;\n      let glob;\n\n      switch (fromType) {\n        case \"dir\":\n          compilation.contextDependencies.add(absoluteFrom);\n          logger.debug(`added '${absoluteFrom}' as a context dependency`);\n          pattern.context = absoluteFrom;\n          glob = path.posix.join(fastGlob.escapePath(normalizePath(path.resolve(absoluteFrom))), \"**/*\");\n          absoluteFrom = path.join(absoluteFrom, \"**/*\");\n\n          if (typeof globOptions.dot === \"undefined\") {\n            globOptions.dot = true;\n          }\n\n          break;\n\n        case \"file\":\n          compilation.fileDependencies.add(absoluteFrom);\n          logger.debug(`added '${absoluteFrom}' as a file dependency`);\n          pattern.context = path.dirname(absoluteFrom);\n          glob = fastGlob.escapePath(normalizePath(path.resolve(absoluteFrom)));\n\n          if (typeof globOptions.dot === \"undefined\") {\n            globOptions.dot = true;\n          }\n\n          break;\n\n        case \"glob\":\n        default:\n          {\n            const contextDependencies = path.normalize(globParent(absoluteFrom));\n            compilation.contextDependencies.add(contextDependencies);\n            logger.debug(`added '${contextDependencies}' as a context dependency`);\n            glob = path.isAbsolute(originalFrom) ? originalFrom : path.posix.join(fastGlob.escapePath(normalizePath(path.resolve(pattern.context))), originalFrom);\n          }\n      }\n\n      logger.log(`begin globbing '${glob}'...`);\n      /**\n       * @type {GlobEntry[]}\n       */\n\n      let globEntries;\n\n      try {\n        globEntries = yield globby(glob, globOptions);\n      } catch (error) {\n        compilation.errors.push(\n        /** @type {WebpackError} */\n        error);\n        return;\n      }\n\n      if (globEntries.length === 0) {\n        if (pattern.noErrorOnMissing) {\n          logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context to '${pattern.to}'`);\n          return;\n        }\n\n        const missingError = new Error(`unable to locate '${glob}' glob`);\n        compilation.errors.push(\n        /** @type {WebpackError} */\n        missingError);\n        return;\n      }\n      /**\n       * @type {Array<CopiedResult | undefined>}\n       */\n\n\n      let copiedResult;\n\n      try {\n        copiedResult = yield Promise.all(globEntries.map(\n        /*#__PURE__*/\n\n        /**\n         * @param {GlobEntry} globEntry\n         * @returns {Promise<CopiedResult | undefined>}\n         */\n        function () {\n          var _ref = _asyncToGenerator(function* (globEntry) {\n            // Exclude directories\n            if (!globEntry.dirent.isFile()) {\n              return;\n            }\n\n            if (pattern.filter) {\n              let isFiltered;\n\n              try {\n                isFiltered = yield pattern.filter(globEntry.path);\n              } catch (error) {\n                compilation.errors.push(\n                /** @type {WebpackError} */\n                error);\n                return;\n              }\n\n              if (!isFiltered) {\n                logger.log(`skip '${globEntry.path}', because it was filtered`);\n                return;\n              }\n            }\n\n            const from = globEntry.path;\n            logger.debug(`found '${from}'`); // `globby`/`fast-glob` return the relative path when the path contains special characters on windows\n\n            const absoluteFilename = path.resolve(pattern.context, from);\n            const to = typeof pattern.to === \"function\" ? yield pattern.to({\n              context: pattern.context,\n              absoluteFilename\n            }) : path.normalize(typeof pattern.to !== \"undefined\" ? pattern.to : \"\");\n            const toType = pattern.toType ? pattern.toType : template.test(to) ? \"template\" : path.extname(to) === \"\" || to.slice(-1) === path.sep ? \"dir\" : \"file\";\n            logger.log(`'to' option '${to}' determinated as '${toType}'`);\n            const relativeFrom = path.relative(pattern.context, absoluteFilename);\n            let filename = toType === \"dir\" ? path.join(to, relativeFrom) : to;\n\n            if (path.isAbsolute(filename)) {\n              filename = path.relative(\n              /** @type {string} */\n              compiler.options.output.path, filename);\n            }\n\n            logger.log(`determined that '${from}' should write to '${filename}'`);\n            const sourceFilename = normalizePath(path.relative(compiler.context, absoluteFilename)); // If this came from a glob or dir, add it to the file dependencies\n\n            if (fromType === \"dir\" || fromType === \"glob\") {\n              compilation.fileDependencies.add(absoluteFilename);\n              logger.debug(`added '${absoluteFilename}' as a file dependency`);\n            }\n\n            let cacheEntry;\n            logger.debug(`getting cache for '${absoluteFilename}'...`);\n\n            try {\n              cacheEntry = yield cache.getPromise(`${sourceFilename}|${index}`, null);\n            } catch (error) {\n              compilation.errors.push(\n              /** @type {WebpackError} */\n              error);\n              return;\n            }\n            /**\n             * @type {Asset[\"source\"] | undefined}\n             */\n\n\n            let source;\n\n            if (cacheEntry) {\n              logger.debug(`found cache for '${absoluteFilename}'...`);\n              let isValidSnapshot;\n              logger.debug(`checking snapshot on valid for '${absoluteFilename}'...`);\n\n              try {\n                isValidSnapshot = yield CopyPlugin.checkSnapshotValid(compilation, cacheEntry.snapshot);\n              } catch (error) {\n                compilation.errors.push(\n                /** @type {WebpackError} */\n                error);\n                return;\n              }\n\n              if (isValidSnapshot) {\n                logger.debug(`snapshot for '${absoluteFilename}' is valid`);\n                ({\n                  source\n                } = cacheEntry);\n              } else {\n                logger.debug(`snapshot for '${absoluteFilename}' is invalid`);\n              }\n            } else {\n              logger.debug(`missed cache for '${absoluteFilename}'`);\n            }\n\n            if (!source) {\n              const startTime = Date.now();\n              logger.debug(`reading '${absoluteFilename}'...`);\n              let data;\n\n              try {\n                data = yield readFile(inputFileSystem, absoluteFilename);\n              } catch (error) {\n                compilation.errors.push(\n                /** @type {WebpackError} */\n                error);\n                return;\n              }\n\n              logger.debug(`read '${absoluteFilename}'`);\n              source = new RawSource(data);\n              let snapshot;\n              logger.debug(`creating snapshot for '${absoluteFilename}'...`);\n\n              try {\n                snapshot = yield CopyPlugin.createSnapshot(compilation, startTime, absoluteFilename);\n              } catch (error) {\n                compilation.errors.push(\n                /** @type {WebpackError} */\n                error);\n                return;\n              }\n\n              if (snapshot) {\n                logger.debug(`created snapshot for '${absoluteFilename}'`);\n                logger.debug(`storing cache for '${absoluteFilename}'...`);\n\n                try {\n                  yield cache.storePromise(`${sourceFilename}|${index}`, null, {\n                    source,\n                    snapshot\n                  });\n                } catch (error) {\n                  compilation.errors.push(\n                  /** @type {WebpackError} */\n                  error);\n                  return;\n                }\n\n                logger.debug(`stored cache for '${absoluteFilename}'`);\n              }\n            }\n\n            if (pattern.transform) {\n              /**\n               * @type {TransformerObject}\n               */\n              const transformObj = typeof pattern.transform === \"function\" ? {\n                transformer: pattern.transform\n              } : pattern.transform;\n\n              if (transformObj.transformer) {\n                logger.log(`transforming content for '${absoluteFilename}'...`);\n                const buffer = source.buffer();\n\n                if (transformObj.cache) {\n                  // TODO: remove in the next major release\n                  const hasher = compiler.webpack && compiler.webpack.util && compiler.webpack.util.createHash ? compiler.webpack.util.createHash(\"xxhash64\") : // eslint-disable-next-line global-require\n                  require(\"crypto\").createHash(\"md4\");\n                  const defaultCacheKeys = {\n                    version,\n                    sourceFilename,\n                    transform: transformObj.transformer,\n                    contentHash: hasher.update(buffer).digest(\"hex\"),\n                    index\n                  };\n                  const cacheKeys = `transform|${serialize(typeof transformObj.cache === \"boolean\" ? defaultCacheKeys : typeof transformObj.cache.keys === \"function\" ? yield transformObj.cache.keys(defaultCacheKeys, absoluteFilename) : { ...defaultCacheKeys,\n                    ...transformObj.cache.keys\n                  })}`;\n                  logger.debug(`getting transformation cache for '${absoluteFilename}'...`);\n                  const cacheItem = cache.getItemCache(cacheKeys, cache.getLazyHashedEtag(source));\n                  source = yield cacheItem.getPromise();\n                  logger.debug(source ? `found transformation cache for '${absoluteFilename}'` : `no transformation cache for '${absoluteFilename}'`);\n\n                  if (!source) {\n                    const transformed = yield transformObj.transformer(buffer, absoluteFilename);\n                    source = new RawSource(transformed);\n                    logger.debug(`caching transformation for '${absoluteFilename}'...`);\n                    yield cacheItem.storePromise(source);\n                    logger.debug(`cached transformation for '${absoluteFilename}'`);\n                  }\n                } else {\n                  source = new RawSource(yield transformObj.transformer(buffer, absoluteFilename));\n                }\n              }\n            }\n\n            let info = typeof pattern.info === \"undefined\" ? {} : typeof pattern.info === \"function\" ? pattern.info({\n              absoluteFilename,\n              sourceFilename,\n              filename,\n              toType\n            }) || {} : pattern.info || {};\n\n            if (toType === \"template\") {\n              logger.log(`interpolating template '${filename}' for '${sourceFilename}'...`);\n              const contentHash = CopyPlugin.getContentHash(compiler, compilation, source.buffer());\n              const ext = path.extname(sourceFilename);\n              const base = path.basename(sourceFilename);\n              const name = base.slice(0, base.length - ext.length);\n              const data = {\n                filename: normalizePath(path.relative(pattern.context, absoluteFilename)),\n                contentHash,\n                chunk: {\n                  name,\n                  id:\n                  /** @type {string} */\n                  sourceFilename,\n                  hash: contentHash\n                }\n              };\n              const {\n                path: interpolatedFilename,\n                info: assetInfo\n              } = compilation.getPathWithInfo(normalizePath(filename), data);\n              info = { ...info,\n                ...assetInfo\n              };\n              filename = interpolatedFilename;\n              logger.log(`interpolated template '${filename}' for '${sourceFilename}'`);\n            } else {\n              filename = normalizePath(filename);\n            } // eslint-disable-next-line consistent-return\n\n\n            return {\n              sourceFilename,\n              absoluteFilename,\n              filename,\n              source,\n              info,\n              force: pattern.force\n            };\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()));\n      } catch (error) {\n        compilation.errors.push(\n        /** @type {WebpackError} */\n        error);\n        return;\n      }\n\n      if (copiedResult.length === 0) {\n        if (pattern.noErrorOnMissing) {\n          logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context to '${pattern.to}'`);\n          return;\n        }\n\n        const missingError = new Error(`unable to locate '${glob}' glob after filtering paths`);\n        compilation.errors.push(\n        /** @type {WebpackError} */\n        missingError);\n        return;\n      }\n\n      logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context`); // eslint-disable-next-line consistent-return\n\n      return copiedResult;\n    })();\n  }\n  /**\n   * @param {Compiler} compiler\n   */\n\n\n  apply(compiler) {\n    var _this = this;\n\n    const pluginName = this.constructor.name;\n    compiler.hooks.thisCompilation.tap(pluginName, compilation => {\n      const logger = compilation.getLogger(\"copy-webpack-plugin\");\n      const cache = compilation.getCache(\"CopyWebpackPlugin\");\n      /**\n       * @type {typeof import(\"globby\").globby}\n       */\n\n      let globby;\n      compilation.hooks.processAssets.tapAsync({\n        name: \"copy-webpack-plugin\",\n        stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL\n      }, /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (unusedAssets, callback) {\n          if (typeof globby === \"undefined\") {\n            try {\n              // @ts-ignore\n              ({\n                globby\n              } = yield import(\"globby\"));\n            } catch (error) {\n              callback(\n              /** @type {Error} */\n              error);\n              return;\n            }\n          }\n\n          logger.log(\"starting to add additional assets...\");\n          const copiedResultMap = new Map();\n          /**\n           * @type {(() => Promise<void>)[]}\n           */\n\n          const scheduledTasks = [];\n\n          _this.patterns.map(\n          /**\n           * @param {Pattern} item\n           * @param {number} index\n           * @return {number}\n           */\n          (item, index) => scheduledTasks.push( /*#__PURE__*/_asyncToGenerator(function* () {\n            /**\n             * @type {ObjectPattern}\n             */\n            const normalizedPattern = typeof item === \"string\" ? {\n              from: item\n            } : { ...item\n            };\n            const context = typeof normalizedPattern.context === \"undefined\" ? compiler.context : path.isAbsolute(normalizedPattern.context) ? normalizedPattern.context : path.join(compiler.context, normalizedPattern.context);\n            normalizedPattern.context = context;\n            /**\n             * @type {Array<CopiedResult | undefined> | undefined}\n             */\n\n            let copiedResult;\n\n            try {\n              copiedResult = yield CopyPlugin.runPattern(globby, compiler, compilation, logger, cache,\n              /** @type {ObjectPattern & { context: string }} */\n              normalizedPattern, index);\n            } catch (error) {\n              compilation.errors.push(\n              /** @type {WebpackError} */\n              error);\n              return;\n            }\n\n            if (!copiedResult) {\n              return;\n            }\n            /**\n             * @type {Array<CopiedResult>}\n             */\n\n\n            let filteredCopiedResult = copiedResult.filter(\n            /**\n             * @param {CopiedResult | undefined} result\n             * @returns {result is CopiedResult}\n             */\n            result => Boolean(result));\n\n            if (typeof normalizedPattern.transformAll !== \"undefined\") {\n              if (typeof normalizedPattern.to === \"undefined\") {\n                compilation.errors.push(\n                /** @type {WebpackError} */\n                new Error(`Invalid \"pattern.to\" for the \"pattern.from\": \"${normalizedPattern.from}\" and \"pattern.transformAll\" function. The \"to\" option must be specified.`));\n                return;\n              }\n\n              filteredCopiedResult.sort((a, b) => a.absoluteFilename > b.absoluteFilename ? 1 : a.absoluteFilename < b.absoluteFilename ? -1 : 0);\n              const mergedEtag = filteredCopiedResult.length === 1 ? cache.getLazyHashedEtag(filteredCopiedResult[0].source) : filteredCopiedResult.reduce(\n              /**\n               * @param {Etag} accumulator\n               * @param {CopiedResult} asset\n               * @param {number} i\n               * @return {Etag}\n               */\n              // @ts-ignore\n              (accumulator, asset, i) => {\n                // eslint-disable-next-line no-param-reassign\n                accumulator = cache.mergeEtags(i === 1 ? cache.getLazyHashedEtag(\n                /** @type {CopiedResult}*/\n                accumulator.source) : accumulator, cache.getLazyHashedEtag(asset.source));\n                return accumulator;\n              });\n              const cacheItem = cache.getItemCache(`transformAll|${serialize({\n                version,\n                from: normalizedPattern.from,\n                to: normalizedPattern.to,\n                transformAll: normalizedPattern.transformAll\n              })}`, mergedEtag);\n              let transformedAsset = yield cacheItem.getPromise();\n\n              if (!transformedAsset) {\n                transformedAsset = {\n                  filename: normalizedPattern.to\n                };\n\n                try {\n                  transformedAsset.data = yield normalizedPattern.transformAll(filteredCopiedResult.map(asset => {\n                    return {\n                      data: asset.source.buffer(),\n                      sourceFilename: asset.sourceFilename,\n                      absoluteFilename: asset.absoluteFilename\n                    };\n                  }));\n                } catch (error) {\n                  compilation.errors.push(\n                  /** @type {WebpackError} */\n                  error);\n                  return;\n                }\n\n                const filename = typeof normalizedPattern.to === \"function\" ? normalizedPattern.to({\n                  context\n                }) : normalizedPattern.to;\n\n                if (template.test(filename)) {\n                  const contentHash = CopyPlugin.getContentHash(compiler, compilation, transformedAsset.data);\n                  const {\n                    path: interpolatedFilename,\n                    info: assetInfo\n                  } = compilation.getPathWithInfo(normalizePath(filename), {\n                    contentHash,\n                    chunk: {\n                      id: \"unknown-copied-asset\",\n                      hash: contentHash\n                    }\n                  });\n                  transformedAsset.filename = interpolatedFilename;\n                  transformedAsset.info = assetInfo;\n                }\n\n                const {\n                  RawSource\n                } = compiler.webpack.sources;\n                transformedAsset.source = new RawSource(transformedAsset.data);\n                transformedAsset.force = normalizedPattern.force;\n                yield cacheItem.storePromise(transformedAsset);\n              }\n\n              filteredCopiedResult = [transformedAsset];\n            }\n\n            const priority = normalizedPattern.priority || 0;\n\n            if (!copiedResultMap.has(priority)) {\n              copiedResultMap.set(priority, []);\n            }\n\n            copiedResultMap.get(priority).push(...filteredCopiedResult);\n          })));\n\n          yield throttleAll(_this.options.concurrency || 100, scheduledTasks);\n          const copiedResult = [...copiedResultMap.entries()].sort((a, b) => a[0] - b[0]); // Avoid writing assets inside `p-limit`, because it creates concurrency.\n          // It could potentially lead to an error - 'Multiple assets emit different content to the same filename'\n\n          copiedResult.reduce((acc, val) => acc.concat(val[1]), []).filter(Boolean).forEach(\n          /**\n           * @param {CopiedResult} result\n           * @returns {void}\n           */\n          result => {\n            const {\n              absoluteFilename,\n              sourceFilename,\n              filename,\n              source,\n              force\n            } = result;\n            const existingAsset = compilation.getAsset(filename);\n\n            if (existingAsset) {\n              if (force) {\n                const info = {\n                  copied: true,\n                  sourceFilename\n                };\n                logger.log(`force updating '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists...`);\n                compilation.updateAsset(filename, source, { ...info,\n                  ...result.info\n                });\n                logger.log(`force updated '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists`);\n                return;\n              }\n\n              logger.log(`skip adding '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists`);\n              return;\n            }\n\n            const info = {\n              copied: true,\n              sourceFilename\n            };\n            logger.log(`writing '${filename}' from '${absoluteFilename}' to compilation assets...`);\n            compilation.emitAsset(filename, source, { ...info,\n              ...result.info\n            });\n            logger.log(`written '${filename}' from '${absoluteFilename}' to compilation assets`);\n          });\n          logger.log(\"finished to adding additional assets\");\n          callback();\n        });\n\n        return function (_x2, _x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n\n      if (compilation.hooks.statsPrinter) {\n        compilation.hooks.statsPrinter.tap(pluginName, stats => {\n          stats.hooks.print.for(\"asset.info.copied\").tap(\"copy-webpack-plugin\", (copied, {\n            green,\n            formatFlag\n          }) => copied ?\n          /** @type {Function} */\n          green(\n          /** @type {Function} */\n          formatFlag(\"copied\")) : \"\");\n        });\n      }\n    });\n  }\n\n}\n\nmodule.exports = CopyPlugin;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/copy-webpack-plugin/dist/index.js"],"names":["path","require","validate","serialize","normalizePath","globParent","fastGlob","version","schema","readFile","stat","throttleAll","template","CopyPlugin","constructor","options","patterns","name","baseDataPath","createSnapshot","compilation","startTime","dependency","Promise","resolve","reject","fileSystemInfo","undefined","error","snapshot","checkSnapshotValid","isValid","getContentHash","compiler","source","outputOptions","hashDigest","hashDigestLength","hashFunction","hashSalt","hash","webpack","util","createHash","update","fullContentHash","digest","toString","slice","runPattern","globby","logger","cache","inputPattern","index","RawSource","sources","pattern","originalFrom","from","normalizedOriginalFrom","normalize","log","context","absoluteFrom","isAbsolute","debug","inputFileSystem","stats","fromType","isDirectory","isFile","globOptions","followSymbolicLinks","cwd","objectMode","fs","glob","contextDependencies","add","posix","join","escapePath","dot","fileDependencies","dirname","globEntries","errors","push","length","noErrorOnMissing","to","missingError","Error","copiedResult","all","map","globEntry","dirent","filter","isFiltered","absoluteFilename","toType","test","extname","sep","relativeFrom","relative","filename","output","sourceFilename","cacheEntry","getPromise","isValidSnapshot","Date","now","data","storePromise","transform","transformObj","transformer","buffer","hasher","defaultCacheKeys","contentHash","cacheKeys","keys","cacheItem","getItemCache","getLazyHashedEtag","transformed","info","ext","base","basename","chunk","id","interpolatedFilename","assetInfo","getPathWithInfo","force","apply","pluginName","hooks","thisCompilation","tap","getLogger","getCache","processAssets","tapAsync","stage","Compilation","PROCESS_ASSETS_STAGE_ADDITIONAL","unusedAssets","callback","copiedResultMap","Map","scheduledTasks","item","normalizedPattern","filteredCopiedResult","result","Boolean","transformAll","sort","a","b","mergedEtag","reduce","accumulator","asset","i","mergeEtags","transformedAsset","priority","has","set","get","concurrency","entries","acc","val","concat","forEach","existingAsset","getAsset","copied","updateAsset","emitAsset","statsPrinter","print","for","green","formatFlag","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst path = require(\"path\");\n\nconst {\n  validate\n} = require(\"schema-utils\");\n\nconst serialize = require(\"serialize-javascript\");\n\nconst normalizePath = require(\"normalize-path\");\n\nconst globParent = require(\"glob-parent\");\n\nconst fastGlob = require(\"fast-glob\"); // @ts-ignore\n\n\nconst {\n  version\n} = require(\"../package.json\");\n\nconst schema = require(\"./options.json\");\n\nconst {\n  readFile,\n  stat,\n  throttleAll\n} = require(\"./utils\");\n\nconst template = /\\[\\\\*([\\w:]+)\\\\*\\]/i;\n/** @typedef {import(\"schema-utils/declarations/validate\").Schema} Schema */\n\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n\n/** @typedef {import(\"webpack\").Compilation} Compilation */\n\n/** @typedef {import(\"webpack\").WebpackError} WebpackError */\n\n/** @typedef {import(\"webpack\").Asset} Asset */\n\n/** @typedef {import(\"globby\").Options} GlobbyOptions */\n\n/** @typedef {import(\"globby\").GlobEntry} GlobEntry */\n\n/** @typedef {ReturnType<Compilation[\"getLogger\"]>} WebpackLogger */\n\n/** @typedef {ReturnType<Compilation[\"getCache\"]>} CacheFacade */\n\n/** @typedef {ReturnType<ReturnType<Compilation[\"getCache\"]>[\"getLazyHashedEtag\"]>} Etag */\n\n/** @typedef {ReturnType<Compilation[\"fileSystemInfo\"][\"mergeSnapshots\"]>} Snapshot */\n\n/**\n * @typedef {boolean} Force\n */\n\n/**\n * @typedef {Object} CopiedResult\n * @property {string} sourceFilename\n * @property {string} absoluteFilename\n * @property {string} filename\n * @property {Asset[\"source\"]} source\n * @property {Force | undefined} force\n * @property {{ [key: string]: string }} info\n */\n\n/**\n * @typedef {string} StringPattern\n */\n\n/**\n * @typedef {boolean} NoErrorOnMissing\n */\n\n/**\n * @typedef {string} Context\n */\n\n/**\n * @typedef {string} From\n */\n\n/**\n * @callback ToFunction\n * @param {{ context: string, absoluteFilename?: string }} pathData\n * @return {string}\n */\n\n/**\n * @typedef {string | ToFunction} To\n */\n\n/**\n * @typedef {\"dir\" | \"file\" | \"template\"} ToType\n */\n\n/**\n * @callback TransformerFunction\n * @param {Buffer} input\n * @param {string} absoluteFilename\n * @returns {string | Buffer}\n */\n\n/**\n * @typedef {{ keys: { [key: string]: any } } | { keys: ((defaultCacheKeys: { [key: string]: any }, absoluteFilename: string) => Promise<{ [key: string]: any }>) }} TransformerCacheObject\n */\n\n/**\n * @typedef {Object} TransformerObject\n * @property {TransformerFunction} transformer\n * @property {boolean | TransformerCacheObject} [cache]\n */\n\n/**\n * @typedef {TransformerFunction | TransformerObject} Transform\n */\n\n/**\n * @callback Filter\n * @param {string} filepath\n * @returns {boolean}\n */\n\n/**\n * @callback TransformAllFunction\n * @param {{ data: Buffer, sourceFilename: string, absoluteFilename: string }[]} data\n * @returns {string | Buffer}\n */\n\n/**\n * @typedef { { [key: string]: string } | ((item: { absoluteFilename: string, sourceFilename: string, filename: string, toType: ToType }) => { [key: string]: string }) } Info\n */\n\n/**\n * @typedef {Object} ObjectPattern\n * @property {From} from\n * @property {GlobbyOptions} [globOptions]\n * @property {Context} [context]\n * @property {To} [to]\n * @property {ToType} [toType]\n * @property {Info} [info]\n * @property {Filter} [filter]\n * @property {Transform} [transform]\n * @property {TransformAllFunction} [transformAll]\n * @property {Force} [force]\n * @property {number} [priority]\n * @property {NoErrorOnMissing} [noErrorOnMissing]\n */\n\n/**\n * @typedef {StringPattern | ObjectPattern} Pattern\n */\n\n/**\n * @typedef {Object} AdditionalOptions\n * @property {number} [concurrency]\n */\n\n/**\n * @typedef {Object} PluginOptions\n * @property {Pattern[]} patterns\n * @property {AdditionalOptions} [options]\n */\n\nclass CopyPlugin {\n  /**\n   * @param {PluginOptions} [options]\n   */\n  constructor(options = {\n    patterns: []\n  }) {\n    validate(\n    /** @type {Schema} */\n    schema, options, {\n      name: \"Copy Plugin\",\n      baseDataPath: \"options\"\n    });\n    /**\n     * @private\n     * @type {Pattern[]}\n     */\n\n    this.patterns = options.patterns;\n    /**\n     * @private\n     * @type {AdditionalOptions}\n     */\n\n    this.options = options.options || {};\n  }\n  /**\n   * @private\n   * @param {Compilation} compilation\n   * @param {number} startTime\n   * @param {string} dependency\n   * @returns {Promise<Snapshot | undefined>}\n   */\n\n\n  static async createSnapshot(compilation, startTime, dependency) {\n    // eslint-disable-next-line consistent-return\n    return new Promise((resolve, reject) => {\n      compilation.fileSystemInfo.createSnapshot(startTime, [dependency], // @ts-ignore\n      // eslint-disable-next-line no-undefined\n      undefined, // eslint-disable-next-line no-undefined\n      undefined, null, (error, snapshot) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(snapshot);\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {Compilation} compilation\n   * @param {Snapshot} snapshot\n   * @returns {Promise<boolean | undefined>}\n   */\n\n\n  static async checkSnapshotValid(compilation, snapshot) {\n    // eslint-disable-next-line consistent-return\n    return new Promise((resolve, reject) => {\n      compilation.fileSystemInfo.checkSnapshotValid(snapshot, (error, isValid) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(isValid);\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {Compiler} compiler\n   * @param {Compilation} compilation\n   * @param {Buffer} source\n   * @returns {string}\n   */\n\n\n  static getContentHash(compiler, compilation, source) {\n    const {\n      outputOptions\n    } = compilation;\n    const {\n      hashDigest,\n      hashDigestLength,\n      hashFunction,\n      hashSalt\n    } = outputOptions;\n    const hash = compiler.webpack.util.createHash(\n    /** @type {string} */\n    hashFunction);\n\n    if (hashSalt) {\n      hash.update(hashSalt);\n    }\n\n    hash.update(source);\n    const fullContentHash = hash.digest(hashDigest);\n    return fullContentHash.toString().slice(0, hashDigestLength);\n  }\n  /**\n   * @private\n   * @param {typeof import(\"globby\").globby} globby\n   * @param {Compiler} compiler\n   * @param {Compilation} compilation\n   * @param {WebpackLogger} logger\n   * @param {CacheFacade} cache\n   * @param {ObjectPattern & { context: string }} inputPattern\n   * @param {number} index\n   * @returns {Promise<Array<CopiedResult | undefined> | undefined>}\n   */\n\n\n  static async runPattern(globby, compiler, compilation, logger, cache, inputPattern, index) {\n    const {\n      RawSource\n    } = compiler.webpack.sources;\n    const pattern = { ...inputPattern\n    };\n    const originalFrom = pattern.from;\n    const normalizedOriginalFrom = path.normalize(originalFrom);\n    logger.log(`starting to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context`);\n    let absoluteFrom;\n\n    if (path.isAbsolute(normalizedOriginalFrom)) {\n      absoluteFrom = normalizedOriginalFrom;\n    } else {\n      absoluteFrom = path.resolve(pattern.context, normalizedOriginalFrom);\n    }\n\n    logger.debug(`getting stats for '${absoluteFrom}'...`);\n    const {\n      inputFileSystem\n    } = compiler;\n    let stats;\n\n    try {\n      stats = await stat(inputFileSystem, absoluteFrom);\n    } catch (error) {// Nothing\n    }\n    /**\n     * @type {\"file\" | \"dir\" | \"glob\"}\n     */\n\n\n    let fromType;\n\n    if (stats) {\n      if (stats.isDirectory()) {\n        fromType = \"dir\";\n        logger.debug(`determined '${absoluteFrom}' is a directory`);\n      } else if (stats.isFile()) {\n        fromType = \"file\";\n        logger.debug(`determined '${absoluteFrom}' is a file`);\n      } else {\n        // Fallback\n        fromType = \"glob\";\n        logger.debug(`determined '${absoluteFrom}' is unknown`);\n      }\n    } else {\n      fromType = \"glob\";\n      logger.debug(`determined '${absoluteFrom}' is a glob`);\n    }\n    /** @type {GlobbyOptions & { objectMode: true }} */\n\n\n    const globOptions = { ...{\n        followSymbolicLinks: true\n      },\n      ...(pattern.globOptions || {}),\n      ...{\n        cwd: pattern.context,\n        objectMode: true\n      }\n    }; // @ts-ignore\n\n    globOptions.fs = inputFileSystem;\n    let glob;\n\n    switch (fromType) {\n      case \"dir\":\n        compilation.contextDependencies.add(absoluteFrom);\n        logger.debug(`added '${absoluteFrom}' as a context dependency`);\n        pattern.context = absoluteFrom;\n        glob = path.posix.join(fastGlob.escapePath(normalizePath(path.resolve(absoluteFrom))), \"**/*\");\n        absoluteFrom = path.join(absoluteFrom, \"**/*\");\n\n        if (typeof globOptions.dot === \"undefined\") {\n          globOptions.dot = true;\n        }\n\n        break;\n\n      case \"file\":\n        compilation.fileDependencies.add(absoluteFrom);\n        logger.debug(`added '${absoluteFrom}' as a file dependency`);\n        pattern.context = path.dirname(absoluteFrom);\n        glob = fastGlob.escapePath(normalizePath(path.resolve(absoluteFrom)));\n\n        if (typeof globOptions.dot === \"undefined\") {\n          globOptions.dot = true;\n        }\n\n        break;\n\n      case \"glob\":\n      default:\n        {\n          const contextDependencies = path.normalize(globParent(absoluteFrom));\n          compilation.contextDependencies.add(contextDependencies);\n          logger.debug(`added '${contextDependencies}' as a context dependency`);\n          glob = path.isAbsolute(originalFrom) ? originalFrom : path.posix.join(fastGlob.escapePath(normalizePath(path.resolve(pattern.context))), originalFrom);\n        }\n    }\n\n    logger.log(`begin globbing '${glob}'...`);\n    /**\n     * @type {GlobEntry[]}\n     */\n\n    let globEntries;\n\n    try {\n      globEntries = await globby(glob, globOptions);\n    } catch (error) {\n      compilation.errors.push(\n      /** @type {WebpackError} */\n      error);\n      return;\n    }\n\n    if (globEntries.length === 0) {\n      if (pattern.noErrorOnMissing) {\n        logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context to '${pattern.to}'`);\n        return;\n      }\n\n      const missingError = new Error(`unable to locate '${glob}' glob`);\n      compilation.errors.push(\n      /** @type {WebpackError} */\n      missingError);\n      return;\n    }\n    /**\n     * @type {Array<CopiedResult | undefined>}\n     */\n\n\n    let copiedResult;\n\n    try {\n      copiedResult = await Promise.all(globEntries.map(\n      /**\n       * @param {GlobEntry} globEntry\n       * @returns {Promise<CopiedResult | undefined>}\n       */\n      async globEntry => {\n        // Exclude directories\n        if (!globEntry.dirent.isFile()) {\n          return;\n        }\n\n        if (pattern.filter) {\n          let isFiltered;\n\n          try {\n            isFiltered = await pattern.filter(globEntry.path);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          if (!isFiltered) {\n            logger.log(`skip '${globEntry.path}', because it was filtered`);\n            return;\n          }\n        }\n\n        const from = globEntry.path;\n        logger.debug(`found '${from}'`); // `globby`/`fast-glob` return the relative path when the path contains special characters on windows\n\n        const absoluteFilename = path.resolve(pattern.context, from);\n        const to = typeof pattern.to === \"function\" ? await pattern.to({\n          context: pattern.context,\n          absoluteFilename\n        }) : path.normalize(typeof pattern.to !== \"undefined\" ? pattern.to : \"\");\n        const toType = pattern.toType ? pattern.toType : template.test(to) ? \"template\" : path.extname(to) === \"\" || to.slice(-1) === path.sep ? \"dir\" : \"file\";\n        logger.log(`'to' option '${to}' determinated as '${toType}'`);\n        const relativeFrom = path.relative(pattern.context, absoluteFilename);\n        let filename = toType === \"dir\" ? path.join(to, relativeFrom) : to;\n\n        if (path.isAbsolute(filename)) {\n          filename = path.relative(\n          /** @type {string} */\n          compiler.options.output.path, filename);\n        }\n\n        logger.log(`determined that '${from}' should write to '${filename}'`);\n        const sourceFilename = normalizePath(path.relative(compiler.context, absoluteFilename)); // If this came from a glob or dir, add it to the file dependencies\n\n        if (fromType === \"dir\" || fromType === \"glob\") {\n          compilation.fileDependencies.add(absoluteFilename);\n          logger.debug(`added '${absoluteFilename}' as a file dependency`);\n        }\n\n        let cacheEntry;\n        logger.debug(`getting cache for '${absoluteFilename}'...`);\n\n        try {\n          cacheEntry = await cache.getPromise(`${sourceFilename}|${index}`, null);\n        } catch (error) {\n          compilation.errors.push(\n          /** @type {WebpackError} */\n          error);\n          return;\n        }\n        /**\n         * @type {Asset[\"source\"] | undefined}\n         */\n\n\n        let source;\n\n        if (cacheEntry) {\n          logger.debug(`found cache for '${absoluteFilename}'...`);\n          let isValidSnapshot;\n          logger.debug(`checking snapshot on valid for '${absoluteFilename}'...`);\n\n          try {\n            isValidSnapshot = await CopyPlugin.checkSnapshotValid(compilation, cacheEntry.snapshot);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          if (isValidSnapshot) {\n            logger.debug(`snapshot for '${absoluteFilename}' is valid`);\n            ({\n              source\n            } = cacheEntry);\n          } else {\n            logger.debug(`snapshot for '${absoluteFilename}' is invalid`);\n          }\n        } else {\n          logger.debug(`missed cache for '${absoluteFilename}'`);\n        }\n\n        if (!source) {\n          const startTime = Date.now();\n          logger.debug(`reading '${absoluteFilename}'...`);\n          let data;\n\n          try {\n            data = await readFile(inputFileSystem, absoluteFilename);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          logger.debug(`read '${absoluteFilename}'`);\n          source = new RawSource(data);\n          let snapshot;\n          logger.debug(`creating snapshot for '${absoluteFilename}'...`);\n\n          try {\n            snapshot = await CopyPlugin.createSnapshot(compilation, startTime, absoluteFilename);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          if (snapshot) {\n            logger.debug(`created snapshot for '${absoluteFilename}'`);\n            logger.debug(`storing cache for '${absoluteFilename}'...`);\n\n            try {\n              await cache.storePromise(`${sourceFilename}|${index}`, null, {\n                source,\n                snapshot\n              });\n            } catch (error) {\n              compilation.errors.push(\n              /** @type {WebpackError} */\n              error);\n              return;\n            }\n\n            logger.debug(`stored cache for '${absoluteFilename}'`);\n          }\n        }\n\n        if (pattern.transform) {\n          /**\n           * @type {TransformerObject}\n           */\n          const transformObj = typeof pattern.transform === \"function\" ? {\n            transformer: pattern.transform\n          } : pattern.transform;\n\n          if (transformObj.transformer) {\n            logger.log(`transforming content for '${absoluteFilename}'...`);\n            const buffer = source.buffer();\n\n            if (transformObj.cache) {\n              // TODO: remove in the next major release\n              const hasher = compiler.webpack && compiler.webpack.util && compiler.webpack.util.createHash ? compiler.webpack.util.createHash(\"xxhash64\") : // eslint-disable-next-line global-require\n              require(\"crypto\").createHash(\"md4\");\n              const defaultCacheKeys = {\n                version,\n                sourceFilename,\n                transform: transformObj.transformer,\n                contentHash: hasher.update(buffer).digest(\"hex\"),\n                index\n              };\n              const cacheKeys = `transform|${serialize(typeof transformObj.cache === \"boolean\" ? defaultCacheKeys : typeof transformObj.cache.keys === \"function\" ? await transformObj.cache.keys(defaultCacheKeys, absoluteFilename) : { ...defaultCacheKeys,\n                ...transformObj.cache.keys\n              })}`;\n              logger.debug(`getting transformation cache for '${absoluteFilename}'...`);\n              const cacheItem = cache.getItemCache(cacheKeys, cache.getLazyHashedEtag(source));\n              source = await cacheItem.getPromise();\n              logger.debug(source ? `found transformation cache for '${absoluteFilename}'` : `no transformation cache for '${absoluteFilename}'`);\n\n              if (!source) {\n                const transformed = await transformObj.transformer(buffer, absoluteFilename);\n                source = new RawSource(transformed);\n                logger.debug(`caching transformation for '${absoluteFilename}'...`);\n                await cacheItem.storePromise(source);\n                logger.debug(`cached transformation for '${absoluteFilename}'`);\n              }\n            } else {\n              source = new RawSource(await transformObj.transformer(buffer, absoluteFilename));\n            }\n          }\n        }\n\n        let info = typeof pattern.info === \"undefined\" ? {} : typeof pattern.info === \"function\" ? pattern.info({\n          absoluteFilename,\n          sourceFilename,\n          filename,\n          toType\n        }) || {} : pattern.info || {};\n\n        if (toType === \"template\") {\n          logger.log(`interpolating template '${filename}' for '${sourceFilename}'...`);\n          const contentHash = CopyPlugin.getContentHash(compiler, compilation, source.buffer());\n          const ext = path.extname(sourceFilename);\n          const base = path.basename(sourceFilename);\n          const name = base.slice(0, base.length - ext.length);\n          const data = {\n            filename: normalizePath(path.relative(pattern.context, absoluteFilename)),\n            contentHash,\n            chunk: {\n              name,\n              id:\n              /** @type {string} */\n              sourceFilename,\n              hash: contentHash\n            }\n          };\n          const {\n            path: interpolatedFilename,\n            info: assetInfo\n          } = compilation.getPathWithInfo(normalizePath(filename), data);\n          info = { ...info,\n            ...assetInfo\n          };\n          filename = interpolatedFilename;\n          logger.log(`interpolated template '${filename}' for '${sourceFilename}'`);\n        } else {\n          filename = normalizePath(filename);\n        } // eslint-disable-next-line consistent-return\n\n\n        return {\n          sourceFilename,\n          absoluteFilename,\n          filename,\n          source,\n          info,\n          force: pattern.force\n        };\n      }));\n    } catch (error) {\n      compilation.errors.push(\n      /** @type {WebpackError} */\n      error);\n      return;\n    }\n\n    if (copiedResult.length === 0) {\n      if (pattern.noErrorOnMissing) {\n        logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context to '${pattern.to}'`);\n        return;\n      }\n\n      const missingError = new Error(`unable to locate '${glob}' glob after filtering paths`);\n      compilation.errors.push(\n      /** @type {WebpackError} */\n      missingError);\n      return;\n    }\n\n    logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context`); // eslint-disable-next-line consistent-return\n\n    return copiedResult;\n  }\n  /**\n   * @param {Compiler} compiler\n   */\n\n\n  apply(compiler) {\n    const pluginName = this.constructor.name;\n    compiler.hooks.thisCompilation.tap(pluginName, compilation => {\n      const logger = compilation.getLogger(\"copy-webpack-plugin\");\n      const cache = compilation.getCache(\"CopyWebpackPlugin\");\n      /**\n       * @type {typeof import(\"globby\").globby}\n       */\n\n      let globby;\n      compilation.hooks.processAssets.tapAsync({\n        name: \"copy-webpack-plugin\",\n        stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL\n      }, async (unusedAssets, callback) => {\n        if (typeof globby === \"undefined\") {\n          try {\n            // @ts-ignore\n            ({\n              globby\n            } = await import(\"globby\"));\n          } catch (error) {\n            callback(\n            /** @type {Error} */\n            error);\n            return;\n          }\n        }\n\n        logger.log(\"starting to add additional assets...\");\n        const copiedResultMap = new Map();\n        /**\n         * @type {(() => Promise<void>)[]}\n         */\n\n        const scheduledTasks = [];\n        this.patterns.map(\n        /**\n         * @param {Pattern} item\n         * @param {number} index\n         * @return {number}\n         */\n        (item, index) => scheduledTasks.push(async () => {\n          /**\n           * @type {ObjectPattern}\n           */\n          const normalizedPattern = typeof item === \"string\" ? {\n            from: item\n          } : { ...item\n          };\n          const context = typeof normalizedPattern.context === \"undefined\" ? compiler.context : path.isAbsolute(normalizedPattern.context) ? normalizedPattern.context : path.join(compiler.context, normalizedPattern.context);\n          normalizedPattern.context = context;\n          /**\n           * @type {Array<CopiedResult | undefined> | undefined}\n           */\n\n          let copiedResult;\n\n          try {\n            copiedResult = await CopyPlugin.runPattern(globby, compiler, compilation, logger, cache,\n            /** @type {ObjectPattern & { context: string }} */\n            normalizedPattern, index);\n          } catch (error) {\n            compilation.errors.push(\n            /** @type {WebpackError} */\n            error);\n            return;\n          }\n\n          if (!copiedResult) {\n            return;\n          }\n          /**\n           * @type {Array<CopiedResult>}\n           */\n\n\n          let filteredCopiedResult = copiedResult.filter(\n          /**\n           * @param {CopiedResult | undefined} result\n           * @returns {result is CopiedResult}\n           */\n          result => Boolean(result));\n\n          if (typeof normalizedPattern.transformAll !== \"undefined\") {\n            if (typeof normalizedPattern.to === \"undefined\") {\n              compilation.errors.push(\n              /** @type {WebpackError} */\n              new Error(`Invalid \"pattern.to\" for the \"pattern.from\": \"${normalizedPattern.from}\" and \"pattern.transformAll\" function. The \"to\" option must be specified.`));\n              return;\n            }\n\n            filteredCopiedResult.sort((a, b) => a.absoluteFilename > b.absoluteFilename ? 1 : a.absoluteFilename < b.absoluteFilename ? -1 : 0);\n            const mergedEtag = filteredCopiedResult.length === 1 ? cache.getLazyHashedEtag(filteredCopiedResult[0].source) : filteredCopiedResult.reduce(\n            /**\n             * @param {Etag} accumulator\n             * @param {CopiedResult} asset\n             * @param {number} i\n             * @return {Etag}\n             */\n            // @ts-ignore\n            (accumulator, asset, i) => {\n              // eslint-disable-next-line no-param-reassign\n              accumulator = cache.mergeEtags(i === 1 ? cache.getLazyHashedEtag(\n              /** @type {CopiedResult}*/\n              accumulator.source) : accumulator, cache.getLazyHashedEtag(asset.source));\n              return accumulator;\n            });\n            const cacheItem = cache.getItemCache(`transformAll|${serialize({\n              version,\n              from: normalizedPattern.from,\n              to: normalizedPattern.to,\n              transformAll: normalizedPattern.transformAll\n            })}`, mergedEtag);\n            let transformedAsset = await cacheItem.getPromise();\n\n            if (!transformedAsset) {\n              transformedAsset = {\n                filename: normalizedPattern.to\n              };\n\n              try {\n                transformedAsset.data = await normalizedPattern.transformAll(filteredCopiedResult.map(asset => {\n                  return {\n                    data: asset.source.buffer(),\n                    sourceFilename: asset.sourceFilename,\n                    absoluteFilename: asset.absoluteFilename\n                  };\n                }));\n              } catch (error) {\n                compilation.errors.push(\n                /** @type {WebpackError} */\n                error);\n                return;\n              }\n\n              const filename = typeof normalizedPattern.to === \"function\" ? normalizedPattern.to({\n                context\n              }) : normalizedPattern.to;\n\n              if (template.test(filename)) {\n                const contentHash = CopyPlugin.getContentHash(compiler, compilation, transformedAsset.data);\n                const {\n                  path: interpolatedFilename,\n                  info: assetInfo\n                } = compilation.getPathWithInfo(normalizePath(filename), {\n                  contentHash,\n                  chunk: {\n                    id: \"unknown-copied-asset\",\n                    hash: contentHash\n                  }\n                });\n                transformedAsset.filename = interpolatedFilename;\n                transformedAsset.info = assetInfo;\n              }\n\n              const {\n                RawSource\n              } = compiler.webpack.sources;\n              transformedAsset.source = new RawSource(transformedAsset.data);\n              transformedAsset.force = normalizedPattern.force;\n              await cacheItem.storePromise(transformedAsset);\n            }\n\n            filteredCopiedResult = [transformedAsset];\n          }\n\n          const priority = normalizedPattern.priority || 0;\n\n          if (!copiedResultMap.has(priority)) {\n            copiedResultMap.set(priority, []);\n          }\n\n          copiedResultMap.get(priority).push(...filteredCopiedResult);\n        }));\n        await throttleAll(this.options.concurrency || 100, scheduledTasks);\n        const copiedResult = [...copiedResultMap.entries()].sort((a, b) => a[0] - b[0]); // Avoid writing assets inside `p-limit`, because it creates concurrency.\n        // It could potentially lead to an error - 'Multiple assets emit different content to the same filename'\n\n        copiedResult.reduce((acc, val) => acc.concat(val[1]), []).filter(Boolean).forEach(\n        /**\n         * @param {CopiedResult} result\n         * @returns {void}\n         */\n        result => {\n          const {\n            absoluteFilename,\n            sourceFilename,\n            filename,\n            source,\n            force\n          } = result;\n          const existingAsset = compilation.getAsset(filename);\n\n          if (existingAsset) {\n            if (force) {\n              const info = {\n                copied: true,\n                sourceFilename\n              };\n              logger.log(`force updating '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists...`);\n              compilation.updateAsset(filename, source, { ...info,\n                ...result.info\n              });\n              logger.log(`force updated '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists`);\n              return;\n            }\n\n            logger.log(`skip adding '${filename}' from '${absoluteFilename}' to compilation assets, because it already exists`);\n            return;\n          }\n\n          const info = {\n            copied: true,\n            sourceFilename\n          };\n          logger.log(`writing '${filename}' from '${absoluteFilename}' to compilation assets...`);\n          compilation.emitAsset(filename, source, { ...info,\n            ...result.info\n          });\n          logger.log(`written '${filename}' from '${absoluteFilename}' to compilation assets`);\n        });\n        logger.log(\"finished to adding additional assets\");\n        callback();\n      });\n\n      if (compilation.hooks.statsPrinter) {\n        compilation.hooks.statsPrinter.tap(pluginName, stats => {\n          stats.hooks.print.for(\"asset.info.copied\").tap(\"copy-webpack-plugin\", (copied, {\n            green,\n            formatFlag\n          }) => copied ?\n          /** @type {Function} */\n          green(\n          /** @type {Function} */\n          formatFlag(\"copied\")) : \"\");\n        });\n      }\n    });\n  }\n\n}\n\nmodule.exports = CopyPlugin;"]},"metadata":{},"sourceType":"script"}