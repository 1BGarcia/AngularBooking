{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nconst {\n  transformSync\n} = require('@babel/core');\n\nconst {\n  defaults\n} = require('@istanbuljs/schema');\n\nconst programVisitor = require('./visitor');\n\nconst readInitialCoverage = require('./read-coverage');\n/**\n * Instrumenter is the public API for the instrument library.\n * It is typically used for ES5 code. For ES6 code that you\n * are already running under `babel` use the coverage plugin\n * instead.\n * @param {Object} opts optional.\n * @param {string} [opts.coverageVariable=__coverage__] name of global coverage variable.\n * @param {boolean} [opts.reportLogic=false] report boolean value of logical expressions.\n * @param {boolean} [opts.preserveComments=false] preserve comments in output.\n * @param {boolean} [opts.compact=true] generate compact code.\n * @param {boolean} [opts.esModules=false] set to true to instrument ES6 modules.\n * @param {boolean} [opts.autoWrap=false] set to true to allow `return` statements outside of functions.\n * @param {boolean} [opts.produceSourceMap=false] set to true to produce a source map for the instrumented code.\n * @param {Array} [opts.ignoreClassMethods=[]] set to array of class method names to ignore for coverage.\n * @param {Function} [opts.sourceMapUrlCallback=null] a callback function that is called when a source map URL\n *     is found in the original code. This function is called with the source file name and the source map URL.\n * @param {boolean} [opts.debug=false] - turn debugging on.\n * @param {array} [opts.parserPlugins] - set babel parser plugins, see @istanbuljs/schema for defaults.\n */\n\n\nclass Instrumenter {\n  constructor(opts = {}) {\n    this.opts = { ...defaults.instrumenter,\n      ...opts\n    };\n    this.fileCoverage = null;\n    this.sourceMap = null;\n  }\n  /**\n   * instrument the supplied code and track coverage against the supplied\n   * filename. It throws if invalid code is passed to it. ES5 and ES6 syntax\n   * is supported. To instrument ES6 modules, make sure that you set the\n   * `esModules` property to `true` when creating the instrumenter.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {object} [inputSourceMap] - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   * @returns {string} the instrumented code.\n   */\n\n\n  instrumentSync(code, filename, inputSourceMap) {\n    if (typeof code !== 'string') {\n      throw new Error('Code must be a string');\n    }\n\n    filename = filename || String(new Date().getTime()) + '.js';\n    const {\n      opts\n    } = this;\n    let output = {};\n    const babelOpts = {\n      configFile: false,\n      babelrc: false,\n      ast: true,\n      filename: filename || String(new Date().getTime()) + '.js',\n      inputSourceMap,\n      sourceMaps: opts.produceSourceMap,\n      compact: opts.compact,\n      comments: opts.preserveComments,\n      parserOpts: {\n        allowReturnOutsideFunction: opts.autoWrap,\n        sourceType: opts.esModules ? 'module' : 'script',\n        plugins: opts.parserPlugins\n      },\n      plugins: [[({\n        types\n      }) => {\n        const ee = programVisitor(types, filename, {\n          coverageVariable: opts.coverageVariable,\n          reportLogic: opts.reportLogic,\n          coverageGlobalScope: opts.coverageGlobalScope,\n          coverageGlobalScopeFunc: opts.coverageGlobalScopeFunc,\n          ignoreClassMethods: opts.ignoreClassMethods,\n          inputSourceMap\n        });\n        return {\n          visitor: {\n            Program: {\n              enter: ee.enter,\n\n              exit(path) {\n                output = ee.exit(path);\n              }\n\n            }\n          }\n        };\n      }]]\n    };\n    const codeMap = transformSync(code, babelOpts);\n\n    if (!output || !output.fileCoverage) {\n      const initialCoverage = readInitialCoverage(codeMap.ast) ||\n      /* istanbul ignore next: paranoid check */\n      {};\n      this.fileCoverage = initialCoverage.coverageData;\n      this.sourceMap = inputSourceMap;\n      return code;\n    }\n\n    this.fileCoverage = output.fileCoverage;\n    this.sourceMap = codeMap.map;\n    const cb = this.opts.sourceMapUrlCallback;\n\n    if (cb && output.sourceMappingURL) {\n      cb(filename, output.sourceMappingURL);\n    }\n\n    return codeMap.code;\n  }\n  /**\n   * callback-style instrument method that calls back with an error\n   * as opposed to throwing one. Note that in the current implementation,\n   * the callback will be called in the same process tick and is not asynchronous.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {Function} callback - the callback\n   * @param {Object} inputSourceMap - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   */\n\n\n  instrument(code, filename, callback, inputSourceMap) {\n    if (!callback && typeof filename === 'function') {\n      callback = filename;\n      filename = null;\n    }\n\n    try {\n      const out = this.instrumentSync(code, filename, inputSourceMap);\n      callback(null, out);\n    } catch (ex) {\n      callback(ex);\n    }\n  }\n  /**\n   * returns the file coverage object for the last file instrumented.\n   * @returns {Object} the file coverage object.\n   */\n\n\n  lastFileCoverage() {\n    return this.fileCoverage;\n  }\n  /**\n   * returns the source map produced for the last file instrumented.\n   * @returns {null|Object} the source map object.\n   */\n\n\n  lastSourceMap() {\n    return this.sourceMap;\n  }\n\n}\n\nmodule.exports = Instrumenter;","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/istanbul-lib-instrument/src/instrumenter.js"],"names":["transformSync","require","defaults","programVisitor","readInitialCoverage","Instrumenter","constructor","opts","instrumenter","fileCoverage","sourceMap","instrumentSync","code","filename","inputSourceMap","Error","String","Date","getTime","output","babelOpts","configFile","babelrc","ast","sourceMaps","produceSourceMap","compact","comments","preserveComments","parserOpts","allowReturnOutsideFunction","autoWrap","sourceType","esModules","plugins","parserPlugins","types","ee","coverageVariable","reportLogic","coverageGlobalScope","coverageGlobalScopeFunc","ignoreClassMethods","visitor","Program","enter","exit","path","codeMap","initialCoverage","coverageData","map","cb","sourceMapUrlCallback","sourceMappingURL","instrument","callback","out","ex","lastFileCoverage","lastSourceMap","module","exports"],"mappings":"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","sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nconst { transformSync } = require('@babel/core');\nconst { defaults } = require('@istanbuljs/schema');\nconst programVisitor = require('./visitor');\nconst readInitialCoverage = require('./read-coverage');\n\n/**\n * Instrumenter is the public API for the instrument library.\n * It is typically used for ES5 code. For ES6 code that you\n * are already running under `babel` use the coverage plugin\n * instead.\n * @param {Object} opts optional.\n * @param {string} [opts.coverageVariable=__coverage__] name of global coverage variable.\n * @param {boolean} [opts.reportLogic=false] report boolean value of logical expressions.\n * @param {boolean} [opts.preserveComments=false] preserve comments in output.\n * @param {boolean} [opts.compact=true] generate compact code.\n * @param {boolean} [opts.esModules=false] set to true to instrument ES6 modules.\n * @param {boolean} [opts.autoWrap=false] set to true to allow `return` statements outside of functions.\n * @param {boolean} [opts.produceSourceMap=false] set to true to produce a source map for the instrumented code.\n * @param {Array} [opts.ignoreClassMethods=[]] set to array of class method names to ignore for coverage.\n * @param {Function} [opts.sourceMapUrlCallback=null] a callback function that is called when a source map URL\n *     is found in the original code. This function is called with the source file name and the source map URL.\n * @param {boolean} [opts.debug=false] - turn debugging on.\n * @param {array} [opts.parserPlugins] - set babel parser plugins, see @istanbuljs/schema for defaults.\n */\nclass Instrumenter {\n    constructor(opts = {}) {\n        this.opts = {\n            ...defaults.instrumenter,\n            ...opts\n        };\n        this.fileCoverage = null;\n        this.sourceMap = null;\n    }\n    /**\n     * instrument the supplied code and track coverage against the supplied\n     * filename. It throws if invalid code is passed to it. ES5 and ES6 syntax\n     * is supported. To instrument ES6 modules, make sure that you set the\n     * `esModules` property to `true` when creating the instrumenter.\n     *\n     * @param {string} code - the code to instrument\n     * @param {string} filename - the filename against which to track coverage.\n     * @param {object} [inputSourceMap] - the source map that maps the not instrumented code back to it's original form.\n     * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n     * coverage to the untranspiled source.\n     * @returns {string} the instrumented code.\n     */\n    instrumentSync(code, filename, inputSourceMap) {\n        if (typeof code !== 'string') {\n            throw new Error('Code must be a string');\n        }\n        filename = filename || String(new Date().getTime()) + '.js';\n        const { opts } = this;\n        let output = {};\n        const babelOpts = {\n            configFile: false,\n            babelrc: false,\n            ast: true,\n            filename: filename || String(new Date().getTime()) + '.js',\n            inputSourceMap,\n            sourceMaps: opts.produceSourceMap,\n            compact: opts.compact,\n            comments: opts.preserveComments,\n            parserOpts: {\n                allowReturnOutsideFunction: opts.autoWrap,\n                sourceType: opts.esModules ? 'module' : 'script',\n                plugins: opts.parserPlugins\n            },\n            plugins: [\n                [\n                    ({ types }) => {\n                        const ee = programVisitor(types, filename, {\n                            coverageVariable: opts.coverageVariable,\n                            reportLogic: opts.reportLogic,\n                            coverageGlobalScope: opts.coverageGlobalScope,\n                            coverageGlobalScopeFunc:\n                                opts.coverageGlobalScopeFunc,\n                            ignoreClassMethods: opts.ignoreClassMethods,\n                            inputSourceMap\n                        });\n\n                        return {\n                            visitor: {\n                                Program: {\n                                    enter: ee.enter,\n                                    exit(path) {\n                                        output = ee.exit(path);\n                                    }\n                                }\n                            }\n                        };\n                    }\n                ]\n            ]\n        };\n\n        const codeMap = transformSync(code, babelOpts);\n\n        if (!output || !output.fileCoverage) {\n            const initialCoverage =\n                readInitialCoverage(codeMap.ast) ||\n                /* istanbul ignore next: paranoid check */ {};\n            this.fileCoverage = initialCoverage.coverageData;\n            this.sourceMap = inputSourceMap;\n            return code;\n        }\n\n        this.fileCoverage = output.fileCoverage;\n        this.sourceMap = codeMap.map;\n        const cb = this.opts.sourceMapUrlCallback;\n        if (cb && output.sourceMappingURL) {\n            cb(filename, output.sourceMappingURL);\n        }\n\n        return codeMap.code;\n    }\n    /**\n     * callback-style instrument method that calls back with an error\n     * as opposed to throwing one. Note that in the current implementation,\n     * the callback will be called in the same process tick and is not asynchronous.\n     *\n     * @param {string} code - the code to instrument\n     * @param {string} filename - the filename against which to track coverage.\n     * @param {Function} callback - the callback\n     * @param {Object} inputSourceMap - the source map that maps the not instrumented code back to it's original form.\n     * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n     * coverage to the untranspiled source.\n     */\n    instrument(code, filename, callback, inputSourceMap) {\n        if (!callback && typeof filename === 'function') {\n            callback = filename;\n            filename = null;\n        }\n        try {\n            const out = this.instrumentSync(code, filename, inputSourceMap);\n            callback(null, out);\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n    /**\n     * returns the file coverage object for the last file instrumented.\n     * @returns {Object} the file coverage object.\n     */\n    lastFileCoverage() {\n        return this.fileCoverage;\n    }\n    /**\n     * returns the source map produced for the last file instrumented.\n     * @returns {null|Object} the source map object.\n     */\n    lastSourceMap() {\n        return this.sourceMap;\n    }\n}\n\nmodule.exports = Instrumenter;\n"]},"metadata":{},"sourceType":"script"}