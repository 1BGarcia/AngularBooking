{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"E:\\\\M7ProyectoAngular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.augmentIndexHtml = void 0;\n\nconst crypto_1 = require(\"crypto\");\n\nconst load_esm_1 = require(\"../load-esm\");\n\nconst html_rewriting_stream_1 = require(\"./html-rewriting-stream\");\n/*\n * Helper function used by the IndexHtmlWebpackPlugin.\n * Can also be directly used by builder, e. g. in order to generate an index.html\n * after processing several configurations in order to build different sets of\n * bundles for differential serving.\n */\n\n\nfunction augmentIndexHtml(_x) {\n  return _augmentIndexHtml.apply(this, arguments);\n}\n\nfunction _augmentIndexHtml() {\n  _augmentIndexHtml = _asyncToGenerator(function* (params) {\n    const {\n      loadOutputFile,\n      files,\n      entrypoints,\n      sri,\n      deployUrl = '',\n      lang,\n      baseHref,\n      html\n    } = params;\n    const warnings = [];\n    const errors = [];\n    let {\n      crossOrigin = 'none'\n    } = params;\n\n    if (sri && crossOrigin === 'none') {\n      crossOrigin = 'anonymous';\n    }\n\n    const stylesheets = new Set();\n    const scripts = new Map(); // Sort files in the order we want to insert them by entrypoint\n\n    for (const [entrypoint, isModule] of entrypoints) {\n      for (const {\n        extension,\n        file,\n        name\n      } of files) {\n        if (name !== entrypoint || scripts.has(file) || stylesheets.has(file)) {\n          continue;\n        }\n\n        switch (extension) {\n          case '.js':\n            // Also, non entrypoints need to be loaded as no module as they can contain problematic code.\n            scripts.set(file, isModule);\n            break;\n\n          case '.css':\n            stylesheets.add(file);\n            break;\n        }\n      }\n    }\n\n    let scriptTags = [];\n\n    for (const [src, isModule] of scripts) {\n      const attrs = [`src=\"${deployUrl}${src}\"`]; // This is also need for non entry-points as they may contain problematic code.\n\n      if (isModule) {\n        attrs.push('type=\"module\"');\n      } else {\n        attrs.push('defer');\n      }\n\n      if (crossOrigin !== 'none') {\n        attrs.push(`crossorigin=\"${crossOrigin}\"`);\n      }\n\n      if (sri) {\n        const content = yield loadOutputFile(src);\n        attrs.push(generateSriAttributes(content));\n      }\n\n      scriptTags.push(`<script ${attrs.join(' ')}></script>`);\n    }\n\n    let linkTags = [];\n\n    for (const src of stylesheets) {\n      const attrs = [`rel=\"stylesheet\"`, `href=\"${deployUrl}${src}\"`];\n\n      if (crossOrigin !== 'none') {\n        attrs.push(`crossorigin=\"${crossOrigin}\"`);\n      }\n\n      if (sri) {\n        const content = yield loadOutputFile(src);\n        attrs.push(generateSriAttributes(content));\n      }\n\n      linkTags.push(`<link ${attrs.join(' ')}>`);\n    }\n\n    const dir = lang ? yield getLanguageDirection(lang, warnings) : undefined;\n    const {\n      rewriter,\n      transformedContent\n    } = yield (0, html_rewriting_stream_1.htmlRewritingStream)(html);\n    const baseTagExists = html.includes('<base');\n    rewriter.on('startTag', tag => {\n      switch (tag.tagName) {\n        case 'html':\n          // Adjust document locale if specified\n          if (isString(lang)) {\n            updateAttribute(tag, 'lang', lang);\n          }\n\n          if (dir) {\n            updateAttribute(tag, 'dir', dir);\n          }\n\n          break;\n\n        case 'head':\n          // Base href should be added before any link, meta tags\n          if (!baseTagExists && isString(baseHref)) {\n            rewriter.emitStartTag(tag);\n            rewriter.emitRaw(`<base href=\"${baseHref}\">`);\n            return;\n          }\n\n          break;\n\n        case 'base':\n          // Adjust base href if specified\n          if (isString(baseHref)) {\n            updateAttribute(tag, 'href', baseHref);\n          }\n\n          break;\n      }\n\n      rewriter.emitStartTag(tag);\n    }).on('endTag', tag => {\n      switch (tag.tagName) {\n        case 'head':\n          for (const linkTag of linkTags) {\n            rewriter.emitRaw(linkTag);\n          }\n\n          linkTags = [];\n          break;\n\n        case 'body':\n          // Add script tags\n          for (const scriptTag of scriptTags) {\n            rewriter.emitRaw(scriptTag);\n          }\n\n          scriptTags = [];\n          break;\n      }\n\n      rewriter.emitEndTag(tag);\n    });\n    const content = yield transformedContent;\n    return {\n      content: linkTags.length || scriptTags.length ? // In case no body/head tags are not present (dotnet partial templates)\n      linkTags.join('') + scriptTags.join('') + content : content,\n      warnings,\n      errors\n    };\n  });\n  return _augmentIndexHtml.apply(this, arguments);\n}\n\nexports.augmentIndexHtml = augmentIndexHtml;\n\nfunction generateSriAttributes(content) {\n  const algo = 'sha384';\n  const hash = (0, crypto_1.createHash)(algo).update(content, 'utf8').digest('base64');\n  return `integrity=\"${algo}-${hash}\"`;\n}\n\nfunction updateAttribute(tag, name, value) {\n  const index = tag.attrs.findIndex(a => a.name === name);\n  const newValue = {\n    name,\n    value\n  };\n\n  if (index === -1) {\n    tag.attrs.push(newValue);\n  } else {\n    tag.attrs[index] = newValue;\n  }\n}\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction getLanguageDirection(_x2, _x3) {\n  return _getLanguageDirection.apply(this, arguments);\n}\n\nfunction _getLanguageDirection() {\n  _getLanguageDirection = _asyncToGenerator(function* (locale, warnings) {\n    const dir = yield getLanguageDirectionFromLocales(locale);\n\n    if (!dir) {\n      warnings.push(`Locale data for '${locale}' cannot be found. 'dir' attribute will not be set for this locale.`);\n    }\n\n    return dir;\n  });\n  return _getLanguageDirection.apply(this, arguments);\n}\n\nfunction getLanguageDirectionFromLocales(_x4) {\n  return _getLanguageDirectionFromLocales.apply(this, arguments);\n}\n\nfunction _getLanguageDirectionFromLocales() {\n  _getLanguageDirectionFromLocales = _asyncToGenerator(function* (locale) {\n    try {\n      const localeData = (yield (0, load_esm_1.loadEsmModule)(`@angular/common/locales/${locale}`)).default;\n      const dir = localeData[localeData.length - 2];\n      return isString(dir) ? dir : undefined;\n    } catch {\n      // In some cases certain locales might map to files which are named only with language id.\n      // Example: `en-US` -> `en`.\n      const [languageId] = locale.split('-', 1);\n\n      if (languageId !== locale) {\n        return getLanguageDirectionFromLocales(languageId);\n      }\n    }\n\n    return undefined;\n  });\n  return _getLanguageDirectionFromLocales.apply(this, arguments);\n}","map":{"version":3,"sources":["E:/M7ProyectoAngular/node_modules/@angular-devkit/build-angular/src/utils/index-file/augment-index-html.js"],"names":["Object","defineProperty","exports","value","augmentIndexHtml","crypto_1","require","load_esm_1","html_rewriting_stream_1","params","loadOutputFile","files","entrypoints","sri","deployUrl","lang","baseHref","html","warnings","errors","crossOrigin","stylesheets","Set","scripts","Map","entrypoint","isModule","extension","file","name","has","set","add","scriptTags","src","attrs","push","content","generateSriAttributes","join","linkTags","dir","getLanguageDirection","undefined","rewriter","transformedContent","htmlRewritingStream","baseTagExists","includes","on","tag","tagName","isString","updateAttribute","emitStartTag","emitRaw","linkTag","scriptTag","emitEndTag","length","algo","hash","createHash","update","digest","index","findIndex","a","newValue","locale","getLanguageDirectionFromLocales","localeData","loadEsmModule","default","languageId","split"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.augmentIndexHtml = void 0;\nconst crypto_1 = require(\"crypto\");\nconst load_esm_1 = require(\"../load-esm\");\nconst html_rewriting_stream_1 = require(\"./html-rewriting-stream\");\n/*\n * Helper function used by the IndexHtmlWebpackPlugin.\n * Can also be directly used by builder, e. g. in order to generate an index.html\n * after processing several configurations in order to build different sets of\n * bundles for differential serving.\n */\nasync function augmentIndexHtml(params) {\n    const { loadOutputFile, files, entrypoints, sri, deployUrl = '', lang, baseHref, html } = params;\n    const warnings = [];\n    const errors = [];\n    let { crossOrigin = 'none' } = params;\n    if (sri && crossOrigin === 'none') {\n        crossOrigin = 'anonymous';\n    }\n    const stylesheets = new Set();\n    const scripts = new Map();\n    // Sort files in the order we want to insert them by entrypoint\n    for (const [entrypoint, isModule] of entrypoints) {\n        for (const { extension, file, name } of files) {\n            if (name !== entrypoint || scripts.has(file) || stylesheets.has(file)) {\n                continue;\n            }\n            switch (extension) {\n                case '.js':\n                    // Also, non entrypoints need to be loaded as no module as they can contain problematic code.\n                    scripts.set(file, isModule);\n                    break;\n                case '.css':\n                    stylesheets.add(file);\n                    break;\n            }\n        }\n    }\n    let scriptTags = [];\n    for (const [src, isModule] of scripts) {\n        const attrs = [`src=\"${deployUrl}${src}\"`];\n        // This is also need for non entry-points as they may contain problematic code.\n        if (isModule) {\n            attrs.push('type=\"module\"');\n        }\n        else {\n            attrs.push('defer');\n        }\n        if (crossOrigin !== 'none') {\n            attrs.push(`crossorigin=\"${crossOrigin}\"`);\n        }\n        if (sri) {\n            const content = await loadOutputFile(src);\n            attrs.push(generateSriAttributes(content));\n        }\n        scriptTags.push(`<script ${attrs.join(' ')}></script>`);\n    }\n    let linkTags = [];\n    for (const src of stylesheets) {\n        const attrs = [`rel=\"stylesheet\"`, `href=\"${deployUrl}${src}\"`];\n        if (crossOrigin !== 'none') {\n            attrs.push(`crossorigin=\"${crossOrigin}\"`);\n        }\n        if (sri) {\n            const content = await loadOutputFile(src);\n            attrs.push(generateSriAttributes(content));\n        }\n        linkTags.push(`<link ${attrs.join(' ')}>`);\n    }\n    const dir = lang ? await getLanguageDirection(lang, warnings) : undefined;\n    const { rewriter, transformedContent } = await (0, html_rewriting_stream_1.htmlRewritingStream)(html);\n    const baseTagExists = html.includes('<base');\n    rewriter\n        .on('startTag', (tag) => {\n        switch (tag.tagName) {\n            case 'html':\n                // Adjust document locale if specified\n                if (isString(lang)) {\n                    updateAttribute(tag, 'lang', lang);\n                }\n                if (dir) {\n                    updateAttribute(tag, 'dir', dir);\n                }\n                break;\n            case 'head':\n                // Base href should be added before any link, meta tags\n                if (!baseTagExists && isString(baseHref)) {\n                    rewriter.emitStartTag(tag);\n                    rewriter.emitRaw(`<base href=\"${baseHref}\">`);\n                    return;\n                }\n                break;\n            case 'base':\n                // Adjust base href if specified\n                if (isString(baseHref)) {\n                    updateAttribute(tag, 'href', baseHref);\n                }\n                break;\n        }\n        rewriter.emitStartTag(tag);\n    })\n        .on('endTag', (tag) => {\n        switch (tag.tagName) {\n            case 'head':\n                for (const linkTag of linkTags) {\n                    rewriter.emitRaw(linkTag);\n                }\n                linkTags = [];\n                break;\n            case 'body':\n                // Add script tags\n                for (const scriptTag of scriptTags) {\n                    rewriter.emitRaw(scriptTag);\n                }\n                scriptTags = [];\n                break;\n        }\n        rewriter.emitEndTag(tag);\n    });\n    const content = await transformedContent;\n    return {\n        content: linkTags.length || scriptTags.length\n            ? // In case no body/head tags are not present (dotnet partial templates)\n                linkTags.join('') + scriptTags.join('') + content\n            : content,\n        warnings,\n        errors,\n    };\n}\nexports.augmentIndexHtml = augmentIndexHtml;\nfunction generateSriAttributes(content) {\n    const algo = 'sha384';\n    const hash = (0, crypto_1.createHash)(algo).update(content, 'utf8').digest('base64');\n    return `integrity=\"${algo}-${hash}\"`;\n}\nfunction updateAttribute(tag, name, value) {\n    const index = tag.attrs.findIndex((a) => a.name === name);\n    const newValue = { name, value };\n    if (index === -1) {\n        tag.attrs.push(newValue);\n    }\n    else {\n        tag.attrs[index] = newValue;\n    }\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nasync function getLanguageDirection(locale, warnings) {\n    const dir = await getLanguageDirectionFromLocales(locale);\n    if (!dir) {\n        warnings.push(`Locale data for '${locale}' cannot be found. 'dir' attribute will not be set for this locale.`);\n    }\n    return dir;\n}\nasync function getLanguageDirectionFromLocales(locale) {\n    try {\n        const localeData = (await (0, load_esm_1.loadEsmModule)(`@angular/common/locales/${locale}`)).default;\n        const dir = localeData[localeData.length - 2];\n        return isString(dir) ? dir : undefined;\n    }\n    catch {\n        // In some cases certain locales might map to files which are named only with language id.\n        // Example: `en-US` -> `en`.\n        const [languageId] = locale.split('-', 1);\n        if (languageId !== locale) {\n            return getLanguageDirectionFromLocales(languageId);\n        }\n    }\n    return undefined;\n}\n"]},"metadata":{},"sourceType":"script"}